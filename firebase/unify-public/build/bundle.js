
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function (AOS) {
    'use strict';

    function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

    var AOS__default = /*#__PURE__*/_interopDefaultLegacy(AOS);

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function compute_rest_props(props, keys) {
        const rest = {};
        keys = new Set(keys);
        for (const k in props)
            if (!keys.has(k) && k[0] !== '$')
                rest[k] = props[k];
        return rest;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function set_custom_element_data(node, prop, value) {
        if (prop in node) {
            node[prop] = value;
        }
        else {
            attr(node, prop, value);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +
            'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = "data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>";
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }
    class HtmlTag {
        constructor(anchor = null) {
            this.a = anchor;
            this.e = this.n = null;
        }
        m(html, target, anchor = null) {
            if (!this.e) {
                this.e = element(target.nodeName);
                this.t = target;
                this.h(html);
            }
            this.i(anchor);
        }
        h(html) {
            this.e.innerHTML = html;
            this.n = Array.from(this.e.childNodes);
        }
        i(anchor) {
            for (let i = 0; i < this.n.length; i += 1) {
                insert(this.t, this.n[i], anchor);
            }
        }
        p(html) {
            this.d();
            this.h(html);
            this.i(this.a);
        }
        d() {
            this.n.forEach(detach);
        }
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error('Cannot have duplicate keys in a keyed each');
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.32.3' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev('SvelteDOMSetProperty', { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable$1(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable$1(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    const LOCATION = {};
    const ROUTER = {};

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/history.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    function getLocation(source) {
      return {
        ...source.location,
        state: source.history.state,
        key: (source.history.state && source.history.state.key) || "initial"
      };
    }

    function createHistory(source, options) {
      const listeners = [];
      let location = getLocation(source);

      return {
        get location() {
          return location;
        },

        listen(listener) {
          listeners.push(listener);

          const popstateListener = () => {
            location = getLocation(source);
            listener({ location, action: "POP" });
          };

          source.addEventListener("popstate", popstateListener);

          return () => {
            source.removeEventListener("popstate", popstateListener);

            const index = listeners.indexOf(listener);
            listeners.splice(index, 1);
          };
        },

        navigate(to, { state, replace = false } = {}) {
          state = { ...state, key: Date.now() + "" };
          // try...catch iOS Safari limits to 100 pushState calls
          try {
            if (replace) {
              source.history.replaceState(state, null, to);
            } else {
              source.history.pushState(state, null, to);
            }
          } catch (e) {
            source.location[replace ? "replace" : "assign"](to);
          }

          location = getLocation(source);
          listeners.forEach(listener => listener({ location, action: "PUSH" }));
        }
      };
    }

    // Stores history entries in memory for testing or other platforms like Native
    function createMemorySource(initialPathname = "/") {
      let index = 0;
      const stack = [{ pathname: initialPathname, search: "" }];
      const states = [];

      return {
        get location() {
          return stack[index];
        },
        addEventListener(name, fn) {},
        removeEventListener(name, fn) {},
        history: {
          get entries() {
            return stack;
          },
          get index() {
            return index;
          },
          get state() {
            return states[index];
          },
          pushState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            index++;
            stack.push({ pathname, search });
            states.push(state);
          },
          replaceState(state, _, uri) {
            const [pathname, search = ""] = uri.split("?");
            stack[index] = { pathname, search };
            states[index] = state;
          }
        }
      };
    }

    // Global history uses window.history as the source if available,
    // otherwise a memory history
    const canUseDOM = Boolean(
      typeof window !== "undefined" &&
        window.document &&
        window.document.createElement
    );
    const globalHistory = createHistory(canUseDOM ? window : createMemorySource());
    const { navigate } = globalHistory;

    /**
     * Adapted from https://github.com/reach/router/blob/b60e6dd781d5d3a4bdaaf4de665649c0f6a7e78d/src/lib/utils.js
     *
     * https://github.com/reach/router/blob/master/LICENSE
     * */

    const paramRe = /^:(.+)/;

    const SEGMENT_POINTS = 4;
    const STATIC_POINTS = 3;
    const DYNAMIC_POINTS = 2;
    const SPLAT_PENALTY = 1;
    const ROOT_POINTS = 1;

    /**
     * Check if `string` starts with `search`
     * @param {string} string
     * @param {string} search
     * @return {boolean}
     */
    function startsWith(string, search) {
      return string.substr(0, search.length) === search;
    }

    /**
     * Check if `segment` is a root segment
     * @param {string} segment
     * @return {boolean}
     */
    function isRootSegment(segment) {
      return segment === "";
    }

    /**
     * Check if `segment` is a dynamic segment
     * @param {string} segment
     * @return {boolean}
     */
    function isDynamic(segment) {
      return paramRe.test(segment);
    }

    /**
     * Check if `segment` is a splat
     * @param {string} segment
     * @return {boolean}
     */
    function isSplat(segment) {
      return segment[0] === "*";
    }

    /**
     * Split up the URI into segments delimited by `/`
     * @param {string} uri
     * @return {string[]}
     */
    function segmentize(uri) {
      return (
        uri
          // Strip starting/ending `/`
          .replace(/(^\/+|\/+$)/g, "")
          .split("/")
      );
    }

    /**
     * Strip `str` of potential start and end `/`
     * @param {string} str
     * @return {string}
     */
    function stripSlashes(str) {
      return str.replace(/(^\/+|\/+$)/g, "");
    }

    /**
     * Score a route depending on how its individual segments look
     * @param {object} route
     * @param {number} index
     * @return {object}
     */
    function rankRoute(route, index) {
      const score = route.default
        ? 0
        : segmentize(route.path).reduce((score, segment) => {
            score += SEGMENT_POINTS;

            if (isRootSegment(segment)) {
              score += ROOT_POINTS;
            } else if (isDynamic(segment)) {
              score += DYNAMIC_POINTS;
            } else if (isSplat(segment)) {
              score -= SEGMENT_POINTS + SPLAT_PENALTY;
            } else {
              score += STATIC_POINTS;
            }

            return score;
          }, 0);

      return { route, score, index };
    }

    /**
     * Give a score to all routes and sort them on that
     * @param {object[]} routes
     * @return {object[]}
     */
    function rankRoutes(routes) {
      return (
        routes
          .map(rankRoute)
          // If two routes have the exact same score, we go by index instead
          .sort((a, b) =>
            a.score < b.score ? 1 : a.score > b.score ? -1 : a.index - b.index
          )
      );
    }

    /**
     * Ranks and picks the best route to match. Each segment gets the highest
     * amount of points, then the type of segment gets an additional amount of
     * points where
     *
     *  static > dynamic > splat > root
     *
     * This way we don't have to worry about the order of our routes, let the
     * computers do it.
     *
     * A route looks like this
     *
     *  { path, default, value }
     *
     * And a returned match looks like:
     *
     *  { route, params, uri }
     *
     * @param {object[]} routes
     * @param {string} uri
     * @return {?object}
     */
    function pick(routes, uri) {
      let match;
      let default_;

      const [uriPathname] = uri.split("?");
      const uriSegments = segmentize(uriPathname);
      const isRootUri = uriSegments[0] === "";
      const ranked = rankRoutes(routes);

      for (let i = 0, l = ranked.length; i < l; i++) {
        const route = ranked[i].route;
        let missed = false;

        if (route.default) {
          default_ = {
            route,
            params: {},
            uri
          };
          continue;
        }

        const routeSegments = segmentize(route.path);
        const params = {};
        const max = Math.max(uriSegments.length, routeSegments.length);
        let index = 0;

        for (; index < max; index++) {
          const routeSegment = routeSegments[index];
          const uriSegment = uriSegments[index];

          if (routeSegment !== undefined && isSplat(routeSegment)) {
            // Hit a splat, just grab the rest, and return a match
            // uri:   /files/documents/work
            // route: /files/* or /files/*splatname
            const splatName = routeSegment === "*" ? "*" : routeSegment.slice(1);

            params[splatName] = uriSegments
              .slice(index)
              .map(decodeURIComponent)
              .join("/");
            break;
          }

          if (uriSegment === undefined) {
            // URI is shorter than the route, no match
            // uri:   /users
            // route: /users/:userId
            missed = true;
            break;
          }

          let dynamicMatch = paramRe.exec(routeSegment);

          if (dynamicMatch && !isRootUri) {
            const value = decodeURIComponent(uriSegment);
            params[dynamicMatch[1]] = value;
          } else if (routeSegment !== uriSegment) {
            // Current segments don't match, not dynamic, not splat, so no match
            // uri:   /users/123/settings
            // route: /users/:id/profile
            missed = true;
            break;
          }
        }

        if (!missed) {
          match = {
            route,
            params,
            uri: "/" + uriSegments.slice(0, index).join("/")
          };
          break;
        }
      }

      return match || default_ || null;
    }

    /**
     * Check if the `path` matches the `uri`.
     * @param {string} path
     * @param {string} uri
     * @return {?object}
     */
    function match(route, uri) {
      return pick([route], uri);
    }

    /**
     * Add the query to the pathname if a query is given
     * @param {string} pathname
     * @param {string} [query]
     * @return {string}
     */
    function addQuery(pathname, query) {
      return pathname + (query ? `?${query}` : "");
    }

    /**
     * Resolve URIs as though every path is a directory, no files. Relative URIs
     * in the browser can feel awkward because not only can you be "in a directory",
     * you can be "at a file", too. For example:
     *
     *  browserSpecResolve('foo', '/bar/') => /bar/foo
     *  browserSpecResolve('foo', '/bar') => /foo
     *
     * But on the command line of a file system, it's not as complicated. You can't
     * `cd` from a file, only directories. This way, links have to know less about
     * their current path. To go deeper you can do this:
     *
     *  <Link to="deeper"/>
     *  // instead of
     *  <Link to=`{${props.uri}/deeper}`/>
     *
     * Just like `cd`, if you want to go deeper from the command line, you do this:
     *
     *  cd deeper
     *  # not
     *  cd $(pwd)/deeper
     *
     * By treating every path as a directory, linking to relative paths should
     * require less contextual information and (fingers crossed) be more intuitive.
     * @param {string} to
     * @param {string} base
     * @return {string}
     */
    function resolve(to, base) {
      // /foo/bar, /baz/qux => /foo/bar
      if (startsWith(to, "/")) {
        return to;
      }

      const [toPathname, toQuery] = to.split("?");
      const [basePathname] = base.split("?");
      const toSegments = segmentize(toPathname);
      const baseSegments = segmentize(basePathname);

      // ?a=b, /users?b=c => /users?a=b
      if (toSegments[0] === "") {
        return addQuery(basePathname, toQuery);
      }

      // profile, /users/789 => /users/789/profile
      if (!startsWith(toSegments[0], ".")) {
        const pathname = baseSegments.concat(toSegments).join("/");

        return addQuery((basePathname === "/" ? "" : "/") + pathname, toQuery);
      }

      // ./       , /users/123 => /users/123
      // ../      , /users/123 => /users
      // ../..    , /users/123 => /
      // ../../one, /a/b/c/d   => /a/b/one
      // .././one , /a/b/c/d   => /a/b/c/one
      const allSegments = baseSegments.concat(toSegments);
      const segments = [];

      allSegments.forEach(segment => {
        if (segment === "..") {
          segments.pop();
        } else if (segment !== ".") {
          segments.push(segment);
        }
      });

      return addQuery("/" + segments.join("/"), toQuery);
    }

    /**
     * Combines the `basepath` and the `path` into one path.
     * @param {string} basepath
     * @param {string} path
     */
    function combinePaths(basepath, path) {
      return `${stripSlashes(
    path === "/" ? basepath : `${stripSlashes(basepath)}/${stripSlashes(path)}`
  )}/`;
    }

    /**
     * Decides whether a given `event` should result in a navigation or not.
     * @param {object} event
     */
    function shouldNavigate(event) {
      return (
        !event.defaultPrevented &&
        event.button === 0 &&
        !(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey)
      );
    }

    function hostMatches(anchor) {
      const host = location.host;
      return (
        anchor.host == host ||
        // svelte seems to kill anchor.host value in ie11, so fall back to checking href
        anchor.href.indexOf(`https://${host}`) === 0 ||
        anchor.href.indexOf(`http://${host}`) === 0
      )
    }

    /* node_modules\svelte-routing\src\Router.svelte generated by Svelte v3.32.3 */

    function create_fragment(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[9].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 256) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[8], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let $base;
    	let $location;
    	let $routes;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Router", slots, ['default']);
    	let { basepath = "/" } = $$props;
    	let { url = null } = $$props;
    	const locationContext = getContext(LOCATION);
    	const routerContext = getContext(ROUTER);
    	const routes = writable([]);
    	validate_store(routes, "routes");
    	component_subscribe($$self, routes, value => $$invalidate(7, $routes = value));
    	const activeRoute = writable(null);
    	let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.

    	// If locationContext is not set, this is the topmost Router in the tree.
    	// If the `url` prop is given we force the location to it.
    	const location = locationContext || writable(url ? { pathname: url } : globalHistory.location);

    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(6, $location = value));

    	// If routerContext is set, the routerBase of the parent Router
    	// will be the base for this Router's descendants.
    	// If routerContext is not set, the path and resolved uri will both
    	// have the value of the basepath prop.
    	const base = routerContext
    	? routerContext.routerBase
    	: writable({ path: basepath, uri: basepath });

    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate(5, $base = value));

    	const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
    		// If there is no activeRoute, the routerBase will be identical to the base.
    		if (activeRoute === null) {
    			return base;
    		}

    		const { path: basepath } = base;
    		const { route, uri } = activeRoute;

    		// Remove the potential /* or /*splatname from
    		// the end of the child Routes relative paths.
    		const path = route.default
    		? basepath
    		: route.path.replace(/\*.*$/, "");

    		return { path, uri };
    	});

    	function registerRoute(route) {
    		const { path: basepath } = $base;
    		let { path } = route;

    		// We store the original path in the _path property so we can reuse
    		// it when the basepath changes. The only thing that matters is that
    		// the route reference is intact, so mutation is fine.
    		route._path = path;

    		route.path = combinePaths(basepath, path);

    		if (typeof window === "undefined") {
    			// In SSR we should set the activeRoute immediately if it is a match.
    			// If there are more Routes being registered after a match is found,
    			// we just skip them.
    			if (hasActiveRoute) {
    				return;
    			}

    			const matchingRoute = match(route, $location.pathname);

    			if (matchingRoute) {
    				activeRoute.set(matchingRoute);
    				hasActiveRoute = true;
    			}
    		} else {
    			routes.update(rs => {
    				rs.push(route);
    				return rs;
    			});
    		}
    	}

    	function unregisterRoute(route) {
    		routes.update(rs => {
    			const index = rs.indexOf(route);
    			rs.splice(index, 1);
    			return rs;
    		});
    	}

    	if (!locationContext) {
    		// The topmost Router in the tree is responsible for updating
    		// the location store and supplying it through context.
    		onMount(() => {
    			const unlisten = globalHistory.listen(history => {
    				location.set(history.location);
    			});

    			return unlisten;
    		});

    		setContext(LOCATION, location);
    	}

    	setContext(ROUTER, {
    		activeRoute,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute
    	});

    	const writable_props = ["basepath", "url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("$$scope" in $$props) $$invalidate(8, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		onMount,
    		writable,
    		derived,
    		LOCATION,
    		ROUTER,
    		globalHistory,
    		pick,
    		match,
    		stripSlashes,
    		combinePaths,
    		basepath,
    		url,
    		locationContext,
    		routerContext,
    		routes,
    		activeRoute,
    		hasActiveRoute,
    		location,
    		base,
    		routerBase,
    		registerRoute,
    		unregisterRoute,
    		$base,
    		$location,
    		$routes
    	});

    	$$self.$inject_state = $$props => {
    		if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    		if ("url" in $$props) $$invalidate(4, url = $$props.url);
    		if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$base*/ 32) {
    			// This reactive statement will update all the Routes' path when
    			// the basepath changes.
    			{
    				const { path: basepath } = $base;

    				routes.update(rs => {
    					rs.forEach(r => r.path = combinePaths(basepath, r._path));
    					return rs;
    				});
    			}
    		}

    		if ($$self.$$.dirty & /*$routes, $location*/ 192) {
    			// This reactive statement will be run when the Router is created
    			// when there are no Routes and then again the following tick, so it
    			// will not find an active Route in SSR and in the browser it will only
    			// pick an active Route after all Routes have been registered.
    			{
    				const bestMatch = pick($routes, $location.pathname);
    				activeRoute.set(bestMatch);
    			}
    		}
    	};

    	return [
    		routes,
    		location,
    		base,
    		basepath,
    		url,
    		$base,
    		$location,
    		$routes,
    		$$scope,
    		slots
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { basepath: 3, url: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get basepath() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set basepath(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-routing\src\Route.svelte generated by Svelte v3.32.3 */

    const get_default_slot_changes = dirty => ({
    	params: dirty & /*routeParams*/ 4,
    	location: dirty & /*$location*/ 16
    });

    const get_default_slot_context = ctx => ({
    	params: /*routeParams*/ ctx[2],
    	location: /*$location*/ ctx[4]
    });

    // (40:0) {#if $activeRoute !== null && $activeRoute.route === route}
    function create_if_block(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*component*/ ctx[0] !== null) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(40:0) {#if $activeRoute !== null && $activeRoute.route === route}",
    		ctx
    	});

    	return block;
    }

    // (43:2) {:else}
    function create_else_block(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, routeParams, $location*/ 532) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(43:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:2) {#if component !== null}
    function create_if_block_1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		{ location: /*$location*/ ctx[4] },
    		/*routeParams*/ ctx[2],
    		/*routeProps*/ ctx[3]
    	];

    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*$location, routeParams, routeProps*/ 28)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*$location*/ 16 && { location: /*$location*/ ctx[4] },
    					dirty & /*routeParams*/ 4 && get_spread_object(/*routeParams*/ ctx[2]),
    					dirty & /*routeProps*/ 8 && get_spread_object(/*routeProps*/ ctx[3])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(41:2) {#if component !== null}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$activeRoute*/ ctx[1] !== null && /*$activeRoute*/ ctx[1].route === /*route*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$activeRoute*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $activeRoute;
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Route", slots, ['default']);
    	let { path = "" } = $$props;
    	let { component = null } = $$props;
    	const { registerRoute, unregisterRoute, activeRoute } = getContext(ROUTER);
    	validate_store(activeRoute, "activeRoute");
    	component_subscribe($$self, activeRoute, value => $$invalidate(1, $activeRoute = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(4, $location = value));

    	const route = {
    		path,
    		// If no path prop is given, this Route will act as the default Route
    		// that is rendered if no other Route in the Router is a match.
    		default: path === ""
    	};

    	let routeParams = {};
    	let routeProps = {};
    	registerRoute(route);

    	// There is no need to unregister Routes in SSR since it will all be
    	// thrown away anyway.
    	if (typeof window !== "undefined") {
    		onDestroy(() => {
    			unregisterRoute(route);
    		});
    	}

    	$$self.$$set = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
    		if ("path" in $$new_props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$new_props) $$invalidate(0, component = $$new_props.component);
    		if ("$$scope" in $$new_props) $$invalidate(9, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		onDestroy,
    		ROUTER,
    		LOCATION,
    		path,
    		component,
    		registerRoute,
    		unregisterRoute,
    		activeRoute,
    		location,
    		route,
    		routeParams,
    		routeProps,
    		$activeRoute,
    		$location
    	});

    	$$self.$inject_state = $$new_props => {
    		$$invalidate(13, $$props = assign(assign({}, $$props), $$new_props));
    		if ("path" in $$props) $$invalidate(8, path = $$new_props.path);
    		if ("component" in $$props) $$invalidate(0, component = $$new_props.component);
    		if ("routeParams" in $$props) $$invalidate(2, routeParams = $$new_props.routeParams);
    		if ("routeProps" in $$props) $$invalidate(3, routeProps = $$new_props.routeProps);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeRoute*/ 2) {
    			if ($activeRoute && $activeRoute.route === route) {
    				$$invalidate(2, routeParams = $activeRoute.params);
    			}
    		}

    		{
    			const { path, component, ...rest } = $$props;
    			$$invalidate(3, routeProps = rest);
    		}
    	};

    	$$props = exclude_internal_props($$props);

    	return [
    		component,
    		$activeRoute,
    		routeParams,
    		routeProps,
    		$location,
    		activeRoute,
    		location,
    		route,
    		path,
    		$$scope,
    		slots
    	];
    }

    class Route extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { path: 8, component: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Route",
    			options,
    			id: create_fragment$1.name
    		});
    	}

    	get path() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get component() {
    		throw new Error("<Route>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set component(value) {
    		throw new Error("<Route>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-routing\src\Link.svelte generated by Svelte v3.32.3 */
    const file = "node_modules\\svelte-routing\\src\\Link.svelte";

    function create_fragment$2(ctx) {
    	let a;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[16].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

    	let a_levels = [
    		{ href: /*href*/ ctx[0] },
    		{ "aria-current": /*ariaCurrent*/ ctx[2] },
    		/*props*/ ctx[1],
    		/*$$restProps*/ ctx[6]
    	];

    	let a_data = {};

    	for (let i = 0; i < a_levels.length; i += 1) {
    		a_data = assign(a_data, a_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();
    			set_attributes(a, a_data);
    			add_location(a, file, 40, 0, 1249);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*onClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32768) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[15], dirty, null, null);
    				}
    			}

    			set_attributes(a, a_data = get_spread_update(a_levels, [
    				(!current || dirty & /*href*/ 1) && { href: /*href*/ ctx[0] },
    				(!current || dirty & /*ariaCurrent*/ 4) && { "aria-current": /*ariaCurrent*/ ctx[2] },
    				dirty & /*props*/ 2 && /*props*/ ctx[1],
    				dirty & /*$$restProps*/ 64 && /*$$restProps*/ ctx[6]
    			]));
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let ariaCurrent;
    	const omit_props_names = ["to","replace","state","getProps"];
    	let $$restProps = compute_rest_props($$props, omit_props_names);
    	let $base;
    	let $location;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Link", slots, ['default']);
    	let { to = "#" } = $$props;
    	let { replace = false } = $$props;
    	let { state = {} } = $$props;
    	let { getProps = () => ({}) } = $$props;
    	const { base } = getContext(ROUTER);
    	validate_store(base, "base");
    	component_subscribe($$self, base, value => $$invalidate(13, $base = value));
    	const location = getContext(LOCATION);
    	validate_store(location, "location");
    	component_subscribe($$self, location, value => $$invalidate(14, $location = value));
    	const dispatch = createEventDispatcher();
    	let href, isPartiallyCurrent, isCurrent, props;

    	function onClick(event) {
    		dispatch("click", event);

    		if (shouldNavigate(event)) {
    			event.preventDefault();

    			// Don't push another entry to the history stack when the user
    			// clicks on a Link to the page they are currently on.
    			const shouldReplace = $location.pathname === href || replace;

    			navigate(href, { state, replace: shouldReplace });
    		}
    	}

    	$$self.$$set = $$new_props => {
    		$$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    		$$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    		if ("to" in $$new_props) $$invalidate(7, to = $$new_props.to);
    		if ("replace" in $$new_props) $$invalidate(8, replace = $$new_props.replace);
    		if ("state" in $$new_props) $$invalidate(9, state = $$new_props.state);
    		if ("getProps" in $$new_props) $$invalidate(10, getProps = $$new_props.getProps);
    		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		createEventDispatcher,
    		ROUTER,
    		LOCATION,
    		navigate,
    		startsWith,
    		resolve,
    		shouldNavigate,
    		to,
    		replace,
    		state,
    		getProps,
    		base,
    		location,
    		dispatch,
    		href,
    		isPartiallyCurrent,
    		isCurrent,
    		props,
    		onClick,
    		$base,
    		$location,
    		ariaCurrent
    	});

    	$$self.$inject_state = $$new_props => {
    		if ("to" in $$props) $$invalidate(7, to = $$new_props.to);
    		if ("replace" in $$props) $$invalidate(8, replace = $$new_props.replace);
    		if ("state" in $$props) $$invalidate(9, state = $$new_props.state);
    		if ("getProps" in $$props) $$invalidate(10, getProps = $$new_props.getProps);
    		if ("href" in $$props) $$invalidate(0, href = $$new_props.href);
    		if ("isPartiallyCurrent" in $$props) $$invalidate(11, isPartiallyCurrent = $$new_props.isPartiallyCurrent);
    		if ("isCurrent" in $$props) $$invalidate(12, isCurrent = $$new_props.isCurrent);
    		if ("props" in $$props) $$invalidate(1, props = $$new_props.props);
    		if ("ariaCurrent" in $$props) $$invalidate(2, ariaCurrent = $$new_props.ariaCurrent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*to, $base*/ 8320) {
    			$$invalidate(0, href = to === "/" ? $base.uri : resolve(to, $base.uri));
    		}

    		if ($$self.$$.dirty & /*$location, href*/ 16385) {
    			$$invalidate(11, isPartiallyCurrent = startsWith($location.pathname, href));
    		}

    		if ($$self.$$.dirty & /*href, $location*/ 16385) {
    			$$invalidate(12, isCurrent = href === $location.pathname);
    		}

    		if ($$self.$$.dirty & /*isCurrent*/ 4096) {
    			$$invalidate(2, ariaCurrent = isCurrent ? "page" : undefined);
    		}

    		if ($$self.$$.dirty & /*getProps, $location, href, isPartiallyCurrent, isCurrent*/ 23553) {
    			$$invalidate(1, props = getProps({
    				location: $location,
    				href,
    				isPartiallyCurrent,
    				isCurrent
    			}));
    		}
    	};

    	return [
    		href,
    		props,
    		ariaCurrent,
    		base,
    		location,
    		onClick,
    		$$restProps,
    		to,
    		replace,
    		state,
    		getProps,
    		isPartiallyCurrent,
    		isCurrent,
    		$base,
    		$location,
    		$$scope,
    		slots
    	];
    }

    class Link extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
    			to: 7,
    			replace: 8,
    			state: 9,
    			getProps: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Link",
    			options,
    			id: create_fragment$2.name
    		});
    	}

    	get to() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get replace() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set replace(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get state() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set state(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getProps() {
    		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getProps(value) {
    		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /**
     * A link action that can be added to <a href=""> tags rather
     * than using the <Link> component.
     *
     * Example:
     * ```html
     * <a href="/post/{postId}" use:link>{post.title}</a>
     * ```
     */
    function link(node) {
      function onClick(event) {
        const anchor = event.currentTarget;

        if (
          anchor.target === "" &&
          hostMatches(anchor) &&
          shouldNavigate(event)
        ) {
          event.preventDefault();
          navigate(anchor.pathname + anchor.search, { replace: anchor.hasAttribute("replace") });
        }
      }

      node.addEventListener("click", onClick);

      return {
        destroy() {
          node.removeEventListener("click", onClick);
        }
      };
    }

    /* src\routes\NotFound.svelte generated by Svelte v3.32.3 */

    function create_fragment$3(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NotFound", slots, []);
    	let { params = {} } = $$props;
    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NotFound> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ params });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params];
    }

    class NotFound extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NotFound",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get params() {
    		throw new Error("<NotFound>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<NotFound>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m) return m.call(o);
        if (o && typeof o.length === "number") return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    /**
     * Session Status
     */
    var SessionStatus;
    (function (SessionStatus) {
        /** JSDoc */
        SessionStatus["Ok"] = "ok";
        /** JSDoc */
        SessionStatus["Exited"] = "exited";
        /** JSDoc */
        SessionStatus["Crashed"] = "crashed";
        /** JSDoc */
        SessionStatus["Abnormal"] = "abnormal";
    })(SessionStatus || (SessionStatus = {}));

    /** JSDoc */
    // eslint-disable-next-line import/export
    var Severity;
    (function (Severity) {
        /** JSDoc */
        Severity["Fatal"] = "fatal";
        /** JSDoc */
        Severity["Error"] = "error";
        /** JSDoc */
        Severity["Warning"] = "warning";
        /** JSDoc */
        Severity["Log"] = "log";
        /** JSDoc */
        Severity["Info"] = "info";
        /** JSDoc */
        Severity["Debug"] = "debug";
        /** JSDoc */
        Severity["Critical"] = "critical";
    })(Severity || (Severity = {}));
    // eslint-disable-next-line @typescript-eslint/no-namespace, import/export
    (function (Severity) {
        /**
         * Converts a string-based level into a {@link Severity}.
         *
         * @param level string representation of Severity
         * @returns Severity
         */
        function fromString(level) {
            switch (level) {
                case 'debug':
                    return Severity.Debug;
                case 'info':
                    return Severity.Info;
                case 'warn':
                case 'warning':
                    return Severity.Warning;
                case 'error':
                    return Severity.Error;
                case 'fatal':
                    return Severity.Fatal;
                case 'critical':
                    return Severity.Critical;
                case 'log':
                default:
                    return Severity.Log;
            }
        }
        Severity.fromString = fromString;
    })(Severity || (Severity = {}));

    /** The status of an event. */
    // eslint-disable-next-line import/export
    var Status;
    (function (Status) {
        /** The status could not be determined. */
        Status["Unknown"] = "unknown";
        /** The event was skipped due to configuration or callbacks. */
        Status["Skipped"] = "skipped";
        /** The event was sent to Sentry successfully. */
        Status["Success"] = "success";
        /** The client is currently rate limited and will try again later. */
        Status["RateLimit"] = "rate_limit";
        /** The event could not be processed. */
        Status["Invalid"] = "invalid";
        /** A server-side error ocurred during submission. */
        Status["Failed"] = "failed";
    })(Status || (Status = {}));
    // eslint-disable-next-line @typescript-eslint/no-namespace, import/export
    (function (Status) {
        /**
         * Converts a HTTP status code into a {@link Status}.
         *
         * @param code The HTTP response status code.
         * @returns The send status or {@link Status.Unknown}.
         */
        function fromHttpCode(code) {
            if (code >= 200 && code < 300) {
                return Status.Success;
            }
            if (code === 429) {
                return Status.RateLimit;
            }
            if (code >= 400 && code < 500) {
                return Status.Invalid;
            }
            if (code >= 500) {
                return Status.Failed;
            }
            return Status.Unknown;
        }
        Status.fromHttpCode = fromHttpCode;
    })(Status || (Status = {}));

    var TransactionSamplingMethod;
    (function (TransactionSamplingMethod) {
        TransactionSamplingMethod["Explicit"] = "explicitly_set";
        TransactionSamplingMethod["Sampler"] = "client_sampler";
        TransactionSamplingMethod["Rate"] = "client_rate";
        TransactionSamplingMethod["Inheritance"] = "inheritance";
    })(TransactionSamplingMethod || (TransactionSamplingMethod = {}));

    /* eslint-disable @typescript-eslint/no-explicit-any */
    /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
    /**
     * Checks whether given value's type is one of a few Error or Error-like
     * {@link isError}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isError(wat) {
        switch (Object.prototype.toString.call(wat)) {
            case '[object Error]':
                return true;
            case '[object Exception]':
                return true;
            case '[object DOMException]':
                return true;
            default:
                return isInstanceOf(wat, Error);
        }
    }
    /**
     * Checks whether given value's type is ErrorEvent
     * {@link isErrorEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isErrorEvent(wat) {
        return Object.prototype.toString.call(wat) === '[object ErrorEvent]';
    }
    /**
     * Checks whether given value's type is DOMError
     * {@link isDOMError}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isDOMError(wat) {
        return Object.prototype.toString.call(wat) === '[object DOMError]';
    }
    /**
     * Checks whether given value's type is DOMException
     * {@link isDOMException}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isDOMException(wat) {
        return Object.prototype.toString.call(wat) === '[object DOMException]';
    }
    /**
     * Checks whether given value's type is a string
     * {@link isString}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isString(wat) {
        return Object.prototype.toString.call(wat) === '[object String]';
    }
    /**
     * Checks whether given value's is a primitive (undefined, null, number, boolean, string, bigint, symbol)
     * {@link isPrimitive}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isPrimitive(wat) {
        return wat === null || (typeof wat !== 'object' && typeof wat !== 'function');
    }
    /**
     * Checks whether given value's type is an object literal
     * {@link isPlainObject}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isPlainObject(wat) {
        return Object.prototype.toString.call(wat) === '[object Object]';
    }
    /**
     * Checks whether given value's type is an Event instance
     * {@link isEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isEvent(wat) {
        return typeof Event !== 'undefined' && isInstanceOf(wat, Event);
    }
    /**
     * Checks whether given value's type is an Element instance
     * {@link isElement}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isElement(wat) {
        return typeof Element !== 'undefined' && isInstanceOf(wat, Element);
    }
    /**
     * Checks whether given value's type is an regexp
     * {@link isRegExp}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isRegExp(wat) {
        return Object.prototype.toString.call(wat) === '[object RegExp]';
    }
    /**
     * Checks whether given value has a then function.
     * @param wat A value to be checked.
     */
    function isThenable(wat) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return Boolean(wat && wat.then && typeof wat.then === 'function');
    }
    /**
     * Checks whether given value's type is a SyntheticEvent
     * {@link isSyntheticEvent}.
     *
     * @param wat A value to be checked.
     * @returns A boolean representing the result.
     */
    function isSyntheticEvent(wat) {
        return isPlainObject(wat) && 'nativeEvent' in wat && 'preventDefault' in wat && 'stopPropagation' in wat;
    }
    /**
     * Checks whether given value's type is an instance of provided constructor.
     * {@link isInstanceOf}.
     *
     * @param wat A value to be checked.
     * @param base A constructor to be used in a check.
     * @returns A boolean representing the result.
     */
    function isInstanceOf(wat, base) {
        try {
            return wat instanceof base;
        }
        catch (_e) {
            return false;
        }
    }

    /**
     * Given a child DOM element, returns a query-selector statement describing that
     * and its ancestors
     * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
     * @returns generated DOM path
     */
    function htmlTreeAsString(elem) {
        // try/catch both:
        // - accessing event.target (see getsentry/raven-js#838, #768)
        // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
        // - can throw an exception in some circumstances.
        try {
            var currentElem = elem;
            var MAX_TRAVERSE_HEIGHT = 5;
            var MAX_OUTPUT_LEN = 80;
            var out = [];
            var height = 0;
            var len = 0;
            var separator = ' > ';
            var sepLength = separator.length;
            var nextStr = void 0;
            // eslint-disable-next-line no-plusplus
            while (currentElem && height++ < MAX_TRAVERSE_HEIGHT) {
                nextStr = _htmlElementAsString(currentElem);
                // bail out if
                // - nextStr is the 'html' element
                // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
                //   (ignore this limit if we are on the first iteration)
                if (nextStr === 'html' || (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)) {
                    break;
                }
                out.push(nextStr);
                len += nextStr.length;
                currentElem = currentElem.parentNode;
            }
            return out.reverse().join(separator);
        }
        catch (_oO) {
            return '<unknown>';
        }
    }
    /**
     * Returns a simple, query-selector representation of a DOM element
     * e.g. [HTMLElement] => input#foo.btn[name=baz]
     * @returns generated DOM path
     */
    function _htmlElementAsString(el) {
        var elem = el;
        var out = [];
        var className;
        var classes;
        var key;
        var attr;
        var i;
        if (!elem || !elem.tagName) {
            return '';
        }
        out.push(elem.tagName.toLowerCase());
        if (elem.id) {
            out.push("#" + elem.id);
        }
        // eslint-disable-next-line prefer-const
        className = elem.className;
        if (className && isString(className)) {
            classes = className.split(/\s+/);
            for (i = 0; i < classes.length; i++) {
                out.push("." + classes[i]);
            }
        }
        var allowedAttrs = ['type', 'name', 'title', 'alt'];
        for (i = 0; i < allowedAttrs.length; i++) {
            key = allowedAttrs[i];
            attr = elem.getAttribute(key);
            if (attr) {
                out.push("[" + key + "=\"" + attr + "\"]");
            }
        }
        return out.join('');
    }

    var setPrototypeOf = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
    /**
     * setPrototypeOf polyfill using __proto__
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function setProtoOf(obj, proto) {
        // @ts-ignore __proto__ does not exist on obj
        obj.__proto__ = proto;
        return obj;
    }
    /**
     * setPrototypeOf polyfill using mixin
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function mixinProperties(obj, proto) {
        for (var prop in proto) {
            // eslint-disable-next-line no-prototype-builtins
            if (!obj.hasOwnProperty(prop)) {
                // @ts-ignore typescript complains about indexing so we remove
                obj[prop] = proto[prop];
            }
        }
        return obj;
    }

    /** An error emitted by Sentry SDKs and related utilities. */
    var SentryError = /** @class */ (function (_super) {
        __extends(SentryError, _super);
        function SentryError(message) {
            var _newTarget = this.constructor;
            var _this = _super.call(this, message) || this;
            _this.message = message;
            _this.name = _newTarget.prototype.constructor.name;
            setPrototypeOf(_this, _newTarget.prototype);
            return _this;
        }
        return SentryError;
    }(Error));

    /** Regular expression used to parse a Dsn. */
    var DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+))?@)([\w.-]+)(?::(\d+))?\/(.+)/;
    /** Error message */
    var ERROR_MESSAGE = 'Invalid Dsn';
    /** The Sentry Dsn, identifying a Sentry instance and project. */
    var Dsn = /** @class */ (function () {
        /** Creates a new Dsn component */
        function Dsn(from) {
            if (typeof from === 'string') {
                this._fromString(from);
            }
            else {
                this._fromComponents(from);
            }
            this._validate();
        }
        /**
         * Renders the string representation of this Dsn.
         *
         * By default, this will render the public representation without the password
         * component. To get the deprecated private representation, set `withPassword`
         * to true.
         *
         * @param withPassword When set to true, the password will be included.
         */
        Dsn.prototype.toString = function (withPassword) {
            if (withPassword === void 0) { withPassword = false; }
            var _a = this, host = _a.host, path = _a.path, pass = _a.pass, port = _a.port, projectId = _a.projectId, protocol = _a.protocol, publicKey = _a.publicKey;
            return (protocol + "://" + publicKey + (withPassword && pass ? ":" + pass : '') +
                ("@" + host + (port ? ":" + port : '') + "/" + (path ? path + "/" : path) + projectId));
        };
        /** Parses a string into this Dsn. */
        Dsn.prototype._fromString = function (str) {
            var match = DSN_REGEX.exec(str);
            if (!match) {
                throw new SentryError(ERROR_MESSAGE);
            }
            var _a = __read(match.slice(1), 6), protocol = _a[0], publicKey = _a[1], _b = _a[2], pass = _b === void 0 ? '' : _b, host = _a[3], _c = _a[4], port = _c === void 0 ? '' : _c, lastPath = _a[5];
            var path = '';
            var projectId = lastPath;
            var split = projectId.split('/');
            if (split.length > 1) {
                path = split.slice(0, -1).join('/');
                projectId = split.pop();
            }
            if (projectId) {
                var projectMatch = projectId.match(/^\d+/);
                if (projectMatch) {
                    projectId = projectMatch[0];
                }
            }
            this._fromComponents({ host: host, pass: pass, path: path, projectId: projectId, port: port, protocol: protocol, publicKey: publicKey });
        };
        /** Maps Dsn components into this instance. */
        Dsn.prototype._fromComponents = function (components) {
            // TODO this is for backwards compatibility, and can be removed in a future version
            if ('user' in components && !('publicKey' in components)) {
                components.publicKey = components.user;
            }
            this.user = components.publicKey || '';
            this.protocol = components.protocol;
            this.publicKey = components.publicKey || '';
            this.pass = components.pass || '';
            this.host = components.host;
            this.port = components.port || '';
            this.path = components.path || '';
            this.projectId = components.projectId;
        };
        /** Validates this Dsn and throws on error. */
        Dsn.prototype._validate = function () {
            var _this = this;
            ['protocol', 'publicKey', 'host', 'projectId'].forEach(function (component) {
                if (!_this[component]) {
                    throw new SentryError(ERROR_MESSAGE + ": " + component + " missing");
                }
            });
            if (!this.projectId.match(/^\d+$/)) {
                throw new SentryError(ERROR_MESSAGE + ": Invalid projectId " + this.projectId);
            }
            if (this.protocol !== 'http' && this.protocol !== 'https') {
                throw new SentryError(ERROR_MESSAGE + ": Invalid protocol " + this.protocol);
            }
            if (this.port && isNaN(parseInt(this.port, 10))) {
                throw new SentryError(ERROR_MESSAGE + ": Invalid port " + this.port);
            }
        };
        return Dsn;
    }());

    /**
     * Checks whether we're in the Node.js or Browser environment
     *
     * @returns Answer to given question
     */
    function isNodeEnv() {
        return Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]';
    }
    /**
     * Requires a module which is protected against bundler minification.
     *
     * @param request The module path to resolve
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
    function dynamicRequire(mod, request) {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        return mod.require(request);
    }

    /**
     * Truncates given string to the maximum characters count
     *
     * @param str An object that contains serializable values
     * @param max Maximum number of characters in truncated string (0 = unlimited)
     * @returns string Encoded
     */
    function truncate(str, max) {
        if (max === void 0) { max = 0; }
        if (typeof str !== 'string' || max === 0) {
            return str;
        }
        return str.length <= max ? str : str.substr(0, max) + "...";
    }
    /**
     * Join values in array
     * @param input array of values to be joined together
     * @param delimiter string to be placed in-between values
     * @returns Joined values
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function safeJoin(input, delimiter) {
        if (!Array.isArray(input)) {
            return '';
        }
        var output = [];
        // eslint-disable-next-line @typescript-eslint/prefer-for-of
        for (var i = 0; i < input.length; i++) {
            var value = input[i];
            try {
                output.push(String(value));
            }
            catch (e) {
                output.push('[value cannot be serialized]');
            }
        }
        return output.join(delimiter);
    }
    /**
     * Checks if the value matches a regex or includes the string
     * @param value The string value to be checked against
     * @param pattern Either a regex or a string that must be contained in value
     */
    function isMatchingPattern(value, pattern) {
        if (!isString(value)) {
            return false;
        }
        if (isRegExp(pattern)) {
            return pattern.test(value);
        }
        if (typeof pattern === 'string') {
            return value.indexOf(pattern) !== -1;
        }
        return false;
    }

    var fallbackGlobalObject = {};
    /**
     * Safely get global scope object
     *
     * @returns Global scope object
     */
    function getGlobalObject() {
        return (isNodeEnv()
            ? global
            : typeof window !== 'undefined'
                ? window
                : typeof self !== 'undefined'
                    ? self
                    : fallbackGlobalObject);
    }
    /**
     * UUID4 generator
     *
     * @returns string Generated UUID4.
     */
    function uuid4() {
        var global = getGlobalObject();
        var crypto = global.crypto || global.msCrypto;
        if (!(crypto === void 0) && crypto.getRandomValues) {
            // Use window.crypto API if available
            var arr = new Uint16Array(8);
            crypto.getRandomValues(arr);
            // set 4 in byte 7
            // eslint-disable-next-line no-bitwise
            arr[3] = (arr[3] & 0xfff) | 0x4000;
            // set 2 most significant bits of byte 9 to '10'
            // eslint-disable-next-line no-bitwise
            arr[4] = (arr[4] & 0x3fff) | 0x8000;
            var pad = function (num) {
                var v = num.toString(16);
                while (v.length < 4) {
                    v = "0" + v;
                }
                return v;
            };
            return (pad(arr[0]) + pad(arr[1]) + pad(arr[2]) + pad(arr[3]) + pad(arr[4]) + pad(arr[5]) + pad(arr[6]) + pad(arr[7]));
        }
        // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
        return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            // eslint-disable-next-line no-bitwise
            var r = (Math.random() * 16) | 0;
            // eslint-disable-next-line no-bitwise
            var v = c === 'x' ? r : (r & 0x3) | 0x8;
            return v.toString(16);
        });
    }
    /**
     * Parses string form of URL into an object
     * // borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
     * // intentionally using regex and not <a/> href parsing trick because React Native and other
     * // environments where DOM might not be available
     * @returns parsed URL object
     */
    function parseUrl(url) {
        if (!url) {
            return {};
        }
        var match = url.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
        if (!match) {
            return {};
        }
        // coerce to undefined values to empty string so we don't get 'undefined'
        var query = match[6] || '';
        var fragment = match[8] || '';
        return {
            host: match[4],
            path: match[5],
            protocol: match[2],
            relative: match[5] + query + fragment,
        };
    }
    /**
     * Extracts either message or type+value from an event that can be used for user-facing logs
     * @returns event's description
     */
    function getEventDescription(event) {
        if (event.message) {
            return event.message;
        }
        if (event.exception && event.exception.values && event.exception.values[0]) {
            var exception = event.exception.values[0];
            if (exception.type && exception.value) {
                return exception.type + ": " + exception.value;
            }
            return exception.type || exception.value || event.event_id || '<unknown>';
        }
        return event.event_id || '<unknown>';
    }
    /** JSDoc */
    function consoleSandbox(callback) {
        var global = getGlobalObject();
        var levels = ['debug', 'info', 'warn', 'error', 'log', 'assert'];
        if (!('console' in global)) {
            return callback();
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        var originalConsole = global.console;
        var wrappedLevels = {};
        // Restore all wrapped console methods
        levels.forEach(function (level) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (level in global.console && originalConsole[level].__sentry_original__) {
                wrappedLevels[level] = originalConsole[level];
                originalConsole[level] = originalConsole[level].__sentry_original__;
            }
        });
        // Perform callback manipulations
        var result = callback();
        // Revert restoration to wrapped state
        Object.keys(wrappedLevels).forEach(function (level) {
            originalConsole[level] = wrappedLevels[level];
        });
        return result;
    }
    /**
     * Adds exception values, type and value to an synthetic Exception.
     * @param event The event to modify.
     * @param value Value of the exception.
     * @param type Type of the exception.
     * @hidden
     */
    function addExceptionTypeValue(event, value, type) {
        event.exception = event.exception || {};
        event.exception.values = event.exception.values || [];
        event.exception.values[0] = event.exception.values[0] || {};
        event.exception.values[0].value = event.exception.values[0].value || value || '';
        event.exception.values[0].type = event.exception.values[0].type || type || 'Error';
    }
    /**
     * Adds exception mechanism to a given event.
     * @param event The event to modify.
     * @param mechanism Mechanism of the mechanism.
     * @hidden
     */
    function addExceptionMechanism(event, mechanism) {
        if (mechanism === void 0) { mechanism = {}; }
        // TODO: Use real type with `keyof Mechanism` thingy and maybe make it better?
        try {
            // @ts-ignore Type 'Mechanism | {}' is not assignable to type 'Mechanism | undefined'
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            event.exception.values[0].mechanism = event.exception.values[0].mechanism || {};
            Object.keys(mechanism).forEach(function (key) {
                // @ts-ignore Mechanism has no index signature
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                event.exception.values[0].mechanism[key] = mechanism[key];
            });
        }
        catch (_oO) {
            // no-empty
        }
    }
    /**
     * A safe form of location.href
     */
    function getLocationHref() {
        try {
            return document.location.href;
        }
        catch (oO) {
            return '';
        }
    }
    var defaultRetryAfter = 60 * 1000; // 60 seconds
    /**
     * Extracts Retry-After value from the request header or returns default value
     * @param now current unix timestamp
     * @param header string representation of 'Retry-After' header
     */
    function parseRetryAfterHeader(now, header) {
        if (!header) {
            return defaultRetryAfter;
        }
        var headerDelay = parseInt("" + header, 10);
        if (!isNaN(headerDelay)) {
            return headerDelay * 1000;
        }
        var headerDate = Date.parse("" + header);
        if (!isNaN(headerDate)) {
            return headerDate - now;
        }
        return defaultRetryAfter;
    }

    /* eslint-disable @typescript-eslint/no-explicit-any */
    // TODO: Implement different loggers for different environments
    var global$1 = getGlobalObject();
    /** Prefix for logging strings */
    var PREFIX = 'Sentry Logger ';
    /** JSDoc */
    var Logger = /** @class */ (function () {
        /** JSDoc */
        function Logger() {
            this._enabled = false;
        }
        /** JSDoc */
        Logger.prototype.disable = function () {
            this._enabled = false;
        };
        /** JSDoc */
        Logger.prototype.enable = function () {
            this._enabled = true;
        };
        /** JSDoc */
        Logger.prototype.log = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this._enabled) {
                return;
            }
            consoleSandbox(function () {
                global$1.console.log(PREFIX + "[Log]: " + args.join(' '));
            });
        };
        /** JSDoc */
        Logger.prototype.warn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this._enabled) {
                return;
            }
            consoleSandbox(function () {
                global$1.console.warn(PREFIX + "[Warn]: " + args.join(' '));
            });
        };
        /** JSDoc */
        Logger.prototype.error = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            if (!this._enabled) {
                return;
            }
            consoleSandbox(function () {
                global$1.console.error(PREFIX + "[Error]: " + args.join(' '));
            });
        };
        return Logger;
    }());
    // Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
    global$1.__SENTRY__ = global$1.__SENTRY__ || {};
    var logger = global$1.__SENTRY__.logger || (global$1.__SENTRY__.logger = new Logger());

    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /* eslint-disable @typescript-eslint/no-explicit-any */
    /* eslint-disable @typescript-eslint/explicit-module-boundary-types */
    /**
     * Memo class used for decycle json objects. Uses WeakSet if available otherwise array.
     */
    var Memo = /** @class */ (function () {
        function Memo() {
            this._hasWeakSet = typeof WeakSet === 'function';
            this._inner = this._hasWeakSet ? new WeakSet() : [];
        }
        /**
         * Sets obj to remember.
         * @param obj Object to remember
         */
        Memo.prototype.memoize = function (obj) {
            if (this._hasWeakSet) {
                if (this._inner.has(obj)) {
                    return true;
                }
                this._inner.add(obj);
                return false;
            }
            // eslint-disable-next-line @typescript-eslint/prefer-for-of
            for (var i = 0; i < this._inner.length; i++) {
                var value = this._inner[i];
                if (value === obj) {
                    return true;
                }
            }
            this._inner.push(obj);
            return false;
        };
        /**
         * Removes object from internal storage.
         * @param obj Object to forget
         */
        Memo.prototype.unmemoize = function (obj) {
            if (this._hasWeakSet) {
                this._inner.delete(obj);
            }
            else {
                for (var i = 0; i < this._inner.length; i++) {
                    if (this._inner[i] === obj) {
                        this._inner.splice(i, 1);
                        break;
                    }
                }
            }
        };
        return Memo;
    }());

    var defaultFunctionName = '<anonymous>';
    /**
     * Safely extract function name from itself
     */
    function getFunctionName(fn) {
        try {
            if (!fn || typeof fn !== 'function') {
                return defaultFunctionName;
            }
            return fn.name || defaultFunctionName;
        }
        catch (e) {
            // Just accessing custom props in some Selenium environments
            // can cause a "Permission denied" exception (see raven-js#495).
            return defaultFunctionName;
        }
    }

    /**
     * Wrap a given object method with a higher-order function
     *
     * @param source An object that contains a method to be wrapped.
     * @param name A name of method to be wrapped.
     * @param replacementFactory A function that should be used to wrap a given method, returning the wrapped method which
     * will be substituted in for `source[name]`.
     * @returns void
     */
    function fill(source, name, replacementFactory) {
        if (!(name in source)) {
            return;
        }
        var original = source[name];
        var wrapped = replacementFactory(original);
        // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work
        // otherwise it'll throw "TypeError: Object.defineProperties called on non-object"
        if (typeof wrapped === 'function') {
            try {
                wrapped.prototype = wrapped.prototype || {};
                Object.defineProperties(wrapped, {
                    __sentry_original__: {
                        enumerable: false,
                        value: original,
                    },
                });
            }
            catch (_Oo) {
                // This can throw if multiple fill happens on a global object like XMLHttpRequest
                // Fixes https://github.com/getsentry/sentry-javascript/issues/2043
            }
        }
        source[name] = wrapped;
    }
    /**
     * Encodes given object into url-friendly format
     *
     * @param object An object that contains serializable values
     * @returns string Encoded
     */
    function urlEncode(object) {
        return Object.keys(object)
            .map(function (key) { return encodeURIComponent(key) + "=" + encodeURIComponent(object[key]); })
            .join('&');
    }
    /**
     * Transforms any object into an object literal with all its attributes
     * attached to it.
     *
     * @param value Initial source that we have to transform in order for it to be usable by the serializer
     */
    function getWalkSource(value) {
        if (isError(value)) {
            var error = value;
            var err = {
                message: error.message,
                name: error.name,
                stack: error.stack,
            };
            for (var i in error) {
                if (Object.prototype.hasOwnProperty.call(error, i)) {
                    err[i] = error[i];
                }
            }
            return err;
        }
        if (isEvent(value)) {
            var event_1 = value;
            var source = {};
            source.type = event_1.type;
            // Accessing event.target can throw (see getsentry/raven-js#838, #768)
            try {
                source.target = isElement(event_1.target)
                    ? htmlTreeAsString(event_1.target)
                    : Object.prototype.toString.call(event_1.target);
            }
            catch (_oO) {
                source.target = '<unknown>';
            }
            try {
                source.currentTarget = isElement(event_1.currentTarget)
                    ? htmlTreeAsString(event_1.currentTarget)
                    : Object.prototype.toString.call(event_1.currentTarget);
            }
            catch (_oO) {
                source.currentTarget = '<unknown>';
            }
            if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {
                source.detail = event_1.detail;
            }
            for (var i in event_1) {
                if (Object.prototype.hasOwnProperty.call(event_1, i)) {
                    source[i] = event_1;
                }
            }
            return source;
        }
        return value;
    }
    /** Calculates bytes size of input string */
    function utf8Length(value) {
        // eslint-disable-next-line no-bitwise
        return ~-encodeURI(value).split(/%..|./).length;
    }
    /** Calculates bytes size of input object */
    function jsonSize(value) {
        return utf8Length(JSON.stringify(value));
    }
    /** JSDoc */
    function normalizeToSize(object, 
    // Default Node.js REPL depth
    depth, 
    // 100kB, as 200kB is max payload size, so half sounds reasonable
    maxSize) {
        if (depth === void 0) { depth = 3; }
        if (maxSize === void 0) { maxSize = 100 * 1024; }
        var serialized = normalize(object, depth);
        if (jsonSize(serialized) > maxSize) {
            return normalizeToSize(object, depth - 1, maxSize);
        }
        return serialized;
    }
    /**
     * Transform any non-primitive, BigInt, or Symbol-type value into a string. Acts as a no-op on strings, numbers,
     * booleans, null, and undefined.
     *
     * @param value The value to stringify
     * @returns For non-primitive, BigInt, and Symbol-type values, a string denoting the value's type, type and value, or
     *  type and `description` property, respectively. For non-BigInt, non-Symbol primitives, returns the original value,
     *  unchanged.
     */
    function serializeValue(value) {
        var type = Object.prototype.toString.call(value);
        // Node.js REPL notation
        if (typeof value === 'string') {
            return value;
        }
        if (type === '[object Object]') {
            return '[Object]';
        }
        if (type === '[object Array]') {
            return '[Array]';
        }
        var normalized = normalizeValue(value);
        return isPrimitive(normalized) ? normalized : type;
    }
    /**
     * normalizeValue()
     *
     * Takes unserializable input and make it serializable friendly
     *
     * - translates undefined/NaN values to "[undefined]"/"[NaN]" respectively,
     * - serializes Error objects
     * - filter global objects
     */
    function normalizeValue(value, key) {
        if (key === 'domain' && value && typeof value === 'object' && value._events) {
            return '[Domain]';
        }
        if (key === 'domainEmitter') {
            return '[DomainEmitter]';
        }
        if (typeof global !== 'undefined' && value === global) {
            return '[Global]';
        }
        if (typeof window !== 'undefined' && value === window) {
            return '[Window]';
        }
        if (typeof document !== 'undefined' && value === document) {
            return '[Document]';
        }
        // React's SyntheticEvent thingy
        if (isSyntheticEvent(value)) {
            return '[SyntheticEvent]';
        }
        if (typeof value === 'number' && value !== value) {
            return '[NaN]';
        }
        if (value === void 0) {
            return '[undefined]';
        }
        if (typeof value === 'function') {
            return "[Function: " + getFunctionName(value) + "]";
        }
        // symbols and bigints are considered primitives by TS, but aren't natively JSON-serilaizable
        if (typeof value === 'symbol') {
            return "[" + String(value) + "]";
        }
        if (typeof value === 'bigint') {
            return "[BigInt: " + String(value) + "]";
        }
        return value;
    }
    /**
     * Walks an object to perform a normalization on it
     *
     * @param key of object that's walked in current iteration
     * @param value object to be walked
     * @param depth Optional number indicating how deep should walking be performed
     * @param memo Optional Memo class handling decycling
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function walk(key, value, depth, memo) {
        if (depth === void 0) { depth = +Infinity; }
        if (memo === void 0) { memo = new Memo(); }
        // If we reach the maximum depth, serialize whatever has left
        if (depth === 0) {
            return serializeValue(value);
        }
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        // If value implements `toJSON` method, call it and return early
        if (value !== null && value !== undefined && typeof value.toJSON === 'function') {
            return value.toJSON();
        }
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further
        var normalized = normalizeValue(value, key);
        if (isPrimitive(normalized)) {
            return normalized;
        }
        // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself
        var source = getWalkSource(value);
        // Create an accumulator that will act as a parent for all future itterations of that branch
        var acc = Array.isArray(value) ? [] : {};
        // If we already walked that branch, bail out, as it's circular reference
        if (memo.memoize(value)) {
            return '[Circular ~]';
        }
        // Walk all keys of the source
        for (var innerKey in source) {
            // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.
            if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {
                continue;
            }
            // Recursively walk through all the child nodes
            acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);
        }
        // Once walked through all the branches, remove the parent from memo storage
        memo.unmemoize(value);
        // Return accumulated values
        return acc;
    }
    /**
     * normalize()
     *
     * - Creates a copy to prevent original input mutation
     * - Skip non-enumerablers
     * - Calls `toJSON` if implemented
     * - Removes circular references
     * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format
     * - Translates known global objects/Classes to a string representations
     * - Takes care of Error objects serialization
     * - Optionally limit depth of final output
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function normalize(input, depth) {
        try {
            return JSON.parse(JSON.stringify(input, function (key, value) { return walk(key, value, depth); }));
        }
        catch (_oO) {
            return '**non-serializable**';
        }
    }
    /**
     * Given any captured exception, extract its keys and create a sorted
     * and truncated list that will be used inside the event message.
     * eg. `Non-error exception captured with keys: foo, bar, baz`
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function extractExceptionKeysForMessage(exception, maxLength) {
        if (maxLength === void 0) { maxLength = 40; }
        var keys = Object.keys(getWalkSource(exception));
        keys.sort();
        if (!keys.length) {
            return '[object has no keys]';
        }
        if (keys[0].length >= maxLength) {
            return truncate(keys[0], maxLength);
        }
        for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {
            var serialized = keys.slice(0, includedKeys).join(', ');
            if (serialized.length > maxLength) {
                continue;
            }
            if (includedKeys === keys.length) {
                return serialized;
            }
            return truncate(serialized, maxLength);
        }
        return '';
    }
    /**
     * Given any object, return the new object with removed keys that value was `undefined`.
     * Works recursively on objects and arrays.
     */
    function dropUndefinedKeys(val) {
        var e_1, _a;
        if (isPlainObject(val)) {
            var obj = val;
            var rv = {};
            try {
                for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (typeof obj[key] !== 'undefined') {
                        rv[key] = dropUndefinedKeys(obj[key]);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return rv;
        }
        if (Array.isArray(val)) {
            return val.map(dropUndefinedKeys);
        }
        return val;
    }

    /**
     * Tells whether current environment supports Fetch API
     * {@link supportsFetch}.
     *
     * @returns Answer to the given question.
     */
    function supportsFetch() {
        if (!('fetch' in getGlobalObject())) {
            return false;
        }
        try {
            new Headers();
            new Request('');
            new Response();
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * isNativeFetch checks if the given function is a native implementation of fetch()
     */
    // eslint-disable-next-line @typescript-eslint/ban-types
    function isNativeFetch(func) {
        return func && /^function fetch\(\)\s+\{\s+\[native code\]\s+\}$/.test(func.toString());
    }
    /**
     * Tells whether current environment supports Fetch API natively
     * {@link supportsNativeFetch}.
     *
     * @returns true if `window.fetch` is natively implemented, false otherwise
     */
    function supportsNativeFetch() {
        if (!supportsFetch()) {
            return false;
        }
        var global = getGlobalObject();
        // Fast path to avoid DOM I/O
        // eslint-disable-next-line @typescript-eslint/unbound-method
        if (isNativeFetch(global.fetch)) {
            return true;
        }
        // window.fetch is implemented, but is polyfilled or already wrapped (e.g: by a chrome extension)
        // so create a "pure" iframe to see if that has native fetch
        var result = false;
        var doc = global.document;
        // eslint-disable-next-line deprecation/deprecation
        if (doc && typeof doc.createElement === "function") {
            try {
                var sandbox = doc.createElement('iframe');
                sandbox.hidden = true;
                doc.head.appendChild(sandbox);
                if (sandbox.contentWindow && sandbox.contentWindow.fetch) {
                    // eslint-disable-next-line @typescript-eslint/unbound-method
                    result = isNativeFetch(sandbox.contentWindow.fetch);
                }
                doc.head.removeChild(sandbox);
            }
            catch (err) {
                logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', err);
            }
        }
        return result;
    }
    /**
     * Tells whether current environment supports Referrer Policy API
     * {@link supportsReferrerPolicy}.
     *
     * @returns Answer to the given question.
     */
    function supportsReferrerPolicy() {
        // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
        // https://caniuse.com/#feat=referrer-policy
        // It doesn't. And it throw exception instead of ignoring this parameter...
        // REF: https://github.com/getsentry/raven-js/issues/1233
        if (!supportsFetch()) {
            return false;
        }
        try {
            new Request('_', {
                referrerPolicy: 'origin',
            });
            return true;
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Tells whether current environment supports History API
     * {@link supportsHistory}.
     *
     * @returns Answer to the given question.
     */
    function supportsHistory() {
        // NOTE: in Chrome App environment, touching history.pushState, *even inside
        //       a try/catch block*, will cause Chrome to output an error to console.error
        // borrowed from: https://github.com/angular/angular.js/pull/13945/files
        var global = getGlobalObject();
        /* eslint-disable @typescript-eslint/no-unsafe-member-access */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var chrome = global.chrome;
        var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
        /* eslint-enable @typescript-eslint/no-unsafe-member-access */
        var hasHistoryApi = 'history' in global && !!global.history.pushState && !!global.history.replaceState;
        return !isChromePackagedApp && hasHistoryApi;
    }

    var global$2 = getGlobalObject();
    /**
     * Instrument native APIs to call handlers that can be used to create breadcrumbs, APM spans etc.
     *  - Console API
     *  - Fetch API
     *  - XHR API
     *  - History API
     *  - DOM API (click/typing)
     *  - Error API
     *  - UnhandledRejection API
     */
    var handlers = {};
    var instrumented = {};
    /** Instruments given API */
    function instrument(type) {
        if (instrumented[type]) {
            return;
        }
        instrumented[type] = true;
        switch (type) {
            case 'console':
                instrumentConsole();
                break;
            case 'dom':
                instrumentDOM();
                break;
            case 'xhr':
                instrumentXHR();
                break;
            case 'fetch':
                instrumentFetch();
                break;
            case 'history':
                instrumentHistory();
                break;
            case 'error':
                instrumentError();
                break;
            case 'unhandledrejection':
                instrumentUnhandledRejection();
                break;
            default:
                logger.warn('unknown instrumentation type:', type);
        }
    }
    /**
     * Add handler that will be called when given type of instrumentation triggers.
     * Use at your own risk, this might break without changelog notice, only used internally.
     * @hidden
     */
    function addInstrumentationHandler(handler) {
        if (!handler || typeof handler.type !== 'string' || typeof handler.callback !== 'function') {
            return;
        }
        handlers[handler.type] = handlers[handler.type] || [];
        handlers[handler.type].push(handler.callback);
        instrument(handler.type);
    }
    /** JSDoc */
    function triggerHandlers(type, data) {
        var e_1, _a;
        if (!type || !handlers[type]) {
            return;
        }
        try {
            for (var _b = __values(handlers[type] || []), _c = _b.next(); !_c.done; _c = _b.next()) {
                var handler = _c.value;
                try {
                    handler(data);
                }
                catch (e) {
                    logger.error("Error while triggering instrumentation handler.\nType: " + type + "\nName: " + getFunctionName(handler) + "\nError: " + e);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    /** JSDoc */
    function instrumentConsole() {
        if (!('console' in global$2)) {
            return;
        }
        ['debug', 'info', 'warn', 'error', 'log', 'assert'].forEach(function (level) {
            if (!(level in global$2.console)) {
                return;
            }
            fill(global$2.console, level, function (originalConsoleLevel) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    triggerHandlers('console', { args: args, level: level });
                    // this fails for some browsers. :(
                    if (originalConsoleLevel) {
                        Function.prototype.apply.call(originalConsoleLevel, global$2.console, args);
                    }
                };
            });
        });
    }
    /** JSDoc */
    function instrumentFetch() {
        if (!supportsNativeFetch()) {
            return;
        }
        fill(global$2, 'fetch', function (originalFetch) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var handlerData = {
                    args: args,
                    fetchData: {
                        method: getFetchMethod(args),
                        url: getFetchUrl(args),
                    },
                    startTimestamp: Date.now(),
                };
                triggerHandlers('fetch', __assign({}, handlerData));
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return originalFetch.apply(global$2, args).then(function (response) {
                    triggerHandlers('fetch', __assign(__assign({}, handlerData), { endTimestamp: Date.now(), response: response }));
                    return response;
                }, function (error) {
                    triggerHandlers('fetch', __assign(__assign({}, handlerData), { endTimestamp: Date.now(), error: error }));
                    // NOTE: If you are a Sentry user, and you are seeing this stack frame,
                    //       it means the sentry.javascript SDK caught an error invoking your application code.
                    //       This is expected behavior and NOT indicative of a bug with sentry.javascript.
                    throw error;
                });
            };
        });
    }
    /* eslint-disable @typescript-eslint/no-unsafe-member-access */
    /** Extract `method` from fetch call arguments */
    function getFetchMethod(fetchArgs) {
        if (fetchArgs === void 0) { fetchArgs = []; }
        if ('Request' in global$2 && isInstanceOf(fetchArgs[0], Request) && fetchArgs[0].method) {
            return String(fetchArgs[0].method).toUpperCase();
        }
        if (fetchArgs[1] && fetchArgs[1].method) {
            return String(fetchArgs[1].method).toUpperCase();
        }
        return 'GET';
    }
    /** Extract `url` from fetch call arguments */
    function getFetchUrl(fetchArgs) {
        if (fetchArgs === void 0) { fetchArgs = []; }
        if (typeof fetchArgs[0] === 'string') {
            return fetchArgs[0];
        }
        if ('Request' in global$2 && isInstanceOf(fetchArgs[0], Request)) {
            return fetchArgs[0].url;
        }
        return String(fetchArgs[0]);
    }
    /* eslint-enable @typescript-eslint/no-unsafe-member-access */
    /** JSDoc */
    function instrumentXHR() {
        if (!('XMLHttpRequest' in global$2)) {
            return;
        }
        // Poor man's implementation of ES6 `Map`, tracking and keeping in sync key and value separately.
        var requestKeys = [];
        var requestValues = [];
        var xhrproto = XMLHttpRequest.prototype;
        fill(xhrproto, 'open', function (originalOpen) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var xhr = this;
                var url = args[1];
                xhr.__sentry_xhr__ = {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    method: isString(args[0]) ? args[0].toUpperCase() : args[0],
                    url: args[1],
                };
                // if Sentry key appears in URL, don't capture it as a request
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if (isString(url) && xhr.__sentry_xhr__.method === 'POST' && url.match(/sentry_key/)) {
                    xhr.__sentry_own_request__ = true;
                }
                var onreadystatechangeHandler = function () {
                    if (xhr.readyState === 4) {
                        try {
                            // touching statusCode in some platforms throws
                            // an exception
                            if (xhr.__sentry_xhr__) {
                                xhr.__sentry_xhr__.status_code = xhr.status;
                            }
                        }
                        catch (e) {
                            /* do nothing */
                        }
                        try {
                            var requestPos = requestKeys.indexOf(xhr);
                            if (requestPos !== -1) {
                                // Make sure to pop both key and value to keep it in sync.
                                requestKeys.splice(requestPos);
                                var args_1 = requestValues.splice(requestPos)[0];
                                if (xhr.__sentry_xhr__ && args_1[0] !== undefined) {
                                    xhr.__sentry_xhr__.body = args_1[0];
                                }
                            }
                        }
                        catch (e) {
                            /* do nothing */
                        }
                        triggerHandlers('xhr', {
                            args: args,
                            endTimestamp: Date.now(),
                            startTimestamp: Date.now(),
                            xhr: xhr,
                        });
                    }
                };
                if ('onreadystatechange' in xhr && typeof xhr.onreadystatechange === 'function') {
                    fill(xhr, 'onreadystatechange', function (original) {
                        return function () {
                            var readyStateArgs = [];
                            for (var _i = 0; _i < arguments.length; _i++) {
                                readyStateArgs[_i] = arguments[_i];
                            }
                            onreadystatechangeHandler();
                            return original.apply(xhr, readyStateArgs);
                        };
                    });
                }
                else {
                    xhr.addEventListener('readystatechange', onreadystatechangeHandler);
                }
                return originalOpen.apply(xhr, args);
            };
        });
        fill(xhrproto, 'send', function (originalSend) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                requestKeys.push(this);
                requestValues.push(args);
                triggerHandlers('xhr', {
                    args: args,
                    startTimestamp: Date.now(),
                    xhr: this,
                });
                return originalSend.apply(this, args);
            };
        });
    }
    var lastHref;
    /** JSDoc */
    function instrumentHistory() {
        if (!supportsHistory()) {
            return;
        }
        var oldOnPopState = global$2.onpopstate;
        global$2.onpopstate = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var to = global$2.location.href;
            // keep track of the current URL state, as we always receive only the updated state
            var from = lastHref;
            lastHref = to;
            triggerHandlers('history', {
                from: from,
                to: to,
            });
            if (oldOnPopState) {
                return oldOnPopState.apply(this, args);
            }
        };
        /** @hidden */
        function historyReplacementFunction(originalHistoryFunction) {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var url = args.length > 2 ? args[2] : undefined;
                if (url) {
                    // coerce to string (this is what pushState does)
                    var from = lastHref;
                    var to = String(url);
                    // keep track of the current URL state, as we always receive only the updated state
                    lastHref = to;
                    triggerHandlers('history', {
                        from: from,
                        to: to,
                    });
                }
                return originalHistoryFunction.apply(this, args);
            };
        }
        fill(global$2.history, 'pushState', historyReplacementFunction);
        fill(global$2.history, 'replaceState', historyReplacementFunction);
    }
    var debounceDuration = 1000;
    var debounceTimerID;
    var lastCapturedEvent;
    /**
     * Decide whether the current event should finish the debounce of previously captured one.
     * @param previous previously captured event
     * @param current event to be captured
     */
    function shouldShortcircuitPreviousDebounce(previous, current) {
        // If there was no previous event, it should always be swapped for the new one.
        if (!previous) {
            return true;
        }
        // If both events have different type, then user definitely performed two separate actions. e.g. click + keypress.
        if (previous.type !== current.type) {
            return true;
        }
        try {
            // If both events have the same type, it's still possible that actions were performed on different targets.
            // e.g. 2 clicks on different buttons.
            if (previous.target !== current.target) {
                return true;
            }
        }
        catch (e) {
            // just accessing `target` property can throw an exception in some rare circumstances
            // see: https://github.com/getsentry/sentry-javascript/issues/838
        }
        // If both events have the same type _and_ same `target` (an element which triggered an event, _not necessarily_
        // to which an event listener was attached), we treat them as the same action, as we want to capture
        // only one breadcrumb. e.g. multiple clicks on the same button, or typing inside a user input box.
        return false;
    }
    /**
     * Decide whether an event should be captured.
     * @param event event to be captured
     */
    function shouldSkipDOMEvent(event) {
        // We are only interested in filtering `keypress` events for now.
        if (event.type !== 'keypress') {
            return false;
        }
        try {
            var target = event.target;
            if (!target || !target.tagName) {
                return true;
            }
            // Only consider keypress events on actual input elements. This will disregard keypresses targeting body
            // e.g.tabbing through elements, hotkeys, etc.
            if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.isContentEditable) {
                return false;
            }
        }
        catch (e) {
            // just accessing `target` property can throw an exception in some rare circumstances
            // see: https://github.com/getsentry/sentry-javascript/issues/838
        }
        return true;
    }
    /**
     * Wraps addEventListener to capture UI breadcrumbs
     * @param handler function that will be triggered
     * @param globalListener indicates whether event was captured by the global event listener
     * @returns wrapped breadcrumb events handler
     * @hidden
     */
    function makeDOMEventHandler(handler, globalListener) {
        if (globalListener === void 0) { globalListener = false; }
        return function (event) {
            // It's possible this handler might trigger multiple times for the same
            // event (e.g. event propagation through node ancestors).
            // Ignore if we've already captured that event.
            if (!event || lastCapturedEvent === event) {
                return;
            }
            // We always want to skip _some_ events.
            if (shouldSkipDOMEvent(event)) {
                return;
            }
            var name = event.type === 'keypress' ? 'input' : event.type;
            // If there is no debounce timer, it means that we can safely capture the new event and store it for future comparisons.
            if (debounceTimerID === undefined) {
                handler({
                    event: event,
                    name: name,
                    global: globalListener,
                });
                lastCapturedEvent = event;
            }
            // If there is a debounce awaiting, see if the new event is different enough to treat it as a unique one.
            // If that's the case, emit the previous event and store locally the newly-captured DOM event.
            else if (shouldShortcircuitPreviousDebounce(lastCapturedEvent, event)) {
                handler({
                    event: event,
                    name: name,
                    global: globalListener,
                });
                lastCapturedEvent = event;
            }
            // Start a new debounce timer that will prevent us from capturing multiple events that should be grouped together.
            clearTimeout(debounceTimerID);
            debounceTimerID = global$2.setTimeout(function () {
                debounceTimerID = undefined;
            }, debounceDuration);
        };
    }
    /** JSDoc */
    function instrumentDOM() {
        if (!('document' in global$2)) {
            return;
        }
        // Make it so that any click or keypress that is unhandled / bubbled up all the way to the document triggers our dom
        // handlers. (Normally we have only one, which captures a breadcrumb for each click or keypress.) Do this before
        // we instrument `addEventListener` so that we don't end up attaching this handler twice.
        var triggerDOMHandler = triggerHandlers.bind(null, 'dom');
        var globalDOMEventHandler = makeDOMEventHandler(triggerDOMHandler, true);
        global$2.document.addEventListener('click', globalDOMEventHandler, false);
        global$2.document.addEventListener('keypress', globalDOMEventHandler, false);
        // After hooking into click and keypress events bubbled up to `document`, we also hook into user-handled
        // clicks & keypresses, by adding an event listener of our own to any element to which they add a listener. That
        // way, whenever one of their handlers is triggered, ours will be, too. (This is needed because their handler
        // could potentially prevent the event from bubbling up to our global listeners. This way, our handler are still
        // guaranteed to fire at least once.)
        ['EventTarget', 'Node'].forEach(function (target) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            var proto = global$2[target] && global$2[target].prototype;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, no-prototype-builtins
            if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
                return;
            }
            fill(proto, 'addEventListener', function (originalAddEventListener) {
                return function (type, listener, options) {
                    if (type === 'click' || type == 'keypress') {
                        try {
                            var el = this;
                            var handlers_1 = (el.__sentry_instrumentation_handlers__ = el.__sentry_instrumentation_handlers__ || {});
                            var handlerForType = (handlers_1[type] = handlers_1[type] || { refCount: 0 });
                            if (!handlerForType.handler) {
                                var handler = makeDOMEventHandler(triggerDOMHandler);
                                handlerForType.handler = handler;
                                originalAddEventListener.call(this, type, handler, options);
                            }
                            handlerForType.refCount += 1;
                        }
                        catch (e) {
                            // Accessing dom properties is always fragile.
                            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                        }
                    }
                    return originalAddEventListener.call(this, type, listener, options);
                };
            });
            fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
                return function (type, listener, options) {
                    if (type === 'click' || type == 'keypress') {
                        try {
                            var el = this;
                            var handlers_2 = el.__sentry_instrumentation_handlers__ || {};
                            var handlerForType = handlers_2[type];
                            if (handlerForType) {
                                handlerForType.refCount -= 1;
                                // If there are no longer any custom handlers of the current type on this element, we can remove ours, too.
                                if (handlerForType.refCount <= 0) {
                                    originalRemoveEventListener.call(this, type, handlerForType.handler, options);
                                    handlerForType.handler = undefined;
                                    delete handlers_2[type]; // eslint-disable-line @typescript-eslint/no-dynamic-delete
                                }
                                // If there are no longer any custom handlers of any type on this element, cleanup everything.
                                if (Object.keys(handlers_2).length === 0) {
                                    delete el.__sentry_instrumentation_handlers__;
                                }
                            }
                        }
                        catch (e) {
                            // Accessing dom properties is always fragile.
                            // Also allows us to skip `addEventListenrs` calls with no proper `this` context.
                        }
                    }
                    return originalRemoveEventListener.call(this, type, listener, options);
                };
            });
        });
    }
    var _oldOnErrorHandler = null;
    /** JSDoc */
    function instrumentError() {
        _oldOnErrorHandler = global$2.onerror;
        global$2.onerror = function (msg, url, line, column, error) {
            triggerHandlers('error', {
                column: column,
                error: error,
                line: line,
                msg: msg,
                url: url,
            });
            if (_oldOnErrorHandler) {
                // eslint-disable-next-line prefer-rest-params
                return _oldOnErrorHandler.apply(this, arguments);
            }
            return false;
        };
    }
    var _oldOnUnhandledRejectionHandler = null;
    /** JSDoc */
    function instrumentUnhandledRejection() {
        _oldOnUnhandledRejectionHandler = global$2.onunhandledrejection;
        global$2.onunhandledrejection = function (e) {
            triggerHandlers('unhandledrejection', e);
            if (_oldOnUnhandledRejectionHandler) {
                // eslint-disable-next-line prefer-rest-params
                return _oldOnUnhandledRejectionHandler.apply(this, arguments);
            }
            return true;
        };
    }

    /* eslint-disable @typescript-eslint/explicit-function-return-type */
    /** SyncPromise internal states */
    var States;
    (function (States) {
        /** Pending */
        States["PENDING"] = "PENDING";
        /** Resolved / OK */
        States["RESOLVED"] = "RESOLVED";
        /** Rejected / Error */
        States["REJECTED"] = "REJECTED";
    })(States || (States = {}));
    /**
     * Thenable class that behaves like a Promise and follows it's interface
     * but is not async internally
     */
    var SyncPromise = /** @class */ (function () {
        function SyncPromise(executor) {
            var _this = this;
            this._state = States.PENDING;
            this._handlers = [];
            /** JSDoc */
            this._resolve = function (value) {
                _this._setResult(States.RESOLVED, value);
            };
            /** JSDoc */
            this._reject = function (reason) {
                _this._setResult(States.REJECTED, reason);
            };
            /** JSDoc */
            this._setResult = function (state, value) {
                if (_this._state !== States.PENDING) {
                    return;
                }
                if (isThenable(value)) {
                    value.then(_this._resolve, _this._reject);
                    return;
                }
                _this._state = state;
                _this._value = value;
                _this._executeHandlers();
            };
            // TODO: FIXME
            /** JSDoc */
            this._attachHandler = function (handler) {
                _this._handlers = _this._handlers.concat(handler);
                _this._executeHandlers();
            };
            /** JSDoc */
            this._executeHandlers = function () {
                if (_this._state === States.PENDING) {
                    return;
                }
                var cachedHandlers = _this._handlers.slice();
                _this._handlers = [];
                cachedHandlers.forEach(function (handler) {
                    if (handler.done) {
                        return;
                    }
                    if (_this._state === States.RESOLVED) {
                        if (handler.onfulfilled) {
                            // eslint-disable-next-line @typescript-eslint/no-floating-promises
                            handler.onfulfilled(_this._value);
                        }
                    }
                    if (_this._state === States.REJECTED) {
                        if (handler.onrejected) {
                            handler.onrejected(_this._value);
                        }
                    }
                    handler.done = true;
                });
            };
            try {
                executor(this._resolve, this._reject);
            }
            catch (e) {
                this._reject(e);
            }
        }
        /** JSDoc */
        SyncPromise.resolve = function (value) {
            return new SyncPromise(function (resolve) {
                resolve(value);
            });
        };
        /** JSDoc */
        SyncPromise.reject = function (reason) {
            return new SyncPromise(function (_, reject) {
                reject(reason);
            });
        };
        /** JSDoc */
        SyncPromise.all = function (collection) {
            return new SyncPromise(function (resolve, reject) {
                if (!Array.isArray(collection)) {
                    reject(new TypeError("Promise.all requires an array as input."));
                    return;
                }
                if (collection.length === 0) {
                    resolve([]);
                    return;
                }
                var counter = collection.length;
                var resolvedCollection = [];
                collection.forEach(function (item, index) {
                    SyncPromise.resolve(item)
                        .then(function (value) {
                        resolvedCollection[index] = value;
                        counter -= 1;
                        if (counter !== 0) {
                            return;
                        }
                        resolve(resolvedCollection);
                    })
                        .then(null, reject);
                });
            });
        };
        /** JSDoc */
        SyncPromise.prototype.then = function (onfulfilled, onrejected) {
            var _this = this;
            return new SyncPromise(function (resolve, reject) {
                _this._attachHandler({
                    done: false,
                    onfulfilled: function (result) {
                        if (!onfulfilled) {
                            // TODO: ¯\_(ツ)_/¯
                            // TODO: FIXME
                            resolve(result);
                            return;
                        }
                        try {
                            resolve(onfulfilled(result));
                            return;
                        }
                        catch (e) {
                            reject(e);
                            return;
                        }
                    },
                    onrejected: function (reason) {
                        if (!onrejected) {
                            reject(reason);
                            return;
                        }
                        try {
                            resolve(onrejected(reason));
                            return;
                        }
                        catch (e) {
                            reject(e);
                            return;
                        }
                    },
                });
            });
        };
        /** JSDoc */
        SyncPromise.prototype.catch = function (onrejected) {
            return this.then(function (val) { return val; }, onrejected);
        };
        /** JSDoc */
        SyncPromise.prototype.finally = function (onfinally) {
            var _this = this;
            return new SyncPromise(function (resolve, reject) {
                var val;
                var isRejected;
                return _this.then(function (value) {
                    isRejected = false;
                    val = value;
                    if (onfinally) {
                        onfinally();
                    }
                }, function (reason) {
                    isRejected = true;
                    val = reason;
                    if (onfinally) {
                        onfinally();
                    }
                }).then(function () {
                    if (isRejected) {
                        reject(val);
                        return;
                    }
                    resolve(val);
                });
            });
        };
        /** JSDoc */
        SyncPromise.prototype.toString = function () {
            return '[object SyncPromise]';
        };
        return SyncPromise;
    }());

    /** A simple queue that holds promises. */
    var PromiseBuffer = /** @class */ (function () {
        function PromiseBuffer(_limit) {
            this._limit = _limit;
            /** Internal set of queued Promises */
            this._buffer = [];
        }
        /**
         * Says if the buffer is ready to take more requests
         */
        PromiseBuffer.prototype.isReady = function () {
            return this._limit === undefined || this.length() < this._limit;
        };
        /**
         * Add a promise to the queue.
         *
         * @param task Can be any PromiseLike<T>
         * @returns The original promise.
         */
        PromiseBuffer.prototype.add = function (task) {
            var _this = this;
            if (!this.isReady()) {
                return SyncPromise.reject(new SentryError('Not adding Promise due to buffer limit reached.'));
            }
            if (this._buffer.indexOf(task) === -1) {
                this._buffer.push(task);
            }
            task
                .then(function () { return _this.remove(task); })
                .then(null, function () {
                return _this.remove(task).then(null, function () {
                    // We have to add this catch here otherwise we have an unhandledPromiseRejection
                    // because it's a new Promise chain.
                });
            });
            return task;
        };
        /**
         * Remove a promise to the queue.
         *
         * @param task Can be any PromiseLike<T>
         * @returns Removed promise.
         */
        PromiseBuffer.prototype.remove = function (task) {
            var removedTask = this._buffer.splice(this._buffer.indexOf(task), 1)[0];
            return removedTask;
        };
        /**
         * This function returns the number of unresolved promises in the queue.
         */
        PromiseBuffer.prototype.length = function () {
            return this._buffer.length;
        };
        /**
         * This will drain the whole queue, returns true if queue is empty or drained.
         * If timeout is provided and the queue takes longer to drain, the promise still resolves but with false.
         *
         * @param timeout Number in ms to wait until it resolves with false.
         */
        PromiseBuffer.prototype.drain = function (timeout) {
            var _this = this;
            return new SyncPromise(function (resolve) {
                var capturedSetTimeout = setTimeout(function () {
                    if (timeout && timeout > 0) {
                        resolve(false);
                    }
                }, timeout);
                SyncPromise.all(_this._buffer)
                    .then(function () {
                    clearTimeout(capturedSetTimeout);
                    resolve(true);
                })
                    .then(null, function () {
                    resolve(true);
                });
            });
        };
        return PromiseBuffer;
    }());

    /**
     * A TimestampSource implementation for environments that do not support the Performance Web API natively.
     *
     * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
     * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
     * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
     */
    var dateTimestampSource = {
        nowSeconds: function () { return Date.now() / 1000; },
    };
    /**
     * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
     * support the API.
     *
     * Wrapping the native API works around differences in behavior from different browsers.
     */
    function getBrowserPerformance() {
        var performance = getGlobalObject().performance;
        if (!performance || !performance.now) {
            return undefined;
        }
        // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
        //
        // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
        // performance.now() gives a date arbitrarily in the past.
        //
        // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
        // undefined.
        //
        // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
        // interact with data coming out of performance entries.
        //
        // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
        // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
        // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
        // observed skews that can be as long as days, weeks or months.
        //
        // See https://github.com/getsentry/sentry-javascript/issues/2590.
        //
        // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
        // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
        // transactions of long-lived web pages.
        var timeOrigin = Date.now() - performance.now();
        return {
            now: function () { return performance.now(); },
            timeOrigin: timeOrigin,
        };
    }
    /**
     * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
     * implement the API.
     */
    function getNodePerformance() {
        try {
            var perfHooks = dynamicRequire(module, 'perf_hooks');
            return perfHooks.performance;
        }
        catch (_) {
            return undefined;
        }
    }
    /**
     * The Performance API implementation for the current platform, if available.
     */
    var platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();
    var timestampSource = platformPerformance === undefined
        ? dateTimestampSource
        : {
            nowSeconds: function () { return (platformPerformance.timeOrigin + platformPerformance.now()) / 1000; },
        };
    /**
     * Returns a timestamp in seconds since the UNIX epoch using the Date API.
     */
    var dateTimestampInSeconds = dateTimestampSource.nowSeconds.bind(dateTimestampSource);
    /**
     * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
     * availability of the Performance API.
     *
     * See `usingPerformanceAPI` to test whether the Performance API is used.
     *
     * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
     * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
     * skew can grow to arbitrary amounts like days, weeks or months.
     * See https://github.com/getsentry/sentry-javascript/issues/2590.
     */
    var timestampInSeconds = timestampSource.nowSeconds.bind(timestampSource);
    // Re-exported with an old name for backwards-compatibility.
    var timestampWithMs = timestampInSeconds;
    /**
     * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
     * performance API is available.
     */
    var browserPerformanceTimeOrigin = (function () {
        var performance = getGlobalObject().performance;
        if (!performance) {
            return undefined;
        }
        if (performance.timeOrigin) {
            return performance.timeOrigin;
        }
        // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
        // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
        // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
        // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
        // Date API.
        // eslint-disable-next-line deprecation/deprecation
        return (performance.timing && performance.timing.navigationStart) || Date.now();
    })();

    /**
     * Holds additional event information. {@link Scope.applyToEvent} will be
     * called by the client before an event will be sent.
     */
    var Scope = /** @class */ (function () {
        function Scope() {
            /** Flag if notifiying is happening. */
            this._notifyingListeners = false;
            /** Callback for client to receive scope changes. */
            this._scopeListeners = [];
            /** Callback list that will be called after {@link applyToEvent}. */
            this._eventProcessors = [];
            /** Array of breadcrumbs. */
            this._breadcrumbs = [];
            /** User */
            this._user = {};
            /** Tags */
            this._tags = {};
            /** Extra */
            this._extra = {};
            /** Contexts */
            this._contexts = {};
        }
        /**
         * Inherit values from the parent scope.
         * @param scope to clone.
         */
        Scope.clone = function (scope) {
            var newScope = new Scope();
            if (scope) {
                newScope._breadcrumbs = __spread(scope._breadcrumbs);
                newScope._tags = __assign({}, scope._tags);
                newScope._extra = __assign({}, scope._extra);
                newScope._contexts = __assign({}, scope._contexts);
                newScope._user = scope._user;
                newScope._level = scope._level;
                newScope._span = scope._span;
                newScope._session = scope._session;
                newScope._transactionName = scope._transactionName;
                newScope._fingerprint = scope._fingerprint;
                newScope._eventProcessors = __spread(scope._eventProcessors);
            }
            return newScope;
        };
        /**
         * Add internal on change listener. Used for sub SDKs that need to store the scope.
         * @hidden
         */
        Scope.prototype.addScopeListener = function (callback) {
            this._scopeListeners.push(callback);
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.addEventProcessor = function (callback) {
            this._eventProcessors.push(callback);
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setUser = function (user) {
            this._user = user || {};
            if (this._session) {
                this._session.update({ user: user });
            }
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.getUser = function () {
            return this._user;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setTags = function (tags) {
            this._tags = __assign(__assign({}, this._tags), tags);
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setTag = function (key, value) {
            var _a;
            this._tags = __assign(__assign({}, this._tags), (_a = {}, _a[key] = value, _a));
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setExtras = function (extras) {
            this._extra = __assign(__assign({}, this._extra), extras);
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setExtra = function (key, extra) {
            var _a;
            this._extra = __assign(__assign({}, this._extra), (_a = {}, _a[key] = extra, _a));
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setFingerprint = function (fingerprint) {
            this._fingerprint = fingerprint;
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setLevel = function (level) {
            this._level = level;
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setTransactionName = function (name) {
            this._transactionName = name;
            this._notifyScopeListeners();
            return this;
        };
        /**
         * Can be removed in major version.
         * @deprecated in favor of {@link this.setTransactionName}
         */
        Scope.prototype.setTransaction = function (name) {
            return this.setTransactionName(name);
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setContext = function (key, context) {
            var _a;
            if (context === null) {
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this._contexts[key];
            }
            else {
                this._contexts = __assign(__assign({}, this._contexts), (_a = {}, _a[key] = context, _a));
            }
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setSpan = function (span) {
            this._span = span;
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.getSpan = function () {
            return this._span;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.getTransaction = function () {
            var _a, _b, _c, _d;
            // often, this span will be a transaction, but it's not guaranteed to be
            var span = this.getSpan();
            // try it the new way first
            if ((_a = span) === null || _a === void 0 ? void 0 : _a.transaction) {
                return (_b = span) === null || _b === void 0 ? void 0 : _b.transaction;
            }
            // fallback to the old way (known bug: this only finds transactions with sampled = true)
            if ((_d = (_c = span) === null || _c === void 0 ? void 0 : _c.spanRecorder) === null || _d === void 0 ? void 0 : _d.spans[0]) {
                return span.spanRecorder.spans[0];
            }
            // neither way found a transaction
            return undefined;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.setSession = function (session) {
            if (!session) {
                delete this._session;
            }
            else {
                this._session = session;
            }
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.getSession = function () {
            return this._session;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.update = function (captureContext) {
            if (!captureContext) {
                return this;
            }
            if (typeof captureContext === 'function') {
                var updatedScope = captureContext(this);
                return updatedScope instanceof Scope ? updatedScope : this;
            }
            if (captureContext instanceof Scope) {
                this._tags = __assign(__assign({}, this._tags), captureContext._tags);
                this._extra = __assign(__assign({}, this._extra), captureContext._extra);
                this._contexts = __assign(__assign({}, this._contexts), captureContext._contexts);
                if (captureContext._user && Object.keys(captureContext._user).length) {
                    this._user = captureContext._user;
                }
                if (captureContext._level) {
                    this._level = captureContext._level;
                }
                if (captureContext._fingerprint) {
                    this._fingerprint = captureContext._fingerprint;
                }
            }
            else if (isPlainObject(captureContext)) {
                // eslint-disable-next-line no-param-reassign
                captureContext = captureContext;
                this._tags = __assign(__assign({}, this._tags), captureContext.tags);
                this._extra = __assign(__assign({}, this._extra), captureContext.extra);
                this._contexts = __assign(__assign({}, this._contexts), captureContext.contexts);
                if (captureContext.user) {
                    this._user = captureContext.user;
                }
                if (captureContext.level) {
                    this._level = captureContext.level;
                }
                if (captureContext.fingerprint) {
                    this._fingerprint = captureContext.fingerprint;
                }
            }
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.clear = function () {
            this._breadcrumbs = [];
            this._tags = {};
            this._extra = {};
            this._user = {};
            this._contexts = {};
            this._level = undefined;
            this._transactionName = undefined;
            this._fingerprint = undefined;
            this._span = undefined;
            this._session = undefined;
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.addBreadcrumb = function (breadcrumb, maxBreadcrumbs) {
            var mergedBreadcrumb = __assign({ timestamp: dateTimestampInSeconds() }, breadcrumb);
            this._breadcrumbs =
                maxBreadcrumbs !== undefined && maxBreadcrumbs >= 0
                    ? __spread(this._breadcrumbs, [mergedBreadcrumb]).slice(-maxBreadcrumbs)
                    : __spread(this._breadcrumbs, [mergedBreadcrumb]);
            this._notifyScopeListeners();
            return this;
        };
        /**
         * @inheritDoc
         */
        Scope.prototype.clearBreadcrumbs = function () {
            this._breadcrumbs = [];
            this._notifyScopeListeners();
            return this;
        };
        /**
         * Applies the current context and fingerprint to the event.
         * Note that breadcrumbs will be added by the client.
         * Also if the event has already breadcrumbs on it, we do not merge them.
         * @param event Event
         * @param hint May contain additional informartion about the original exception.
         * @hidden
         */
        Scope.prototype.applyToEvent = function (event, hint) {
            var _a;
            if (this._extra && Object.keys(this._extra).length) {
                event.extra = __assign(__assign({}, this._extra), event.extra);
            }
            if (this._tags && Object.keys(this._tags).length) {
                event.tags = __assign(__assign({}, this._tags), event.tags);
            }
            if (this._user && Object.keys(this._user).length) {
                event.user = __assign(__assign({}, this._user), event.user);
            }
            if (this._contexts && Object.keys(this._contexts).length) {
                event.contexts = __assign(__assign({}, this._contexts), event.contexts);
            }
            if (this._level) {
                event.level = this._level;
            }
            if (this._transactionName) {
                event.transaction = this._transactionName;
            }
            // We want to set the trace context for normal events only if there isn't already
            // a trace context on the event. There is a product feature in place where we link
            // errors with transaction and it relys on that.
            if (this._span) {
                event.contexts = __assign({ trace: this._span.getTraceContext() }, event.contexts);
                var transactionName = (_a = this._span.transaction) === null || _a === void 0 ? void 0 : _a.name;
                if (transactionName) {
                    event.tags = __assign({ transaction: transactionName }, event.tags);
                }
            }
            this._applyFingerprint(event);
            event.breadcrumbs = __spread((event.breadcrumbs || []), this._breadcrumbs);
            event.breadcrumbs = event.breadcrumbs.length > 0 ? event.breadcrumbs : undefined;
            return this._notifyEventProcessors(__spread(getGlobalEventProcessors(), this._eventProcessors), event, hint);
        };
        /**
         * This will be called after {@link applyToEvent} is finished.
         */
        Scope.prototype._notifyEventProcessors = function (processors, event, hint, index) {
            var _this = this;
            if (index === void 0) { index = 0; }
            return new SyncPromise(function (resolve, reject) {
                var processor = processors[index];
                if (event === null || typeof processor !== 'function') {
                    resolve(event);
                }
                else {
                    var result = processor(__assign({}, event), hint);
                    if (isThenable(result)) {
                        result
                            .then(function (final) { return _this._notifyEventProcessors(processors, final, hint, index + 1).then(resolve); })
                            .then(null, reject);
                    }
                    else {
                        _this._notifyEventProcessors(processors, result, hint, index + 1)
                            .then(resolve)
                            .then(null, reject);
                    }
                }
            });
        };
        /**
         * This will be called on every set call.
         */
        Scope.prototype._notifyScopeListeners = function () {
            var _this = this;
            // We need this check for this._notifyingListeners to be able to work on scope during updates
            // If this check is not here we'll produce endless recursion when something is done with the scope
            // during the callback.
            if (!this._notifyingListeners) {
                this._notifyingListeners = true;
                this._scopeListeners.forEach(function (callback) {
                    callback(_this);
                });
                this._notifyingListeners = false;
            }
        };
        /**
         * Applies fingerprint from the scope to the event if there's one,
         * uses message if there's one instead or get rid of empty fingerprint
         */
        Scope.prototype._applyFingerprint = function (event) {
            // Make sure it's an array first and we actually have something in place
            event.fingerprint = event.fingerprint
                ? Array.isArray(event.fingerprint)
                    ? event.fingerprint
                    : [event.fingerprint]
                : [];
            // If we have something on the scope, then merge it with event
            if (this._fingerprint) {
                event.fingerprint = event.fingerprint.concat(this._fingerprint);
            }
            // If we have no data at all, remove empty array default
            if (event.fingerprint && !event.fingerprint.length) {
                delete event.fingerprint;
            }
        };
        return Scope;
    }());
    /**
     * Retruns the global event processors.
     */
    function getGlobalEventProcessors() {
        /* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access  */
        var global = getGlobalObject();
        global.__SENTRY__ = global.__SENTRY__ || {};
        global.__SENTRY__.globalEventProcessors = global.__SENTRY__.globalEventProcessors || [];
        return global.__SENTRY__.globalEventProcessors;
        /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access */
    }
    /**
     * Add a EventProcessor to be kept globally.
     * @param callback EventProcessor to add
     */
    function addGlobalEventProcessor(callback) {
        getGlobalEventProcessors().push(callback);
    }

    /**
     * @inheritdoc
     */
    var Session = /** @class */ (function () {
        function Session(context) {
            this.errors = 0;
            this.sid = uuid4();
            this.timestamp = Date.now();
            this.started = Date.now();
            this.duration = 0;
            this.status = SessionStatus.Ok;
            this.init = true;
            if (context) {
                this.update(context);
            }
        }
        /** JSDoc */
        // eslint-disable-next-line complexity
        Session.prototype.update = function (context) {
            if (context === void 0) { context = {}; }
            if (context.user) {
                if (context.user.ip_address) {
                    this.ipAddress = context.user.ip_address;
                }
                if (!context.did) {
                    this.did = context.user.id || context.user.email || context.user.username;
                }
            }
            this.timestamp = context.timestamp || Date.now();
            if (context.sid) {
                // Good enough uuid validation. — Kamil
                this.sid = context.sid.length === 32 ? context.sid : uuid4();
            }
            if (context.init !== undefined) {
                this.init = context.init;
            }
            if (context.did) {
                this.did = "" + context.did;
            }
            if (typeof context.started === 'number') {
                this.started = context.started;
            }
            if (typeof context.duration === 'number') {
                this.duration = context.duration;
            }
            else {
                this.duration = this.timestamp - this.started;
            }
            if (context.release) {
                this.release = context.release;
            }
            if (context.environment) {
                this.environment = context.environment;
            }
            if (context.ipAddress) {
                this.ipAddress = context.ipAddress;
            }
            if (context.userAgent) {
                this.userAgent = context.userAgent;
            }
            if (typeof context.errors === 'number') {
                this.errors = context.errors;
            }
            if (context.status) {
                this.status = context.status;
            }
        };
        /** JSDoc */
        Session.prototype.close = function (status) {
            if (status) {
                this.update({ status: status });
            }
            else if (this.status === SessionStatus.Ok) {
                this.update({ status: SessionStatus.Exited });
            }
            else {
                this.update();
            }
        };
        /** JSDoc */
        Session.prototype.toJSON = function () {
            return dropUndefinedKeys({
                sid: "" + this.sid,
                init: this.init,
                started: new Date(this.started).toISOString(),
                timestamp: new Date(this.timestamp).toISOString(),
                status: this.status,
                errors: this.errors,
                did: typeof this.did === 'number' || typeof this.did === 'string' ? "" + this.did : undefined,
                duration: this.duration,
                attrs: dropUndefinedKeys({
                    release: this.release,
                    environment: this.environment,
                    ip_address: this.ipAddress,
                    user_agent: this.userAgent,
                }),
            });
        };
        return Session;
    }());

    /**
     * API compatibility version of this hub.
     *
     * WARNING: This number should only be increased when the global interface
     * changes and new methods are introduced.
     *
     * @hidden
     */
    var API_VERSION = 3;
    /**
     * Default maximum number of breadcrumbs added to an event. Can be overwritten
     * with {@link Options.maxBreadcrumbs}.
     */
    var DEFAULT_BREADCRUMBS = 100;
    /**
     * Absolute maximum number of breadcrumbs added to an event. The
     * `maxBreadcrumbs` option cannot be higher than this value.
     */
    var MAX_BREADCRUMBS = 100;
    /**
     * @inheritDoc
     */
    var Hub = /** @class */ (function () {
        /**
         * Creates a new instance of the hub, will push one {@link Layer} into the
         * internal stack on creation.
         *
         * @param client bound to the hub.
         * @param scope bound to the hub.
         * @param version number, higher number means higher priority.
         */
        function Hub(client, scope, _version) {
            if (scope === void 0) { scope = new Scope(); }
            if (_version === void 0) { _version = API_VERSION; }
            this._version = _version;
            /** Is a {@link Layer}[] containing the client and scope */
            this._stack = [{}];
            this.getStackTop().scope = scope;
            this.bindClient(client);
        }
        /**
         * @inheritDoc
         */
        Hub.prototype.isOlderThan = function (version) {
            return this._version < version;
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.bindClient = function (client) {
            var top = this.getStackTop();
            top.client = client;
            if (client && client.setupIntegrations) {
                client.setupIntegrations();
            }
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.pushScope = function () {
            // We want to clone the content of prev scope
            var scope = Scope.clone(this.getScope());
            this.getStack().push({
                client: this.getClient(),
                scope: scope,
            });
            return scope;
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.popScope = function () {
            if (this.getStack().length <= 1)
                return false;
            return !!this.getStack().pop();
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.withScope = function (callback) {
            var scope = this.pushScope();
            try {
                callback(scope);
            }
            finally {
                this.popScope();
            }
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.getClient = function () {
            return this.getStackTop().client;
        };
        /** Returns the scope of the top stack. */
        Hub.prototype.getScope = function () {
            return this.getStackTop().scope;
        };
        /** Returns the scope stack for domains or the process. */
        Hub.prototype.getStack = function () {
            return this._stack;
        };
        /** Returns the topmost scope layer in the order domain > local > process. */
        Hub.prototype.getStackTop = function () {
            return this._stack[this._stack.length - 1];
        };
        /**
         * @inheritDoc
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
        Hub.prototype.captureException = function (exception, hint) {
            var eventId = (this._lastEventId = uuid4());
            var finalHint = hint;
            // If there's no explicit hint provided, mimick the same thing that would happen
            // in the minimal itself to create a consistent behavior.
            // We don't do this in the client, as it's the lowest level API, and doing this,
            // would prevent user from having full control over direct calls.
            if (!hint) {
                var syntheticException = void 0;
                try {
                    throw new Error('Sentry syntheticException');
                }
                catch (exception) {
                    syntheticException = exception;
                }
                finalHint = {
                    originalException: exception,
                    syntheticException: syntheticException,
                };
            }
            this._invokeClient('captureException', exception, __assign(__assign({}, finalHint), { event_id: eventId }));
            return eventId;
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.captureMessage = function (message, level, hint) {
            var eventId = (this._lastEventId = uuid4());
            var finalHint = hint;
            // If there's no explicit hint provided, mimick the same thing that would happen
            // in the minimal itself to create a consistent behavior.
            // We don't do this in the client, as it's the lowest level API, and doing this,
            // would prevent user from having full control over direct calls.
            if (!hint) {
                var syntheticException = void 0;
                try {
                    throw new Error(message);
                }
                catch (exception) {
                    syntheticException = exception;
                }
                finalHint = {
                    originalException: message,
                    syntheticException: syntheticException,
                };
            }
            this._invokeClient('captureMessage', message, level, __assign(__assign({}, finalHint), { event_id: eventId }));
            return eventId;
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.captureEvent = function (event, hint) {
            var eventId = (this._lastEventId = uuid4());
            this._invokeClient('captureEvent', event, __assign(__assign({}, hint), { event_id: eventId }));
            return eventId;
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.lastEventId = function () {
            return this._lastEventId;
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.addBreadcrumb = function (breadcrumb, hint) {
            var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
            if (!scope || !client)
                return;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            var _b = (client.getOptions && client.getOptions()) || {}, _c = _b.beforeBreadcrumb, beforeBreadcrumb = _c === void 0 ? null : _c, _d = _b.maxBreadcrumbs, maxBreadcrumbs = _d === void 0 ? DEFAULT_BREADCRUMBS : _d;
            if (maxBreadcrumbs <= 0)
                return;
            var timestamp = dateTimestampInSeconds();
            var mergedBreadcrumb = __assign({ timestamp: timestamp }, breadcrumb);
            var finalBreadcrumb = beforeBreadcrumb
                ? consoleSandbox(function () { return beforeBreadcrumb(mergedBreadcrumb, hint); })
                : mergedBreadcrumb;
            if (finalBreadcrumb === null)
                return;
            scope.addBreadcrumb(finalBreadcrumb, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.setUser = function (user) {
            var scope = this.getScope();
            if (scope)
                scope.setUser(user);
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.setTags = function (tags) {
            var scope = this.getScope();
            if (scope)
                scope.setTags(tags);
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.setExtras = function (extras) {
            var scope = this.getScope();
            if (scope)
                scope.setExtras(extras);
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.setTag = function (key, value) {
            var scope = this.getScope();
            if (scope)
                scope.setTag(key, value);
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.setExtra = function (key, extra) {
            var scope = this.getScope();
            if (scope)
                scope.setExtra(key, extra);
        };
        /**
         * @inheritDoc
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Hub.prototype.setContext = function (name, context) {
            var scope = this.getScope();
            if (scope)
                scope.setContext(name, context);
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.configureScope = function (callback) {
            var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
            if (scope && client) {
                callback(scope);
            }
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.run = function (callback) {
            var oldHub = makeMain(this);
            try {
                callback(this);
            }
            finally {
                makeMain(oldHub);
            }
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.getIntegration = function (integration) {
            var client = this.getClient();
            if (!client)
                return null;
            try {
                return client.getIntegration(integration);
            }
            catch (_oO) {
                logger.warn("Cannot retrieve integration " + integration.id + " from the current Hub");
                return null;
            }
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.startSpan = function (context) {
            return this._callExtensionMethod('startSpan', context);
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.startTransaction = function (context, customSamplingContext) {
            return this._callExtensionMethod('startTransaction', context, customSamplingContext);
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.traceHeaders = function () {
            return this._callExtensionMethod('traceHeaders');
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.captureSession = function (endSession) {
            if (endSession === void 0) { endSession = false; }
            // both send the update and pull the session from the scope
            if (endSession) {
                return this.endSession();
            }
            // only send the update
            this._sendSessionUpdate();
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.endSession = function () {
            var _a, _b, _c, _d, _e;
            (_c = (_b = (_a = this.getStackTop()) === null || _a === void 0 ? void 0 : _a.scope) === null || _b === void 0 ? void 0 : _b.getSession()) === null || _c === void 0 ? void 0 : _c.close();
            this._sendSessionUpdate();
            // the session is over; take it off of the scope
            (_e = (_d = this.getStackTop()) === null || _d === void 0 ? void 0 : _d.scope) === null || _e === void 0 ? void 0 : _e.setSession();
        };
        /**
         * @inheritDoc
         */
        Hub.prototype.startSession = function (context) {
            var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
            var _b = (client && client.getOptions()) || {}, release = _b.release, environment = _b.environment;
            var session = new Session(__assign(__assign({ release: release,
                environment: environment }, (scope && { user: scope.getUser() })), context));
            if (scope) {
                // End existing session if there's one
                var currentSession = scope.getSession && scope.getSession();
                if (currentSession && currentSession.status === SessionStatus.Ok) {
                    currentSession.update({ status: SessionStatus.Exited });
                }
                this.endSession();
                // Afterwards we set the new session on the scope
                scope.setSession(session);
            }
            return session;
        };
        /**
         * Sends the current Session on the scope
         */
        Hub.prototype._sendSessionUpdate = function () {
            var _a = this.getStackTop(), scope = _a.scope, client = _a.client;
            if (!scope)
                return;
            var session = scope.getSession && scope.getSession();
            if (session) {
                if (client && client.captureSession) {
                    client.captureSession(session);
                }
            }
        };
        /**
         * Internal helper function to call a method on the top client if it exists.
         *
         * @param method The method to call on the client.
         * @param args Arguments to pass to the client function.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Hub.prototype._invokeClient = function (method) {
            var _a;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _b = this.getStackTop(), scope = _b.scope, client = _b.client;
            if (client && client[method]) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
                (_a = client)[method].apply(_a, __spread(args, [scope]));
            }
        };
        /**
         * Calls global extension method and binding current instance to the function call
         */
        // @ts-ignore Function lacks ending return statement and return type does not include 'undefined'. ts(2366)
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Hub.prototype._callExtensionMethod = function (method) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var carrier = getMainCarrier();
            var sentry = carrier.__SENTRY__;
            if (sentry && sentry.extensions && typeof sentry.extensions[method] === 'function') {
                return sentry.extensions[method].apply(this, args);
            }
            logger.warn("Extension method " + method + " couldn't be found, doing nothing.");
        };
        return Hub;
    }());
    /** Returns the global shim registry. */
    function getMainCarrier() {
        var carrier = getGlobalObject();
        carrier.__SENTRY__ = carrier.__SENTRY__ || {
            extensions: {},
            hub: undefined,
        };
        return carrier;
    }
    /**
     * Replaces the current main hub with the passed one on the global object
     *
     * @returns The old replaced hub
     */
    function makeMain(hub) {
        var registry = getMainCarrier();
        var oldHub = getHubFromCarrier(registry);
        setHubOnCarrier(registry, hub);
        return oldHub;
    }
    /**
     * Returns the default hub instance.
     *
     * If a hub is already registered in the global carrier but this module
     * contains a more recent version, it replaces the registered version.
     * Otherwise, the currently registered hub will be returned.
     */
    function getCurrentHub() {
        // Get main carrier (global for every environment)
        var registry = getMainCarrier();
        // If there's no hub, or its an old API, assign a new one
        if (!hasHubOnCarrier(registry) || getHubFromCarrier(registry).isOlderThan(API_VERSION)) {
            setHubOnCarrier(registry, new Hub());
        }
        // Prefer domains over global if they are there (applicable only to Node environment)
        if (isNodeEnv()) {
            return getHubFromActiveDomain(registry);
        }
        // Return hub that lives on a global object
        return getHubFromCarrier(registry);
    }
    /**
     * Try to read the hub from an active domain, and fallback to the registry if one doesn't exist
     * @returns discovered hub
     */
    function getHubFromActiveDomain(registry) {
        var _a, _b, _c;
        try {
            var activeDomain = (_c = (_b = (_a = getMainCarrier().__SENTRY__) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.domain) === null || _c === void 0 ? void 0 : _c.active;
            // If there's no active domain, just return global hub
            if (!activeDomain) {
                return getHubFromCarrier(registry);
            }
            // If there's no hub on current domain, or it's an old API, assign a new one
            if (!hasHubOnCarrier(activeDomain) || getHubFromCarrier(activeDomain).isOlderThan(API_VERSION)) {
                var registryHubTopStack = getHubFromCarrier(registry).getStackTop();
                setHubOnCarrier(activeDomain, new Hub(registryHubTopStack.client, Scope.clone(registryHubTopStack.scope)));
            }
            // Return hub that lives on a domain
            return getHubFromCarrier(activeDomain);
        }
        catch (_Oo) {
            // Return hub that lives on a global object
            return getHubFromCarrier(registry);
        }
    }
    /**
     * This will tell whether a carrier has a hub on it or not
     * @param carrier object
     */
    function hasHubOnCarrier(carrier) {
        return !!(carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub);
    }
    /**
     * This will create a new {@link Hub} and add to the passed object on
     * __SENTRY__.hub.
     * @param carrier object
     * @hidden
     */
    function getHubFromCarrier(carrier) {
        if (carrier && carrier.__SENTRY__ && carrier.__SENTRY__.hub)
            return carrier.__SENTRY__.hub;
        carrier.__SENTRY__ = carrier.__SENTRY__ || {};
        carrier.__SENTRY__.hub = new Hub();
        return carrier.__SENTRY__.hub;
    }
    /**
     * This will set passed {@link Hub} on the passed object's __SENTRY__.hub attribute
     * @param carrier object
     * @param hub Hub
     * @returns A boolean indicating success or failure
     */
    function setHubOnCarrier(carrier, hub) {
        if (!carrier)
            return false;
        carrier.__SENTRY__ = carrier.__SENTRY__ || {};
        carrier.__SENTRY__.hub = hub;
        return true;
    }

    /**
     * This calls a function on the current hub.
     * @param method function to call on hub.
     * @param args to pass to function.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function callOnHub(method) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var hub = getCurrentHub();
        if (hub && hub[method]) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return hub[method].apply(hub, __spread(args));
        }
        throw new Error("No hub defined or " + method + " was not found on the hub, please open a bug report.");
    }
    /**
     * Captures an exception event and sends it to Sentry.
     *
     * @param exception An exception-like object.
     * @returns The generated eventId.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    function captureException(exception, captureContext) {
        var syntheticException;
        try {
            throw new Error('Sentry syntheticException');
        }
        catch (exception) {
            syntheticException = exception;
        }
        return callOnHub('captureException', exception, {
            captureContext: captureContext,
            originalException: exception,
            syntheticException: syntheticException,
        });
    }
    /**
     * Creates a new scope with and executes the given operation within.
     * The scope is automatically removed once the operation
     * finishes or throws.
     *
     * This is essentially a convenience function for:
     *
     *     pushScope();
     *     callback();
     *     popScope();
     *
     * @param callback that will be enclosed into push/popScope.
     */
    function withScope(callback) {
        callOnHub('withScope', callback);
    }

    var SENTRY_API_VERSION = '7';
    /**
     * Helper class to provide urls, headers and metadata that can be used to form
     * different types of requests to Sentry endpoints.
     * Supports both envelopes and regular event requests.
     **/
    var API = /** @class */ (function () {
        /** Create a new instance of API */
        function API(dsn, metadata) {
            if (metadata === void 0) { metadata = {}; }
            this.dsn = dsn;
            this._dsnObject = new Dsn(dsn);
            this.metadata = metadata;
        }
        /** Returns the Dsn object. */
        API.prototype.getDsn = function () {
            return this._dsnObject;
        };
        /** Returns the prefix to construct Sentry ingestion API endpoints. */
        API.prototype.getBaseApiEndpoint = function () {
            var dsn = this._dsnObject;
            var protocol = dsn.protocol ? dsn.protocol + ":" : '';
            var port = dsn.port ? ":" + dsn.port : '';
            return protocol + "//" + dsn.host + port + (dsn.path ? "/" + dsn.path : '') + "/api/";
        };
        /** Returns the store endpoint URL. */
        API.prototype.getStoreEndpoint = function () {
            return this._getIngestEndpoint('store');
        };
        /**
         * Returns the store endpoint URL with auth in the query string.
         *
         * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
         */
        API.prototype.getStoreEndpointWithUrlEncodedAuth = function () {
            return this.getStoreEndpoint() + "?" + this._encodedAuth();
        };
        /**
         * Returns the envelope endpoint URL with auth in the query string.
         *
         * Sending auth as part of the query string and not as custom HTTP headers avoids CORS preflight requests.
         */
        API.prototype.getEnvelopeEndpointWithUrlEncodedAuth = function () {
            return this._getEnvelopeEndpoint() + "?" + this._encodedAuth();
        };
        /** Returns only the path component for the store endpoint. */
        API.prototype.getStoreEndpointPath = function () {
            var dsn = this._dsnObject;
            return (dsn.path ? "/" + dsn.path : '') + "/api/" + dsn.projectId + "/store/";
        };
        /**
         * Returns an object that can be used in request headers.
         * This is needed for node and the old /store endpoint in sentry
         */
        API.prototype.getRequestHeaders = function (clientName, clientVersion) {
            // CHANGE THIS to use metadata but keep clientName and clientVersion compatible
            var dsn = this._dsnObject;
            var header = ["Sentry sentry_version=" + SENTRY_API_VERSION];
            header.push("sentry_client=" + clientName + "/" + clientVersion);
            header.push("sentry_key=" + dsn.publicKey);
            if (dsn.pass) {
                header.push("sentry_secret=" + dsn.pass);
            }
            return {
                'Content-Type': 'application/json',
                'X-Sentry-Auth': header.join(', '),
            };
        };
        /** Returns the url to the report dialog endpoint. */
        API.prototype.getReportDialogEndpoint = function (dialogOptions) {
            if (dialogOptions === void 0) { dialogOptions = {}; }
            var dsn = this._dsnObject;
            var endpoint = this.getBaseApiEndpoint() + "embed/error-page/";
            var encodedOptions = [];
            encodedOptions.push("dsn=" + dsn.toString());
            for (var key in dialogOptions) {
                if (key === 'dsn') {
                    continue;
                }
                if (key === 'user') {
                    if (!dialogOptions.user) {
                        continue;
                    }
                    if (dialogOptions.user.name) {
                        encodedOptions.push("name=" + encodeURIComponent(dialogOptions.user.name));
                    }
                    if (dialogOptions.user.email) {
                        encodedOptions.push("email=" + encodeURIComponent(dialogOptions.user.email));
                    }
                }
                else {
                    encodedOptions.push(encodeURIComponent(key) + "=" + encodeURIComponent(dialogOptions[key]));
                }
            }
            if (encodedOptions.length) {
                return endpoint + "?" + encodedOptions.join('&');
            }
            return endpoint;
        };
        /** Returns the envelope endpoint URL. */
        API.prototype._getEnvelopeEndpoint = function () {
            return this._getIngestEndpoint('envelope');
        };
        /** Returns the ingest API endpoint for target. */
        API.prototype._getIngestEndpoint = function (target) {
            var base = this.getBaseApiEndpoint();
            var dsn = this._dsnObject;
            return "" + base + dsn.projectId + "/" + target + "/";
        };
        /** Returns a URL-encoded string with auth config suitable for a query string. */
        API.prototype._encodedAuth = function () {
            var dsn = this._dsnObject;
            var auth = {
                // We send only the minimum set of required information. See
                // https://github.com/getsentry/sentry-javascript/issues/2572.
                sentry_key: dsn.publicKey,
                sentry_version: SENTRY_API_VERSION,
            };
            return urlEncode(auth);
        };
        return API;
    }());

    var installedIntegrations = [];
    /** Gets integration to install */
    function getIntegrationsToSetup(options) {
        var defaultIntegrations = (options.defaultIntegrations && __spread(options.defaultIntegrations)) || [];
        var userIntegrations = options.integrations;
        var integrations = [];
        if (Array.isArray(userIntegrations)) {
            var userIntegrationsNames_1 = userIntegrations.map(function (i) { return i.name; });
            var pickedIntegrationsNames_1 = [];
            // Leave only unique default integrations, that were not overridden with provided user integrations
            defaultIntegrations.forEach(function (defaultIntegration) {
                if (userIntegrationsNames_1.indexOf(defaultIntegration.name) === -1 &&
                    pickedIntegrationsNames_1.indexOf(defaultIntegration.name) === -1) {
                    integrations.push(defaultIntegration);
                    pickedIntegrationsNames_1.push(defaultIntegration.name);
                }
            });
            // Don't add same user integration twice
            userIntegrations.forEach(function (userIntegration) {
                if (pickedIntegrationsNames_1.indexOf(userIntegration.name) === -1) {
                    integrations.push(userIntegration);
                    pickedIntegrationsNames_1.push(userIntegration.name);
                }
            });
        }
        else if (typeof userIntegrations === 'function') {
            integrations = userIntegrations(defaultIntegrations);
            integrations = Array.isArray(integrations) ? integrations : [integrations];
        }
        else {
            integrations = __spread(defaultIntegrations);
        }
        // Make sure that if present, `Debug` integration will always run last
        var integrationsNames = integrations.map(function (i) { return i.name; });
        var alwaysLastToRun = 'Debug';
        if (integrationsNames.indexOf(alwaysLastToRun) !== -1) {
            integrations.push.apply(integrations, __spread(integrations.splice(integrationsNames.indexOf(alwaysLastToRun), 1)));
        }
        return integrations;
    }
    /** Setup given integration */
    function setupIntegration(integration) {
        if (installedIntegrations.indexOf(integration.name) !== -1) {
            return;
        }
        integration.setupOnce(addGlobalEventProcessor, getCurrentHub);
        installedIntegrations.push(integration.name);
        logger.log("Integration installed: " + integration.name);
    }
    /**
     * Given a list of integration instances this installs them all. When `withDefaults` is set to `true` then all default
     * integrations are added unless they were already provided before.
     * @param integrations array of integration instances
     * @param withDefault should enable default integrations
     */
    function setupIntegrations(options) {
        var integrations = {};
        getIntegrationsToSetup(options).forEach(function (integration) {
            integrations[integration.name] = integration;
            setupIntegration(integration);
        });
        return integrations;
    }

    /**
     * Base implementation for all JavaScript SDK clients.
     *
     * Call the constructor with the corresponding backend constructor and options
     * specific to the client subclass. To access these options later, use
     * {@link Client.getOptions}. Also, the Backend instance is available via
     * {@link Client.getBackend}.
     *
     * If a Dsn is specified in the options, it will be parsed and stored. Use
     * {@link Client.getDsn} to retrieve the Dsn at any moment. In case the Dsn is
     * invalid, the constructor will throw a {@link SentryException}. Note that
     * without a valid Dsn, the SDK will not send any events to Sentry.
     *
     * Before sending an event via the backend, it is passed through
     * {@link BaseClient._prepareEvent} to add SDK information and scope data
     * (breadcrumbs and context). To add more custom information, override this
     * method and extend the resulting prepared event.
     *
     * To issue automatically created events (e.g. via instrumentation), use
     * {@link Client.captureEvent}. It will prepare the event and pass it through
     * the callback lifecycle. To issue auto-breadcrumbs, use
     * {@link Client.addBreadcrumb}.
     *
     * @example
     * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {
     *   public constructor(options: NodeOptions) {
     *     super(NodeBackend, options);
     *   }
     *
     *   // ...
     * }
     */
    var BaseClient = /** @class */ (function () {
        /**
         * Initializes this client instance.
         *
         * @param backendClass A constructor function to create the backend.
         * @param options Options for the client.
         */
        function BaseClient(backendClass, options) {
            /** Array of used integrations. */
            this._integrations = {};
            /** Number of call being processed */
            this._processing = 0;
            this._backend = new backendClass(options);
            this._options = options;
            if (options.dsn) {
                this._dsn = new Dsn(options.dsn);
            }
        }
        /**
         * @inheritDoc
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
        BaseClient.prototype.captureException = function (exception, hint, scope) {
            var _this = this;
            var eventId = hint && hint.event_id;
            this._process(this._getBackend()
                .eventFromException(exception, hint)
                .then(function (event) { return _this._captureEvent(event, hint, scope); })
                .then(function (result) {
                eventId = result;
            }));
            return eventId;
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.captureMessage = function (message, level, hint, scope) {
            var _this = this;
            var eventId = hint && hint.event_id;
            var promisedEvent = isPrimitive(message)
                ? this._getBackend().eventFromMessage(String(message), level, hint)
                : this._getBackend().eventFromException(message, hint);
            this._process(promisedEvent
                .then(function (event) { return _this._captureEvent(event, hint, scope); })
                .then(function (result) {
                eventId = result;
            }));
            return eventId;
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.captureEvent = function (event, hint, scope) {
            var eventId = hint && hint.event_id;
            this._process(this._captureEvent(event, hint, scope).then(function (result) {
                eventId = result;
            }));
            return eventId;
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.captureSession = function (session) {
            if (!session.release) {
                logger.warn('Discarded session because of missing release');
            }
            else {
                this._sendSession(session);
                // After sending, we set init false to inidcate it's not the first occurence
                session.update({ init: false });
            }
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.getDsn = function () {
            return this._dsn;
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.getOptions = function () {
            return this._options;
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.flush = function (timeout) {
            var _this = this;
            return this._isClientProcessing(timeout).then(function (ready) {
                return _this._getBackend()
                    .getTransport()
                    .close(timeout)
                    .then(function (transportFlushed) { return ready && transportFlushed; });
            });
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.close = function (timeout) {
            var _this = this;
            return this.flush(timeout).then(function (result) {
                _this.getOptions().enabled = false;
                return result;
            });
        };
        /**
         * Sets up the integrations
         */
        BaseClient.prototype.setupIntegrations = function () {
            if (this._isEnabled()) {
                this._integrations = setupIntegrations(this._options);
            }
        };
        /**
         * @inheritDoc
         */
        BaseClient.prototype.getIntegration = function (integration) {
            try {
                return this._integrations[integration.id] || null;
            }
            catch (_oO) {
                logger.warn("Cannot retrieve integration " + integration.id + " from the current Client");
                return null;
            }
        };
        /** Updates existing session based on the provided event */
        BaseClient.prototype._updateSessionFromEvent = function (session, event) {
            var e_1, _a;
            var crashed = false;
            var errored = false;
            var userAgent;
            var exceptions = event.exception && event.exception.values;
            if (exceptions) {
                errored = true;
                try {
                    for (var exceptions_1 = __values(exceptions), exceptions_1_1 = exceptions_1.next(); !exceptions_1_1.done; exceptions_1_1 = exceptions_1.next()) {
                        var ex = exceptions_1_1.value;
                        var mechanism = ex.mechanism;
                        if (mechanism && mechanism.handled === false) {
                            crashed = true;
                            break;
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (exceptions_1_1 && !exceptions_1_1.done && (_a = exceptions_1.return)) _a.call(exceptions_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            var user = event.user;
            if (!session.userAgent) {
                var headers = event.request ? event.request.headers : {};
                for (var key in headers) {
                    if (key.toLowerCase() === 'user-agent') {
                        userAgent = headers[key];
                        break;
                    }
                }
            }
            session.update(__assign(__assign({}, (crashed && { status: SessionStatus.Crashed })), { user: user,
                userAgent: userAgent, errors: session.errors + Number(errored || crashed) }));
            this.captureSession(session);
        };
        /** Deliver captured session to Sentry */
        BaseClient.prototype._sendSession = function (session) {
            this._getBackend().sendSession(session);
        };
        /** Waits for the client to be done with processing. */
        BaseClient.prototype._isClientProcessing = function (timeout) {
            var _this = this;
            return new SyncPromise(function (resolve) {
                var ticked = 0;
                var tick = 1;
                var interval = setInterval(function () {
                    if (_this._processing == 0) {
                        clearInterval(interval);
                        resolve(true);
                    }
                    else {
                        ticked += tick;
                        if (timeout && ticked >= timeout) {
                            clearInterval(interval);
                            resolve(false);
                        }
                    }
                }, tick);
            });
        };
        /** Returns the current backend. */
        BaseClient.prototype._getBackend = function () {
            return this._backend;
        };
        /** Determines whether this SDK is enabled and a valid Dsn is present. */
        BaseClient.prototype._isEnabled = function () {
            return this.getOptions().enabled !== false && this._dsn !== undefined;
        };
        /**
         * Adds common information to events.
         *
         * The information includes release and environment from `options`,
         * breadcrumbs and context (extra, tags and user) from the scope.
         *
         * Information that is already present in the event is never overwritten. For
         * nested objects, such as the context, keys are merged.
         *
         * @param event The original event.
         * @param hint May contain additional information about the original exception.
         * @param scope A scope containing event metadata.
         * @returns A new event with more information.
         */
        BaseClient.prototype._prepareEvent = function (event, scope, hint) {
            var _this = this;
            var _a = this.getOptions().normalizeDepth, normalizeDepth = _a === void 0 ? 3 : _a;
            var prepared = __assign(__assign({}, event), { event_id: event.event_id || (hint && hint.event_id ? hint.event_id : uuid4()), timestamp: event.timestamp || dateTimestampInSeconds() });
            this._applyClientOptions(prepared);
            this._applyIntegrationsMetadata(prepared);
            // If we have scope given to us, use it as the base for further modifications.
            // This allows us to prevent unnecessary copying of data if `captureContext` is not provided.
            var finalScope = scope;
            if (hint && hint.captureContext) {
                finalScope = Scope.clone(finalScope).update(hint.captureContext);
            }
            // We prepare the result here with a resolved Event.
            var result = SyncPromise.resolve(prepared);
            // This should be the last thing called, since we want that
            // {@link Hub.addEventProcessor} gets the finished prepared event.
            if (finalScope) {
                // In case we have a hub we reassign it.
                result = finalScope.applyToEvent(prepared, hint);
            }
            return result.then(function (evt) {
                if (typeof normalizeDepth === 'number' && normalizeDepth > 0) {
                    return _this._normalizeEvent(evt, normalizeDepth);
                }
                return evt;
            });
        };
        /**
         * Applies `normalize` function on necessary `Event` attributes to make them safe for serialization.
         * Normalized keys:
         * - `breadcrumbs.data`
         * - `user`
         * - `contexts`
         * - `extra`
         * @param event Event
         * @returns Normalized event
         */
        BaseClient.prototype._normalizeEvent = function (event, depth) {
            if (!event) {
                return null;
            }
            var normalized = __assign(__assign(__assign(__assign(__assign({}, event), (event.breadcrumbs && {
                breadcrumbs: event.breadcrumbs.map(function (b) { return (__assign(__assign({}, b), (b.data && {
                    data: normalize(b.data, depth),
                }))); }),
            })), (event.user && {
                user: normalize(event.user, depth),
            })), (event.contexts && {
                contexts: normalize(event.contexts, depth),
            })), (event.extra && {
                extra: normalize(event.extra, depth),
            }));
            // event.contexts.trace stores information about a Transaction. Similarly,
            // event.spans[] stores information about child Spans. Given that a
            // Transaction is conceptually a Span, normalization should apply to both
            // Transactions and Spans consistently.
            // For now the decision is to skip normalization of Transactions and Spans,
            // so this block overwrites the normalized event to add back the original
            // Transaction information prior to normalization.
            if (event.contexts && event.contexts.trace) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                normalized.contexts.trace = event.contexts.trace;
            }
            return normalized;
        };
        /**
         *  Enhances event using the client configuration.
         *  It takes care of all "static" values like environment, release and `dist`,
         *  as well as truncating overly long values.
         * @param event event instance to be enhanced
         */
        BaseClient.prototype._applyClientOptions = function (event) {
            var options = this.getOptions();
            var environment = options.environment, release = options.release, dist = options.dist, _a = options.maxValueLength, maxValueLength = _a === void 0 ? 250 : _a;
            if (!('environment' in event)) {
                event.environment = 'environment' in options ? environment : 'production';
            }
            if (event.release === undefined && release !== undefined) {
                event.release = release;
            }
            if (event.dist === undefined && dist !== undefined) {
                event.dist = dist;
            }
            if (event.message) {
                event.message = truncate(event.message, maxValueLength);
            }
            var exception = event.exception && event.exception.values && event.exception.values[0];
            if (exception && exception.value) {
                exception.value = truncate(exception.value, maxValueLength);
            }
            var request = event.request;
            if (request && request.url) {
                request.url = truncate(request.url, maxValueLength);
            }
        };
        /**
         * This function adds all used integrations to the SDK info in the event.
         * @param event The event that will be filled with all integrations.
         */
        BaseClient.prototype._applyIntegrationsMetadata = function (event) {
            var sdkInfo = event.sdk;
            var integrationsArray = Object.keys(this._integrations);
            if (sdkInfo && integrationsArray.length > 0) {
                sdkInfo.integrations = integrationsArray;
            }
        };
        /**
         * Tells the backend to send this event
         * @param event The Sentry event to send
         */
        BaseClient.prototype._sendEvent = function (event) {
            this._getBackend().sendEvent(event);
        };
        /**
         * Processes the event and logs an error in case of rejection
         * @param event
         * @param hint
         * @param scope
         */
        BaseClient.prototype._captureEvent = function (event, hint, scope) {
            return this._processEvent(event, hint, scope).then(function (finalEvent) {
                return finalEvent.event_id;
            }, function (reason) {
                logger.error(reason);
                return undefined;
            });
        };
        /**
         * Processes an event (either error or message) and sends it to Sentry.
         *
         * This also adds breadcrumbs and context information to the event. However,
         * platform specific meta data (such as the User's IP address) must be added
         * by the SDK implementor.
         *
         *
         * @param event The event to send to Sentry.
         * @param hint May contain additional information about the original exception.
         * @param scope A scope containing event metadata.
         * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
         */
        BaseClient.prototype._processEvent = function (event, hint, scope) {
            var _this = this;
            // eslint-disable-next-line @typescript-eslint/unbound-method
            var _a = this.getOptions(), beforeSend = _a.beforeSend, sampleRate = _a.sampleRate;
            if (!this._isEnabled()) {
                return SyncPromise.reject(new SentryError('SDK not enabled, will not send event.'));
            }
            var isTransaction = event.type === 'transaction';
            // 1.0 === 100% events are sent
            // 0.0 === 0% events are sent
            // Sampling for transaction happens somewhere else
            if (!isTransaction && typeof sampleRate === 'number' && Math.random() > sampleRate) {
                return SyncPromise.reject(new SentryError("Discarding event because it's not included in the random sample (sampling rate = " + sampleRate + ")"));
            }
            return this._prepareEvent(event, scope, hint)
                .then(function (prepared) {
                if (prepared === null) {
                    throw new SentryError('An event processor returned null, will not send event.');
                }
                var isInternalException = hint && hint.data && hint.data.__sentry__ === true;
                if (isInternalException || isTransaction || !beforeSend) {
                    return prepared;
                }
                var beforeSendResult = beforeSend(prepared, hint);
                if (typeof beforeSendResult === 'undefined') {
                    throw new SentryError('`beforeSend` method has to return `null` or a valid event.');
                }
                else if (isThenable(beforeSendResult)) {
                    return beforeSendResult.then(function (event) { return event; }, function (e) {
                        throw new SentryError("beforeSend rejected with " + e);
                    });
                }
                return beforeSendResult;
            })
                .then(function (processedEvent) {
                if (processedEvent === null) {
                    throw new SentryError('`beforeSend` returned `null`, will not send event.');
                }
                var session = scope && scope.getSession && scope.getSession();
                if (!isTransaction && session) {
                    _this._updateSessionFromEvent(session, processedEvent);
                }
                _this._sendEvent(processedEvent);
                return processedEvent;
            })
                .then(null, function (reason) {
                if (reason instanceof SentryError) {
                    throw reason;
                }
                _this.captureException(reason, {
                    data: {
                        __sentry__: true,
                    },
                    originalException: reason,
                });
                throw new SentryError("Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.\nReason: " + reason);
            });
        };
        /**
         * Occupies the client with processing and event
         */
        BaseClient.prototype._process = function (promise) {
            var _this = this;
            this._processing += 1;
            promise.then(function (value) {
                _this._processing -= 1;
                return value;
            }, function (reason) {
                _this._processing -= 1;
                return reason;
            });
        };
        return BaseClient;
    }());

    /** Noop transport */
    var NoopTransport = /** @class */ (function () {
        function NoopTransport() {
        }
        /**
         * @inheritDoc
         */
        NoopTransport.prototype.sendEvent = function (_) {
            return SyncPromise.resolve({
                reason: "NoopTransport: Event has been skipped because no Dsn is configured.",
                status: Status.Skipped,
            });
        };
        /**
         * @inheritDoc
         */
        NoopTransport.prototype.close = function (_) {
            return SyncPromise.resolve(true);
        };
        return NoopTransport;
    }());

    /**
     * This is the base implemention of a Backend.
     * @hidden
     */
    var BaseBackend = /** @class */ (function () {
        /** Creates a new backend instance. */
        function BaseBackend(options) {
            this._options = options;
            if (!this._options.dsn) {
                logger.warn('No DSN provided, backend will not do anything.');
            }
            this._transport = this._setupTransport();
        }
        /**
         * @inheritDoc
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
        BaseBackend.prototype.eventFromException = function (_exception, _hint) {
            throw new SentryError('Backend has to implement `eventFromException` method');
        };
        /**
         * @inheritDoc
         */
        BaseBackend.prototype.eventFromMessage = function (_message, _level, _hint) {
            throw new SentryError('Backend has to implement `eventFromMessage` method');
        };
        /**
         * @inheritDoc
         */
        BaseBackend.prototype.sendEvent = function (event) {
            this._transport.sendEvent(event).then(null, function (reason) {
                logger.error("Error while sending event: " + reason);
            });
        };
        /**
         * @inheritDoc
         */
        BaseBackend.prototype.sendSession = function (session) {
            if (!this._transport.sendSession) {
                logger.warn("Dropping session because custom transport doesn't implement sendSession");
                return;
            }
            this._transport.sendSession(session).then(null, function (reason) {
                logger.error("Error while sending session: " + reason);
            });
        };
        /**
         * @inheritDoc
         */
        BaseBackend.prototype.getTransport = function () {
            return this._transport;
        };
        /**
         * Sets up the transport so it can be used later to send requests.
         */
        BaseBackend.prototype._setupTransport = function () {
            return new NoopTransport();
        };
        return BaseBackend;
    }());

    /** Extract sdk info from from the API metadata */
    function getSdkMetadataForEnvelopeHeader(api) {
        if (!api.metadata || !api.metadata.sdk) {
            return;
        }
        var _a = api.metadata.sdk, name = _a.name, version = _a.version;
        return { name: name, version: version };
    }
    /**
     * Apply SdkInfo (name, version, packages, integrations) to the corresponding event key.
     * Merge with existing data if any.
     **/
    function enhanceEventWithSdkInfo(event, sdkInfo) {
        if (!sdkInfo) {
            return event;
        }
        event.sdk = event.sdk || {
            name: sdkInfo.name,
            version: sdkInfo.version,
        };
        event.sdk.name = event.sdk.name || sdkInfo.name;
        event.sdk.version = event.sdk.version || sdkInfo.version;
        event.sdk.integrations = __spread((event.sdk.integrations || []), (sdkInfo.integrations || []));
        event.sdk.packages = __spread((event.sdk.packages || []), (sdkInfo.packages || []));
        return event;
    }
    /** Creates a SentryRequest from an event. */
    function sessionToSentryRequest(session, api) {
        var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
        var envelopeHeaders = JSON.stringify(__assign({ sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })));
        var itemHeaders = JSON.stringify({
            type: 'session',
        });
        return {
            body: envelopeHeaders + "\n" + itemHeaders + "\n" + JSON.stringify(session),
            type: 'session',
            url: api.getEnvelopeEndpointWithUrlEncodedAuth(),
        };
    }
    /** Creates a SentryRequest from an event. */
    function eventToSentryRequest(event, api) {
        var sdkInfo = getSdkMetadataForEnvelopeHeader(api);
        var eventType = event.type || 'event';
        var useEnvelope = eventType === 'transaction';
        var _a = event.debug_meta || {}, transactionSampling = _a.transactionSampling, metadata = __rest(_a, ["transactionSampling"]);
        var _b = transactionSampling || {}, samplingMethod = _b.method, sampleRate = _b.rate;
        if (Object.keys(metadata).length === 0) {
            delete event.debug_meta;
        }
        else {
            event.debug_meta = metadata;
        }
        var req = {
            body: JSON.stringify(sdkInfo ? enhanceEventWithSdkInfo(event, api.metadata.sdk) : event),
            type: eventType,
            url: useEnvelope ? api.getEnvelopeEndpointWithUrlEncodedAuth() : api.getStoreEndpointWithUrlEncodedAuth(),
        };
        // https://develop.sentry.dev/sdk/envelopes/
        // Since we don't need to manipulate envelopes nor store them, there is no
        // exported concept of an Envelope with operations including serialization and
        // deserialization. Instead, we only implement a minimal subset of the spec to
        // serialize events inline here.
        if (useEnvelope) {
            var envelopeHeaders = JSON.stringify(__assign({ event_id: event.event_id, sent_at: new Date().toISOString() }, (sdkInfo && { sdk: sdkInfo })));
            var itemHeaders = JSON.stringify({
                type: event.type,
                // TODO: Right now, sampleRate may or may not be defined (it won't be in the cases of inheritance and
                // explicitly-set sampling decisions). Are we good with that?
                sample_rates: [{ id: samplingMethod, rate: sampleRate }],
            });
            // The trailing newline is optional. We intentionally don't send it to avoid
            // sending unnecessary bytes.
            //
            // const envelope = `${envelopeHeaders}\n${itemHeaders}\n${req.body}\n`;
            var envelope = envelopeHeaders + "\n" + itemHeaders + "\n" + req.body;
            req.body = envelope;
        }
        return req;
    }

    /**
     * Internal function to create a new SDK client instance. The client is
     * installed and then bound to the current scope.
     *
     * @param clientClass The client class to instantiate.
     * @param options Options to pass to the client.
     */
    function initAndBind(clientClass, options) {
        if (options.debug === true) {
            logger.enable();
        }
        var hub = getCurrentHub();
        var client = new clientClass(options);
        hub.bindClient(client);
    }

    var SDK_VERSION = '6.2.0';

    var originalFunctionToString;
    /** Patch toString calls to return proper name for wrapped functions */
    var FunctionToString = /** @class */ (function () {
        function FunctionToString() {
            /**
             * @inheritDoc
             */
            this.name = FunctionToString.id;
        }
        /**
         * @inheritDoc
         */
        FunctionToString.prototype.setupOnce = function () {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            originalFunctionToString = Function.prototype.toString;
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            Function.prototype.toString = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var context = this.__sentry_original__ || this;
                return originalFunctionToString.apply(context, args);
            };
        };
        /**
         * @inheritDoc
         */
        FunctionToString.id = 'FunctionToString';
        return FunctionToString;
    }());

    // "Script error." is hard coded into browsers for errors that it can't read.
    // this is the result of a script being pulled in from an external domain and CORS.
    var DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/];
    /** Inbound filters configurable by the user */
    var InboundFilters = /** @class */ (function () {
        function InboundFilters(_options) {
            if (_options === void 0) { _options = {}; }
            this._options = _options;
            /**
             * @inheritDoc
             */
            this.name = InboundFilters.id;
        }
        /**
         * @inheritDoc
         */
        InboundFilters.prototype.setupOnce = function () {
            addGlobalEventProcessor(function (event) {
                var hub = getCurrentHub();
                if (!hub) {
                    return event;
                }
                var self = hub.getIntegration(InboundFilters);
                if (self) {
                    var client = hub.getClient();
                    var clientOptions = client ? client.getOptions() : {};
                    var options = self._mergeOptions(clientOptions);
                    if (self._shouldDropEvent(event, options)) {
                        return null;
                    }
                }
                return event;
            });
        };
        /** JSDoc */
        InboundFilters.prototype._shouldDropEvent = function (event, options) {
            if (this._isSentryError(event, options)) {
                logger.warn("Event dropped due to being internal Sentry Error.\nEvent: " + getEventDescription(event));
                return true;
            }
            if (this._isIgnoredError(event, options)) {
                logger.warn("Event dropped due to being matched by `ignoreErrors` option.\nEvent: " + getEventDescription(event));
                return true;
            }
            if (this._isDeniedUrl(event, options)) {
                logger.warn("Event dropped due to being matched by `denyUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
                return true;
            }
            if (!this._isAllowedUrl(event, options)) {
                logger.warn("Event dropped due to not being matched by `allowUrls` option.\nEvent: " + getEventDescription(event) + ".\nUrl: " + this._getEventFilterUrl(event));
                return true;
            }
            return false;
        };
        /** JSDoc */
        InboundFilters.prototype._isSentryError = function (event, options) {
            if (!options.ignoreInternal) {
                return false;
            }
            try {
                return ((event &&
                    event.exception &&
                    event.exception.values &&
                    event.exception.values[0] &&
                    event.exception.values[0].type === 'SentryError') ||
                    false);
            }
            catch (_oO) {
                return false;
            }
        };
        /** JSDoc */
        InboundFilters.prototype._isIgnoredError = function (event, options) {
            if (!options.ignoreErrors || !options.ignoreErrors.length) {
                return false;
            }
            return this._getPossibleEventMessages(event).some(function (message) {
                // Not sure why TypeScript complains here...
                return options.ignoreErrors.some(function (pattern) { return isMatchingPattern(message, pattern); });
            });
        };
        /** JSDoc */
        InboundFilters.prototype._isDeniedUrl = function (event, options) {
            // TODO: Use Glob instead?
            if (!options.denyUrls || !options.denyUrls.length) {
                return false;
            }
            var url = this._getEventFilterUrl(event);
            return !url ? false : options.denyUrls.some(function (pattern) { return isMatchingPattern(url, pattern); });
        };
        /** JSDoc */
        InboundFilters.prototype._isAllowedUrl = function (event, options) {
            // TODO: Use Glob instead?
            if (!options.allowUrls || !options.allowUrls.length) {
                return true;
            }
            var url = this._getEventFilterUrl(event);
            return !url ? true : options.allowUrls.some(function (pattern) { return isMatchingPattern(url, pattern); });
        };
        /** JSDoc */
        InboundFilters.prototype._mergeOptions = function (clientOptions) {
            if (clientOptions === void 0) { clientOptions = {}; }
            return {
                allowUrls: __spread((this._options.whitelistUrls || []), (this._options.allowUrls || []), (clientOptions.whitelistUrls || []), (clientOptions.allowUrls || [])),
                denyUrls: __spread((this._options.blacklistUrls || []), (this._options.denyUrls || []), (clientOptions.blacklistUrls || []), (clientOptions.denyUrls || [])),
                ignoreErrors: __spread((this._options.ignoreErrors || []), (clientOptions.ignoreErrors || []), DEFAULT_IGNORE_ERRORS),
                ignoreInternal: typeof this._options.ignoreInternal !== 'undefined' ? this._options.ignoreInternal : true,
            };
        };
        /** JSDoc */
        InboundFilters.prototype._getPossibleEventMessages = function (event) {
            if (event.message) {
                return [event.message];
            }
            if (event.exception) {
                try {
                    var _a = (event.exception.values && event.exception.values[0]) || {}, _b = _a.type, type = _b === void 0 ? '' : _b, _c = _a.value, value = _c === void 0 ? '' : _c;
                    return ["" + value, type + ": " + value];
                }
                catch (oO) {
                    logger.error("Cannot extract message for event " + getEventDescription(event));
                    return [];
                }
            }
            return [];
        };
        /** JSDoc */
        InboundFilters.prototype._getEventFilterUrl = function (event) {
            try {
                if (event.stacktrace) {
                    var frames_1 = event.stacktrace.frames;
                    return (frames_1 && frames_1[frames_1.length - 1].filename) || null;
                }
                if (event.exception) {
                    var frames_2 = event.exception.values && event.exception.values[0].stacktrace && event.exception.values[0].stacktrace.frames;
                    return (frames_2 && frames_2[frames_2.length - 1].filename) || null;
                }
                return null;
            }
            catch (oO) {
                logger.error("Cannot extract url for event " + getEventDescription(event));
                return null;
            }
        };
        /**
         * @inheritDoc
         */
        InboundFilters.id = 'InboundFilters';
        return InboundFilters;
    }());

    /**
     * This was originally forked from https://github.com/occ/TraceKit, but has since been
     * largely modified and is now maintained as part of Sentry JS SDK.
     */
    // global reference to slice
    var UNKNOWN_FUNCTION = '?';
    // Chromium based browsers: Chrome, Brave, new Opera, new Edge
    var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|address|native|eval|webpack|<anonymous>|[-a-z]+:|.*bundle|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    // gecko regex: `(?:bundle|\d+\.js)`: `bundle` is for react native, `\d+\.js` also but specifically for ram bundles because it
    // generates filenames without a prefix like `file://` the filenames in the stacktrace are just 42.js
    // We need this specific case for now because we want no other regex to match.
    var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:file|https?|blob|chrome|webpack|resource|moz-extension|capacitor).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i;
    var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    // Based on our own mapping pattern - https://github.com/getsentry/sentry/blob/9f08305e09866c8bd6d0c24f5b0aabdd7dd6c59c/src/sentry/lang/javascript/errormapping.py#L83-L108
    var reactMinifiedRegexp = /Minified React error #\d+;/i;
    /** JSDoc */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
    function computeStackTrace(ex) {
        var stack = null;
        var popSize = 0;
        if (ex) {
            if (typeof ex.framesToPop === 'number') {
                popSize = ex.framesToPop;
            }
            else if (reactMinifiedRegexp.test(ex.message)) {
                popSize = 1;
            }
        }
        try {
            // This must be tried first because Opera 10 *destroys*
            // its stacktrace property if you try to access the stack
            // property first!!
            stack = computeStackTraceFromStacktraceProp(ex);
            if (stack) {
                return popFrames(stack, popSize);
            }
        }
        catch (e) {
            // no-empty
        }
        try {
            stack = computeStackTraceFromStackProp(ex);
            if (stack) {
                return popFrames(stack, popSize);
            }
        }
        catch (e) {
            // no-empty
        }
        return {
            message: extractMessage(ex),
            name: ex && ex.name,
            stack: [],
            failed: true,
        };
    }
    /** JSDoc */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any, complexity
    function computeStackTraceFromStackProp(ex) {
        if (!ex || !ex.stack) {
            return null;
        }
        var stack = [];
        var lines = ex.stack.split('\n');
        var isEval;
        var submatch;
        var parts;
        var element;
        for (var i = 0; i < lines.length; ++i) {
            if ((parts = chrome.exec(lines[i]))) {
                var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
                isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
                if (isEval && (submatch = chromeEval.exec(parts[2]))) {
                    // throw out eval line/column and use top-most line/column number
                    parts[2] = submatch[1]; // url
                    parts[3] = submatch[2]; // line
                    parts[4] = submatch[3]; // column
                }
                element = {
                    // working with the regexp above is super painful. it is quite a hack, but just stripping the `address at `
                    // prefix here seems like the quickest solution for now.
                    url: parts[2] && parts[2].indexOf('address at ') === 0 ? parts[2].substr('address at '.length) : parts[2],
                    func: parts[1] || UNKNOWN_FUNCTION,
                    args: isNative ? [parts[2]] : [],
                    line: parts[3] ? +parts[3] : null,
                    column: parts[4] ? +parts[4] : null,
                };
            }
            else if ((parts = winjs.exec(lines[i]))) {
                element = {
                    url: parts[2],
                    func: parts[1] || UNKNOWN_FUNCTION,
                    args: [],
                    line: +parts[3],
                    column: parts[4] ? +parts[4] : null,
                };
            }
            else if ((parts = gecko.exec(lines[i]))) {
                isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
                if (isEval && (submatch = geckoEval.exec(parts[3]))) {
                    // throw out eval line/column and use top-most line number
                    parts[1] = parts[1] || "eval";
                    parts[3] = submatch[1];
                    parts[4] = submatch[2];
                    parts[5] = ''; // no column when eval
                }
                else if (i === 0 && !parts[5] && ex.columnNumber !== void 0) {
                    // FireFox uses this awesome columnNumber property for its top frame
                    // Also note, Firefox's column number is 0-based and everything else expects 1-based,
                    // so adding 1
                    // NOTE: this hack doesn't work if top-most frame is eval
                    stack[0].column = ex.columnNumber + 1;
                }
                element = {
                    url: parts[3],
                    func: parts[1] || UNKNOWN_FUNCTION,
                    args: parts[2] ? parts[2].split(',') : [],
                    line: parts[4] ? +parts[4] : null,
                    column: parts[5] ? +parts[5] : null,
                };
            }
            else {
                continue;
            }
            if (!element.func && element.line) {
                element.func = UNKNOWN_FUNCTION;
            }
            stack.push(element);
        }
        if (!stack.length) {
            return null;
        }
        return {
            message: extractMessage(ex),
            name: ex.name,
            stack: stack,
        };
    }
    /** JSDoc */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function computeStackTraceFromStacktraceProp(ex) {
        if (!ex || !ex.stacktrace) {
            return null;
        }
        // Access and store the stacktrace property before doing ANYTHING
        // else to it because Opera is not very good at providing it
        // reliably in other circumstances.
        var stacktrace = ex.stacktrace;
        var opera10Regex = / line (\d+).*script (?:in )?(\S+)(?:: in function (\S+))?$/i;
        var opera11Regex = / line (\d+), column (\d+)\s*(?:in (?:<anonymous function: ([^>]+)>|([^)]+))\((.*)\))? in (.*):\s*$/i;
        var lines = stacktrace.split('\n');
        var stack = [];
        var parts;
        for (var line = 0; line < lines.length; line += 2) {
            var element = null;
            if ((parts = opera10Regex.exec(lines[line]))) {
                element = {
                    url: parts[2],
                    func: parts[3],
                    args: [],
                    line: +parts[1],
                    column: null,
                };
            }
            else if ((parts = opera11Regex.exec(lines[line]))) {
                element = {
                    url: parts[6],
                    func: parts[3] || parts[4],
                    args: parts[5] ? parts[5].split(',') : [],
                    line: +parts[1],
                    column: +parts[2],
                };
            }
            if (element) {
                if (!element.func && element.line) {
                    element.func = UNKNOWN_FUNCTION;
                }
                stack.push(element);
            }
        }
        if (!stack.length) {
            return null;
        }
        return {
            message: extractMessage(ex),
            name: ex.name,
            stack: stack,
        };
    }
    /** Remove N number of frames from the stack */
    function popFrames(stacktrace, popSize) {
        try {
            return __assign(__assign({}, stacktrace), { stack: stacktrace.stack.slice(popSize) });
        }
        catch (e) {
            return stacktrace;
        }
    }
    /**
     * There are cases where stacktrace.message is an Event object
     * https://github.com/getsentry/sentry-javascript/issues/1949
     * In this specific case we try to extract stacktrace.message.error.message
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    function extractMessage(ex) {
        var message = ex && ex.message;
        if (!message) {
            return 'No error message';
        }
        if (message.error && typeof message.error.message === 'string') {
            return message.error.message;
        }
        return message;
    }

    var STACKTRACE_LIMIT = 50;
    /**
     * This function creates an exception from an TraceKitStackTrace
     * @param stacktrace TraceKitStackTrace that will be converted to an exception
     * @hidden
     */
    function exceptionFromStacktrace(stacktrace) {
        var frames = prepareFramesForEvent(stacktrace.stack);
        var exception = {
            type: stacktrace.name,
            value: stacktrace.message,
        };
        if (frames && frames.length) {
            exception.stacktrace = { frames: frames };
        }
        if (exception.type === undefined && exception.value === '') {
            exception.value = 'Unrecoverable error caught';
        }
        return exception;
    }
    /**
     * @hidden
     */
    function eventFromPlainObject(exception, syntheticException, rejection) {
        var event = {
            exception: {
                values: [
                    {
                        type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',
                        value: "Non-Error " + (rejection ? 'promise rejection' : 'exception') + " captured with keys: " + extractExceptionKeysForMessage(exception),
                    },
                ],
            },
            extra: {
                __serialized__: normalizeToSize(exception),
            },
        };
        if (syntheticException) {
            var stacktrace = computeStackTrace(syntheticException);
            var frames_1 = prepareFramesForEvent(stacktrace.stack);
            event.stacktrace = {
                frames: frames_1,
            };
        }
        return event;
    }
    /**
     * @hidden
     */
    function eventFromStacktrace(stacktrace) {
        var exception = exceptionFromStacktrace(stacktrace);
        return {
            exception: {
                values: [exception],
            },
        };
    }
    /**
     * @hidden
     */
    function prepareFramesForEvent(stack) {
        if (!stack || !stack.length) {
            return [];
        }
        var localStack = stack;
        var firstFrameFunction = localStack[0].func || '';
        var lastFrameFunction = localStack[localStack.length - 1].func || '';
        // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)
        if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {
            localStack = localStack.slice(1);
        }
        // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)
        if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {
            localStack = localStack.slice(0, -1);
        }
        // The frame where the crash happened, should be the last entry in the array
        return localStack
            .slice(0, STACKTRACE_LIMIT)
            .map(function (frame) { return ({
            colno: frame.column === null ? undefined : frame.column,
            filename: frame.url || localStack[0].url,
            function: frame.func || '?',
            in_app: true,
            lineno: frame.line === null ? undefined : frame.line,
        }); })
            .reverse();
    }

    /**
     * Builds and Event from a Exception
     * @hidden
     */
    function eventFromException(options, exception, hint) {
        var syntheticException = (hint && hint.syntheticException) || undefined;
        var event = eventFromUnknownInput(exception, syntheticException, {
            attachStacktrace: options.attachStacktrace,
        });
        addExceptionMechanism(event, {
            handled: true,
            type: 'generic',
        });
        event.level = Severity.Error;
        if (hint && hint.event_id) {
            event.event_id = hint.event_id;
        }
        return SyncPromise.resolve(event);
    }
    /**
     * Builds and Event from a Message
     * @hidden
     */
    function eventFromMessage(options, message, level, hint) {
        if (level === void 0) { level = Severity.Info; }
        var syntheticException = (hint && hint.syntheticException) || undefined;
        var event = eventFromString(message, syntheticException, {
            attachStacktrace: options.attachStacktrace,
        });
        event.level = level;
        if (hint && hint.event_id) {
            event.event_id = hint.event_id;
        }
        return SyncPromise.resolve(event);
    }
    /**
     * @hidden
     */
    function eventFromUnknownInput(exception, syntheticException, options) {
        if (options === void 0) { options = {}; }
        var event;
        if (isErrorEvent(exception) && exception.error) {
            // If it is an ErrorEvent with `error` property, extract it to get actual Error
            var errorEvent = exception;
            // eslint-disable-next-line no-param-reassign
            exception = errorEvent.error;
            event = eventFromStacktrace(computeStackTrace(exception));
            return event;
        }
        if (isDOMError(exception) || isDOMException(exception)) {
            // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)
            // then we just extract the name, code, and message, as they don't provide anything else
            // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
            // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
            var domException = exception;
            var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');
            var message = domException.message ? name_1 + ": " + domException.message : name_1;
            event = eventFromString(message, syntheticException, options);
            addExceptionTypeValue(event, message);
            if ('code' in domException) {
                event.tags = __assign(__assign({}, event.tags), { 'DOMException.code': "" + domException.code });
            }
            return event;
        }
        if (isError(exception)) {
            // we have a real Error object, do nothing
            event = eventFromStacktrace(computeStackTrace(exception));
            return event;
        }
        if (isPlainObject(exception) || isEvent(exception)) {
            // If it is plain Object or Event, serialize it manually and extract options
            // This will allow us to group events based on top-level keys
            // which is much better than creating new group when any key/value change
            var objectException = exception;
            event = eventFromPlainObject(objectException, syntheticException, options.rejection);
            addExceptionMechanism(event, {
                synthetic: true,
            });
            return event;
        }
        // If none of previous checks were valid, then it means that it's not:
        // - an instance of DOMError
        // - an instance of DOMException
        // - an instance of Event
        // - an instance of Error
        // - a valid ErrorEvent (one with an error property)
        // - a plain Object
        //
        // So bail out and capture it as a simple message:
        event = eventFromString(exception, syntheticException, options);
        addExceptionTypeValue(event, "" + exception, undefined);
        addExceptionMechanism(event, {
            synthetic: true,
        });
        return event;
    }
    /**
     * @hidden
     */
    function eventFromString(input, syntheticException, options) {
        if (options === void 0) { options = {}; }
        var event = {
            message: input,
        };
        if (options.attachStacktrace && syntheticException) {
            var stacktrace = computeStackTrace(syntheticException);
            var frames_1 = prepareFramesForEvent(stacktrace.stack);
            event.stacktrace = {
                frames: frames_1,
            };
        }
        return event;
    }

    /** Base Transport class implementation */
    var BaseTransport = /** @class */ (function () {
        function BaseTransport(options) {
            this.options = options;
            /** A simple buffer holding all requests. */
            this._buffer = new PromiseBuffer(30);
            /** Locks transport after receiving rate limits in a response */
            this._rateLimits = {};
            this._api = new API(options.dsn, options._metadata);
            // eslint-disable-next-line deprecation/deprecation
            this.url = this._api.getStoreEndpointWithUrlEncodedAuth();
        }
        /**
         * @inheritDoc
         */
        BaseTransport.prototype.sendEvent = function (_) {
            throw new SentryError('Transport Class has to implement `sendEvent` method');
        };
        /**
         * @inheritDoc
         */
        BaseTransport.prototype.close = function (timeout) {
            return this._buffer.drain(timeout);
        };
        /**
         * Handle Sentry repsonse for promise-based transports.
         */
        BaseTransport.prototype._handleResponse = function (_a) {
            var requestType = _a.requestType, response = _a.response, headers = _a.headers, resolve = _a.resolve, reject = _a.reject;
            var status = Status.fromHttpCode(response.status);
            /**
             * "The name is case-insensitive."
             * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get
             */
            var limited = this._handleRateLimit(headers);
            if (limited)
                logger.warn("Too many requests, backing off until: " + this._disabledUntil(requestType));
            if (status === Status.Success) {
                resolve({ status: status });
                return;
            }
            reject(response);
        };
        /**
         * Gets the time that given category is disabled until for rate limiting
         */
        BaseTransport.prototype._disabledUntil = function (category) {
            return this._rateLimits[category] || this._rateLimits.all;
        };
        /**
         * Checks if a category is rate limited
         */
        BaseTransport.prototype._isRateLimited = function (category) {
            return this._disabledUntil(category) > new Date(Date.now());
        };
        /**
         * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.
         */
        BaseTransport.prototype._handleRateLimit = function (headers) {
            var e_1, _a, e_2, _b;
            var now = Date.now();
            var rlHeader = headers['x-sentry-rate-limits'];
            var raHeader = headers['retry-after'];
            if (rlHeader) {
                try {
                    // rate limit headers are of the form
                    //     <header>,<header>,..
                    // where each <header> is of the form
                    //     <retry_after>: <categories>: <scope>: <reason_code>
                    // where
                    //     <retry_after> is a delay in ms
                    //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form
                    //         <category>;<category>;...
                    //     <scope> is what's being limited (org, project, or key) - ignored by SDK
                    //     <reason_code> is an arbitrary string like "org_quota" - ignored by SDK
                    for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {
                        var limit = _d.value;
                        var parameters = limit.split(':', 2);
                        var headerDelay = parseInt(parameters[0], 10);
                        var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default
                        try {
                            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var category = _f.value;
                                this._rateLimits[category || 'all'] = new Date(now + delay);
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return true;
            }
            else if (raHeader) {
                this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));
                return true;
            }
            return false;
        };
        return BaseTransport;
    }());

    var global$3 = getGlobalObject();
    /** `fetch` based transport */
    var FetchTransport = /** @class */ (function (_super) {
        __extends(FetchTransport, _super);
        function FetchTransport() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @inheritDoc
         */
        FetchTransport.prototype.sendEvent = function (event) {
            return this._sendRequest(eventToSentryRequest(event, this._api), event);
        };
        /**
         * @inheritDoc
         */
        FetchTransport.prototype.sendSession = function (session) {
            return this._sendRequest(sessionToSentryRequest(session, this._api), session);
        };
        /**
         * @param sentryRequest Prepared SentryRequest to be delivered
         * @param originalPayload Original payload used to create SentryRequest
         */
        FetchTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {
            var _this = this;
            if (this._isRateLimited(sentryRequest.type)) {
                return Promise.reject({
                    event: originalPayload,
                    type: sentryRequest.type,
                    reason: "Transport locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
                    status: 429,
                });
            }
            var options = {
                body: sentryRequest.body,
                method: 'POST',
                // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
                // https://caniuse.com/#feat=referrer-policy
                // It doesn't. And it throw exception instead of ignoring this parameter...
                // REF: https://github.com/getsentry/raven-js/issues/1233
                referrerPolicy: (supportsReferrerPolicy() ? 'origin' : ''),
            };
            if (this.options.fetchParameters !== undefined) {
                Object.assign(options, this.options.fetchParameters);
            }
            if (this.options.headers !== undefined) {
                options.headers = this.options.headers;
            }
            return this._buffer.add(new SyncPromise(function (resolve, reject) {
                global$3
                    .fetch(sentryRequest.url, options)
                    .then(function (response) {
                    var headers = {
                        'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),
                        'retry-after': response.headers.get('Retry-After'),
                    };
                    _this._handleResponse({
                        requestType: sentryRequest.type,
                        response: response,
                        headers: headers,
                        resolve: resolve,
                        reject: reject,
                    });
                })
                    .catch(reject);
            }));
        };
        return FetchTransport;
    }(BaseTransport));

    /** `XHR` based transport */
    var XHRTransport = /** @class */ (function (_super) {
        __extends(XHRTransport, _super);
        function XHRTransport() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @inheritDoc
         */
        XHRTransport.prototype.sendEvent = function (event) {
            return this._sendRequest(eventToSentryRequest(event, this._api), event);
        };
        /**
         * @inheritDoc
         */
        XHRTransport.prototype.sendSession = function (session) {
            return this._sendRequest(sessionToSentryRequest(session, this._api), session);
        };
        /**
         * @param sentryRequest Prepared SentryRequest to be delivered
         * @param originalPayload Original payload used to create SentryRequest
         */
        XHRTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {
            var _this = this;
            if (this._isRateLimited(sentryRequest.type)) {
                return Promise.reject({
                    event: originalPayload,
                    type: sentryRequest.type,
                    reason: "Transport locked till " + this._disabledUntil(sentryRequest.type) + " due to too many requests.",
                    status: 429,
                });
            }
            return this._buffer.add(new SyncPromise(function (resolve, reject) {
                var request = new XMLHttpRequest();
                request.onreadystatechange = function () {
                    if (request.readyState === 4) {
                        var headers = {
                            'x-sentry-rate-limits': request.getResponseHeader('X-Sentry-Rate-Limits'),
                            'retry-after': request.getResponseHeader('Retry-After'),
                        };
                        _this._handleResponse({ requestType: sentryRequest.type, response: request, headers: headers, resolve: resolve, reject: reject });
                    }
                };
                request.open('POST', sentryRequest.url);
                for (var header in _this.options.headers) {
                    if (_this.options.headers.hasOwnProperty(header)) {
                        request.setRequestHeader(header, _this.options.headers[header]);
                    }
                }
                request.send(sentryRequest.body);
            }));
        };
        return XHRTransport;
    }(BaseTransport));

    /**
     * The Sentry Browser SDK Backend.
     * @hidden
     */
    var BrowserBackend = /** @class */ (function (_super) {
        __extends(BrowserBackend, _super);
        function BrowserBackend() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @inheritDoc
         */
        BrowserBackend.prototype.eventFromException = function (exception, hint) {
            return eventFromException(this._options, exception, hint);
        };
        /**
         * @inheritDoc
         */
        BrowserBackend.prototype.eventFromMessage = function (message, level, hint) {
            if (level === void 0) { level = Severity.Info; }
            return eventFromMessage(this._options, message, level, hint);
        };
        /**
         * @inheritDoc
         */
        BrowserBackend.prototype._setupTransport = function () {
            if (!this._options.dsn) {
                // We return the noop transport here in case there is no Dsn.
                return _super.prototype._setupTransport.call(this);
            }
            var transportOptions = __assign(__assign({}, this._options.transportOptions), { dsn: this._options.dsn, _metadata: this._options._metadata });
            if (this._options.transport) {
                return new this._options.transport(transportOptions);
            }
            if (supportsFetch()) {
                return new FetchTransport(transportOptions);
            }
            return new XHRTransport(transportOptions);
        };
        return BrowserBackend;
    }(BaseBackend));

    var ignoreOnError = 0;
    /**
     * @hidden
     */
    function shouldIgnoreOnError() {
        return ignoreOnError > 0;
    }
    /**
     * @hidden
     */
    function ignoreNextOnError() {
        // onerror should trigger before setTimeout
        ignoreOnError += 1;
        setTimeout(function () {
            ignoreOnError -= 1;
        });
    }
    /**
     * Instruments the given function and sends an event to Sentry every time the
     * function throws an exception.
     *
     * @param fn A function to wrap.
     * @returns The wrapped function.
     * @hidden
     */
    function wrap(fn, options, before) {
        if (options === void 0) { options = {}; }
        if (typeof fn !== 'function') {
            return fn;
        }
        try {
            // We don't wanna wrap it twice
            if (fn.__sentry__) {
                return fn;
            }
            // If this has already been wrapped in the past, return that wrapped function
            if (fn.__sentry_wrapped__) {
                return fn.__sentry_wrapped__;
            }
        }
        catch (e) {
            // Just accessing custom props in some Selenium environments
            // can cause a "Permission denied" exception (see raven-js#495).
            // Bail on wrapping and return the function as-is (defers to window.onerror).
            return fn;
        }
        /* eslint-disable prefer-rest-params */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        var sentryWrapped = function () {
            var args = Array.prototype.slice.call(arguments);
            try {
                if (before && typeof before === 'function') {
                    before.apply(this, arguments);
                }
                // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
                var wrappedArguments = args.map(function (arg) { return wrap(arg, options); });
                if (fn.handleEvent) {
                    // Attempt to invoke user-land function
                    // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
                    //       means the sentry.javascript SDK caught an error invoking your application code. This
                    //       is expected behavior and NOT indicative of a bug with sentry.javascript.
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    return fn.handleEvent.apply(this, wrappedArguments);
                }
                // Attempt to invoke user-land function
                // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
                //       means the sentry.javascript SDK caught an error invoking your application code. This
                //       is expected behavior and NOT indicative of a bug with sentry.javascript.
                return fn.apply(this, wrappedArguments);
            }
            catch (ex) {
                ignoreNextOnError();
                withScope(function (scope) {
                    scope.addEventProcessor(function (event) {
                        var processedEvent = __assign({}, event);
                        if (options.mechanism) {
                            addExceptionTypeValue(processedEvent, undefined, undefined);
                            addExceptionMechanism(processedEvent, options.mechanism);
                        }
                        processedEvent.extra = __assign(__assign({}, processedEvent.extra), { arguments: args });
                        return processedEvent;
                    });
                    captureException(ex);
                });
                throw ex;
            }
        };
        /* eslint-enable prefer-rest-params */
        // Accessing some objects may throw
        // ref: https://github.com/getsentry/sentry-javascript/issues/1168
        try {
            for (var property in fn) {
                if (Object.prototype.hasOwnProperty.call(fn, property)) {
                    sentryWrapped[property] = fn[property];
                }
            }
        }
        catch (_oO) { } // eslint-disable-line no-empty
        fn.prototype = fn.prototype || {};
        sentryWrapped.prototype = fn.prototype;
        Object.defineProperty(fn, '__sentry_wrapped__', {
            enumerable: false,
            value: sentryWrapped,
        });
        // Signal that this function has been wrapped/filled already
        // for both debugging and to prevent it to being wrapped/filled twice
        Object.defineProperties(sentryWrapped, {
            __sentry__: {
                enumerable: false,
                value: true,
            },
            __sentry_original__: {
                enumerable: false,
                value: fn,
            },
        });
        // Restore original function name (not all browsers allow that)
        try {
            var descriptor = Object.getOwnPropertyDescriptor(sentryWrapped, 'name');
            if (descriptor.configurable) {
                Object.defineProperty(sentryWrapped, 'name', {
                    get: function () {
                        return fn.name;
                    },
                });
            }
            // eslint-disable-next-line no-empty
        }
        catch (_oO) { }
        return sentryWrapped;
    }
    /**
     * Injects the Report Dialog script
     * @hidden
     */
    function injectReportDialog(options) {
        if (options === void 0) { options = {}; }
        if (!options.eventId) {
            logger.error("Missing eventId option in showReportDialog call");
            return;
        }
        if (!options.dsn) {
            logger.error("Missing dsn option in showReportDialog call");
            return;
        }
        var script = document.createElement('script');
        script.async = true;
        script.src = new API(options.dsn).getReportDialogEndpoint(options);
        if (options.onLoad) {
            // eslint-disable-next-line @typescript-eslint/unbound-method
            script.onload = options.onLoad;
        }
        (document.head || document.body).appendChild(script);
    }

    /** Global handlers */
    var GlobalHandlers = /** @class */ (function () {
        /** JSDoc */
        function GlobalHandlers(options) {
            /**
             * @inheritDoc
             */
            this.name = GlobalHandlers.id;
            /** JSDoc */
            this._onErrorHandlerInstalled = false;
            /** JSDoc */
            this._onUnhandledRejectionHandlerInstalled = false;
            this._options = __assign({ onerror: true, onunhandledrejection: true }, options);
        }
        /**
         * @inheritDoc
         */
        GlobalHandlers.prototype.setupOnce = function () {
            Error.stackTraceLimit = 50;
            if (this._options.onerror) {
                logger.log('Global Handler attached: onerror');
                this._installGlobalOnErrorHandler();
            }
            if (this._options.onunhandledrejection) {
                logger.log('Global Handler attached: onunhandledrejection');
                this._installGlobalOnUnhandledRejectionHandler();
            }
        };
        /** JSDoc */
        GlobalHandlers.prototype._installGlobalOnErrorHandler = function () {
            var _this = this;
            if (this._onErrorHandlerInstalled) {
                return;
            }
            addInstrumentationHandler({
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                callback: function (data) {
                    var error = data.error;
                    var currentHub = getCurrentHub();
                    var hasIntegration = currentHub.getIntegration(GlobalHandlers);
                    var isFailedOwnDelivery = error && error.__sentry_own_request__ === true;
                    if (!hasIntegration || shouldIgnoreOnError() || isFailedOwnDelivery) {
                        return;
                    }
                    var client = currentHub.getClient();
                    var event = isPrimitive(error)
                        ? _this._eventFromIncompleteOnError(data.msg, data.url, data.line, data.column)
                        : _this._enhanceEventWithInitialFrame(eventFromUnknownInput(error, undefined, {
                            attachStacktrace: client && client.getOptions().attachStacktrace,
                            rejection: false,
                        }), data.url, data.line, data.column);
                    addExceptionMechanism(event, {
                        handled: false,
                        type: 'onerror',
                    });
                    currentHub.captureEvent(event, {
                        originalException: error,
                    });
                },
                type: 'error',
            });
            this._onErrorHandlerInstalled = true;
        };
        /** JSDoc */
        GlobalHandlers.prototype._installGlobalOnUnhandledRejectionHandler = function () {
            var _this = this;
            if (this._onUnhandledRejectionHandlerInstalled) {
                return;
            }
            addInstrumentationHandler({
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                callback: function (e) {
                    var error = e;
                    // dig the object of the rejection out of known event types
                    try {
                        // PromiseRejectionEvents store the object of the rejection under 'reason'
                        // see https://developer.mozilla.org/en-US/docs/Web/API/PromiseRejectionEvent
                        if ('reason' in e) {
                            error = e.reason;
                        }
                        // something, somewhere, (likely a browser extension) effectively casts PromiseRejectionEvents
                        // to CustomEvents, moving the `promise` and `reason` attributes of the PRE into
                        // the CustomEvent's `detail` attribute, since they're not part of CustomEvent's spec
                        // see https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent and
                        // https://github.com/getsentry/sentry-javascript/issues/2380
                        else if ('detail' in e && 'reason' in e.detail) {
                            error = e.detail.reason;
                        }
                    }
                    catch (_oO) {
                        // no-empty
                    }
                    var currentHub = getCurrentHub();
                    var hasIntegration = currentHub.getIntegration(GlobalHandlers);
                    var isFailedOwnDelivery = error && error.__sentry_own_request__ === true;
                    if (!hasIntegration || shouldIgnoreOnError() || isFailedOwnDelivery) {
                        return true;
                    }
                    var client = currentHub.getClient();
                    var event = isPrimitive(error)
                        ? _this._eventFromRejectionWithPrimitive(error)
                        : eventFromUnknownInput(error, undefined, {
                            attachStacktrace: client && client.getOptions().attachStacktrace,
                            rejection: true,
                        });
                    event.level = Severity.Error;
                    addExceptionMechanism(event, {
                        handled: false,
                        type: 'onunhandledrejection',
                    });
                    currentHub.captureEvent(event, {
                        originalException: error,
                    });
                    return;
                },
                type: 'unhandledrejection',
            });
            this._onUnhandledRejectionHandlerInstalled = true;
        };
        /**
         * This function creates a stack from an old, error-less onerror handler.
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        GlobalHandlers.prototype._eventFromIncompleteOnError = function (msg, url, line, column) {
            var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/i;
            // If 'message' is ErrorEvent, get real message from inside
            var message = isErrorEvent(msg) ? msg.message : msg;
            var name;
            if (isString(message)) {
                var groups = message.match(ERROR_TYPES_RE);
                if (groups) {
                    name = groups[1];
                    message = groups[2];
                }
            }
            var event = {
                exception: {
                    values: [
                        {
                            type: name || 'Error',
                            value: message,
                        },
                    ],
                },
            };
            return this._enhanceEventWithInitialFrame(event, url, line, column);
        };
        /**
         * Create an event from a promise rejection where the `reason` is a primitive.
         *
         * @param reason: The `reason` property of the promise rejection
         * @returns An Event object with an appropriate `exception` value
         */
        GlobalHandlers.prototype._eventFromRejectionWithPrimitive = function (reason) {
            return {
                exception: {
                    values: [
                        {
                            type: 'UnhandledRejection',
                            // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
                            value: "Non-Error promise rejection captured with value: " + String(reason),
                        },
                    ],
                },
            };
        };
        /** JSDoc */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        GlobalHandlers.prototype._enhanceEventWithInitialFrame = function (event, url, line, column) {
            event.exception = event.exception || {};
            event.exception.values = event.exception.values || [];
            event.exception.values[0] = event.exception.values[0] || {};
            event.exception.values[0].stacktrace = event.exception.values[0].stacktrace || {};
            event.exception.values[0].stacktrace.frames = event.exception.values[0].stacktrace.frames || [];
            var colno = isNaN(parseInt(column, 10)) ? undefined : column;
            var lineno = isNaN(parseInt(line, 10)) ? undefined : line;
            var filename = isString(url) && url.length > 0 ? url : getLocationHref();
            if (event.exception.values[0].stacktrace.frames.length === 0) {
                event.exception.values[0].stacktrace.frames.push({
                    colno: colno,
                    filename: filename,
                    function: '?',
                    in_app: true,
                    lineno: lineno,
                });
            }
            return event;
        };
        /**
         * @inheritDoc
         */
        GlobalHandlers.id = 'GlobalHandlers';
        return GlobalHandlers;
    }());

    var DEFAULT_EVENT_TARGET = [
        'EventTarget',
        'Window',
        'Node',
        'ApplicationCache',
        'AudioTrackList',
        'ChannelMergerNode',
        'CryptoOperation',
        'EventSource',
        'FileReader',
        'HTMLUnknownElement',
        'IDBDatabase',
        'IDBRequest',
        'IDBTransaction',
        'KeyOperation',
        'MediaController',
        'MessagePort',
        'ModalWindow',
        'Notification',
        'SVGElementInstance',
        'Screen',
        'TextTrack',
        'TextTrackCue',
        'TextTrackList',
        'WebSocket',
        'WebSocketWorker',
        'Worker',
        'XMLHttpRequest',
        'XMLHttpRequestEventTarget',
        'XMLHttpRequestUpload',
    ];
    /** Wrap timer functions and event targets to catch errors and provide better meta data */
    var TryCatch = /** @class */ (function () {
        /**
         * @inheritDoc
         */
        function TryCatch(options) {
            /**
             * @inheritDoc
             */
            this.name = TryCatch.id;
            this._options = __assign({ XMLHttpRequest: true, eventTarget: true, requestAnimationFrame: true, setInterval: true, setTimeout: true }, options);
        }
        /**
         * Wrap timer functions and event targets to catch errors
         * and provide better metadata.
         */
        TryCatch.prototype.setupOnce = function () {
            var global = getGlobalObject();
            if (this._options.setTimeout) {
                fill(global, 'setTimeout', this._wrapTimeFunction.bind(this));
            }
            if (this._options.setInterval) {
                fill(global, 'setInterval', this._wrapTimeFunction.bind(this));
            }
            if (this._options.requestAnimationFrame) {
                fill(global, 'requestAnimationFrame', this._wrapRAF.bind(this));
            }
            if (this._options.XMLHttpRequest && 'XMLHttpRequest' in global) {
                fill(XMLHttpRequest.prototype, 'send', this._wrapXHR.bind(this));
            }
            if (this._options.eventTarget) {
                var eventTarget = Array.isArray(this._options.eventTarget) ? this._options.eventTarget : DEFAULT_EVENT_TARGET;
                eventTarget.forEach(this._wrapEventTarget.bind(this));
            }
        };
        /** JSDoc */
        TryCatch.prototype._wrapTimeFunction = function (original) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var originalCallback = args[0];
                args[0] = wrap(originalCallback, {
                    mechanism: {
                        data: { function: getFunctionName(original) },
                        handled: true,
                        type: 'instrument',
                    },
                });
                return original.apply(this, args);
            };
        };
        /** JSDoc */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        TryCatch.prototype._wrapRAF = function (original) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return function (callback) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                return original.call(this, wrap(callback, {
                    mechanism: {
                        data: {
                            function: 'requestAnimationFrame',
                            handler: getFunctionName(original),
                        },
                        handled: true,
                        type: 'instrument',
                    },
                }));
            };
        };
        /** JSDoc */
        TryCatch.prototype._wrapEventTarget = function (target) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var global = getGlobalObject();
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            var proto = global[target] && global[target].prototype;
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (!proto || !proto.hasOwnProperty || !proto.hasOwnProperty('addEventListener')) {
                return;
            }
            fill(proto, 'addEventListener', function (original) {
                return function (eventName, fn, options) {
                    try {
                        if (typeof fn.handleEvent === 'function') {
                            fn.handleEvent = wrap(fn.handleEvent.bind(fn), {
                                mechanism: {
                                    data: {
                                        function: 'handleEvent',
                                        handler: getFunctionName(fn),
                                        target: target,
                                    },
                                    handled: true,
                                    type: 'instrument',
                                },
                            });
                        }
                    }
                    catch (err) {
                        // can sometimes get 'Permission denied to access property "handle Event'
                    }
                    return original.call(this, eventName, 
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    wrap(fn, {
                        mechanism: {
                            data: {
                                function: 'addEventListener',
                                handler: getFunctionName(fn),
                                target: target,
                            },
                            handled: true,
                            type: 'instrument',
                        },
                    }), options);
                };
            });
            fill(proto, 'removeEventListener', function (originalRemoveEventListener) {
                return function (eventName, fn, options) {
                    var _a;
                    /**
                     * There are 2 possible scenarios here:
                     *
                     * 1. Someone passes a callback, which was attached prior to Sentry initialization, or by using unmodified
                     * method, eg. `document.addEventListener.call(el, name, handler). In this case, we treat this function
                     * as a pass-through, and call original `removeEventListener` with it.
                     *
                     * 2. Someone passes a callback, which was attached after Sentry was initialized, which means that it was using
                     * our wrapped version of `addEventListener`, which internally calls `wrap` helper.
                     * This helper "wraps" whole callback inside a try/catch statement, and attached appropriate metadata to it,
                     * in order for us to make a distinction between wrapped/non-wrapped functions possible.
                     * If a function was wrapped, it has additional property of `__sentry_wrapped__`, holding the handler.
                     *
                     * When someone adds a handler prior to initialization, and then do it again, but after,
                     * then we have to detach both of them. Otherwise, if we'd detach only wrapped one, it'd be impossible
                     * to get rid of the initial handler and it'd stick there forever.
                     */
                    var wrappedEventHandler = fn;
                    try {
                        var originalEventHandler = (_a = wrappedEventHandler) === null || _a === void 0 ? void 0 : _a.__sentry_wrapped__;
                        if (originalEventHandler) {
                            originalRemoveEventListener.call(this, eventName, originalEventHandler, options);
                        }
                    }
                    catch (e) {
                        // ignore, accessing __sentry_wrapped__ will throw in some Selenium environments
                    }
                    return originalRemoveEventListener.call(this, eventName, wrappedEventHandler, options);
                };
            });
        };
        /** JSDoc */
        TryCatch.prototype._wrapXHR = function (originalSend) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                // eslint-disable-next-line @typescript-eslint/no-this-alias
                var xhr = this;
                var xmlHttpRequestProps = ['onload', 'onerror', 'onprogress', 'onreadystatechange'];
                xmlHttpRequestProps.forEach(function (prop) {
                    if (prop in xhr && typeof xhr[prop] === 'function') {
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        fill(xhr, prop, function (original) {
                            var wrapOptions = {
                                mechanism: {
                                    data: {
                                        function: prop,
                                        handler: getFunctionName(original),
                                    },
                                    handled: true,
                                    type: 'instrument',
                                },
                            };
                            // If Instrument integration has been called before TryCatch, get the name of original function
                            if (original.__sentry_original__) {
                                wrapOptions.mechanism.data.handler = getFunctionName(original.__sentry_original__);
                            }
                            // Otherwise wrap directly
                            return wrap(original, wrapOptions);
                        });
                    }
                });
                return originalSend.apply(this, args);
            };
        };
        /**
         * @inheritDoc
         */
        TryCatch.id = 'TryCatch';
        return TryCatch;
    }());

    /**
     * Default Breadcrumbs instrumentations
     * TODO: Deprecated - with v6, this will be renamed to `Instrument`
     */
    var Breadcrumbs = /** @class */ (function () {
        /**
         * @inheritDoc
         */
        function Breadcrumbs(options) {
            /**
             * @inheritDoc
             */
            this.name = Breadcrumbs.id;
            this._options = __assign({ console: true, dom: true, fetch: true, history: true, sentry: true, xhr: true }, options);
        }
        /**
         * Create a breadcrumb of `sentry` from the events themselves
         */
        Breadcrumbs.prototype.addSentryBreadcrumb = function (event) {
            if (!this._options.sentry) {
                return;
            }
            getCurrentHub().addBreadcrumb({
                category: "sentry." + (event.type === 'transaction' ? 'transaction' : 'event'),
                event_id: event.event_id,
                level: event.level,
                message: getEventDescription(event),
            }, {
                event: event,
            });
        };
        /**
         * Instrument browser built-ins w/ breadcrumb capturing
         *  - Console API
         *  - DOM API (click/typing)
         *  - XMLHttpRequest API
         *  - Fetch API
         *  - History API
         */
        Breadcrumbs.prototype.setupOnce = function () {
            var _this = this;
            if (this._options.console) {
                addInstrumentationHandler({
                    callback: function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        _this._consoleBreadcrumb.apply(_this, __spread(args));
                    },
                    type: 'console',
                });
            }
            if (this._options.dom) {
                addInstrumentationHandler({
                    callback: function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        _this._domBreadcrumb.apply(_this, __spread(args));
                    },
                    type: 'dom',
                });
            }
            if (this._options.xhr) {
                addInstrumentationHandler({
                    callback: function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        _this._xhrBreadcrumb.apply(_this, __spread(args));
                    },
                    type: 'xhr',
                });
            }
            if (this._options.fetch) {
                addInstrumentationHandler({
                    callback: function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        _this._fetchBreadcrumb.apply(_this, __spread(args));
                    },
                    type: 'fetch',
                });
            }
            if (this._options.history) {
                addInstrumentationHandler({
                    callback: function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        _this._historyBreadcrumb.apply(_this, __spread(args));
                    },
                    type: 'history',
                });
            }
        };
        /**
         * Creates breadcrumbs from console API calls
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Breadcrumbs.prototype._consoleBreadcrumb = function (handlerData) {
            var breadcrumb = {
                category: 'console',
                data: {
                    arguments: handlerData.args,
                    logger: 'console',
                },
                level: Severity.fromString(handlerData.level),
                message: safeJoin(handlerData.args, ' '),
            };
            if (handlerData.level === 'assert') {
                if (handlerData.args[0] === false) {
                    breadcrumb.message = "Assertion failed: " + (safeJoin(handlerData.args.slice(1), ' ') || 'console.assert');
                    breadcrumb.data.arguments = handlerData.args.slice(1);
                }
                else {
                    // Don't capture a breadcrumb for passed assertions
                    return;
                }
            }
            getCurrentHub().addBreadcrumb(breadcrumb, {
                input: handlerData.args,
                level: handlerData.level,
            });
        };
        /**
         * Creates breadcrumbs from DOM API calls
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Breadcrumbs.prototype._domBreadcrumb = function (handlerData) {
            var target;
            // Accessing event.target can throw (see getsentry/raven-js#838, #768)
            try {
                target = handlerData.event.target
                    ? htmlTreeAsString(handlerData.event.target)
                    : htmlTreeAsString(handlerData.event);
            }
            catch (e) {
                target = '<unknown>';
            }
            if (target.length === 0) {
                return;
            }
            getCurrentHub().addBreadcrumb({
                category: "ui." + handlerData.name,
                message: target,
            }, {
                event: handlerData.event,
                name: handlerData.name,
                global: handlerData.global,
            });
        };
        /**
         * Creates breadcrumbs from XHR API calls
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Breadcrumbs.prototype._xhrBreadcrumb = function (handlerData) {
            if (handlerData.endTimestamp) {
                // We only capture complete, non-sentry requests
                if (handlerData.xhr.__sentry_own_request__) {
                    return;
                }
                var _a = handlerData.xhr.__sentry_xhr__ || {}, method = _a.method, url = _a.url, status_code = _a.status_code, body = _a.body;
                getCurrentHub().addBreadcrumb({
                    category: 'xhr',
                    data: {
                        method: method,
                        url: url,
                        status_code: status_code,
                    },
                    type: 'http',
                }, {
                    xhr: handlerData.xhr,
                    input: body,
                });
                return;
            }
        };
        /**
         * Creates breadcrumbs from fetch API calls
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Breadcrumbs.prototype._fetchBreadcrumb = function (handlerData) {
            // We only capture complete fetch requests
            if (!handlerData.endTimestamp) {
                return;
            }
            if (handlerData.fetchData.url.match(/sentry_key/) && handlerData.fetchData.method === 'POST') {
                // We will not create breadcrumbs for fetch requests that contain `sentry_key` (internal sentry requests)
                return;
            }
            if (handlerData.error) {
                getCurrentHub().addBreadcrumb({
                    category: 'fetch',
                    data: handlerData.fetchData,
                    level: Severity.Error,
                    type: 'http',
                }, {
                    data: handlerData.error,
                    input: handlerData.args,
                });
            }
            else {
                getCurrentHub().addBreadcrumb({
                    category: 'fetch',
                    data: __assign(__assign({}, handlerData.fetchData), { status_code: handlerData.response.status }),
                    type: 'http',
                }, {
                    input: handlerData.args,
                    response: handlerData.response,
                });
            }
        };
        /**
         * Creates breadcrumbs from history API calls
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        Breadcrumbs.prototype._historyBreadcrumb = function (handlerData) {
            var global = getGlobalObject();
            var from = handlerData.from;
            var to = handlerData.to;
            var parsedLoc = parseUrl(global.location.href);
            var parsedFrom = parseUrl(from);
            var parsedTo = parseUrl(to);
            // Initial pushState doesn't provide `from` information
            if (!parsedFrom.path) {
                parsedFrom = parsedLoc;
            }
            // Use only the path component of the URL if the URL matches the current
            // document (almost all the time when using pushState)
            if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host) {
                to = parsedTo.relative;
            }
            if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host) {
                from = parsedFrom.relative;
            }
            getCurrentHub().addBreadcrumb({
                category: 'navigation',
                data: {
                    from: from,
                    to: to,
                },
            });
        };
        /**
         * @inheritDoc
         */
        Breadcrumbs.id = 'Breadcrumbs';
        return Breadcrumbs;
    }());

    var DEFAULT_KEY = 'cause';
    var DEFAULT_LIMIT = 5;
    /** Adds SDK info to an event. */
    var LinkedErrors = /** @class */ (function () {
        /**
         * @inheritDoc
         */
        function LinkedErrors(options) {
            if (options === void 0) { options = {}; }
            /**
             * @inheritDoc
             */
            this.name = LinkedErrors.id;
            this._key = options.key || DEFAULT_KEY;
            this._limit = options.limit || DEFAULT_LIMIT;
        }
        /**
         * @inheritDoc
         */
        LinkedErrors.prototype.setupOnce = function () {
            addGlobalEventProcessor(function (event, hint) {
                var self = getCurrentHub().getIntegration(LinkedErrors);
                if (self) {
                    return self._handler(event, hint);
                }
                return event;
            });
        };
        /**
         * @inheritDoc
         */
        LinkedErrors.prototype._handler = function (event, hint) {
            if (!event.exception || !event.exception.values || !hint || !isInstanceOf(hint.originalException, Error)) {
                return event;
            }
            var linkedErrors = this._walkErrorTree(hint.originalException, this._key);
            event.exception.values = __spread(linkedErrors, event.exception.values);
            return event;
        };
        /**
         * @inheritDoc
         */
        LinkedErrors.prototype._walkErrorTree = function (error, key, stack) {
            if (stack === void 0) { stack = []; }
            if (!isInstanceOf(error[key], Error) || stack.length + 1 >= this._limit) {
                return stack;
            }
            var stacktrace = computeStackTrace(error[key]);
            var exception = exceptionFromStacktrace(stacktrace);
            return this._walkErrorTree(error[key], key, __spread([exception], stack));
        };
        /**
         * @inheritDoc
         */
        LinkedErrors.id = 'LinkedErrors';
        return LinkedErrors;
    }());

    var global$4 = getGlobalObject();
    /** UserAgent */
    var UserAgent = /** @class */ (function () {
        function UserAgent() {
            /**
             * @inheritDoc
             */
            this.name = UserAgent.id;
        }
        /**
         * @inheritDoc
         */
        UserAgent.prototype.setupOnce = function () {
            addGlobalEventProcessor(function (event) {
                var _a, _b, _c;
                if (getCurrentHub().getIntegration(UserAgent)) {
                    // if none of the information we want exists, don't bother
                    if (!global$4.navigator && !global$4.location && !global$4.document) {
                        return event;
                    }
                    // grab as much info as exists and add it to the event
                    var url = ((_a = event.request) === null || _a === void 0 ? void 0 : _a.url) || ((_b = global$4.location) === null || _b === void 0 ? void 0 : _b.href);
                    var referrer = (global$4.document || {}).referrer;
                    var userAgent = (global$4.navigator || {}).userAgent;
                    var headers = __assign(__assign(__assign({}, (_c = event.request) === null || _c === void 0 ? void 0 : _c.headers), (referrer && { Referer: referrer })), (userAgent && { 'User-Agent': userAgent }));
                    var request = __assign(__assign({}, (url && { url: url })), { headers: headers });
                    return __assign(__assign({}, event), { request: request });
                }
                return event;
            });
        };
        /**
         * @inheritDoc
         */
        UserAgent.id = 'UserAgent';
        return UserAgent;
    }());

    /**
     * The Sentry Browser SDK Client.
     *
     * @see BrowserOptions for documentation on configuration options.
     * @see SentryClient for usage documentation.
     */
    var BrowserClient = /** @class */ (function (_super) {
        __extends(BrowserClient, _super);
        /**
         * Creates a new Browser SDK instance.
         *
         * @param options Configuration options for this SDK.
         */
        function BrowserClient(options) {
            if (options === void 0) { options = {}; }
            return _super.call(this, BrowserBackend, options) || this;
        }
        /**
         * Show a report dialog to the user to send feedback to a specific event.
         *
         * @param options Set individual options for the dialog
         */
        BrowserClient.prototype.showReportDialog = function (options) {
            if (options === void 0) { options = {}; }
            // doesn't work without a document (React Native)
            var document = getGlobalObject().document;
            if (!document) {
                return;
            }
            if (!this._isEnabled()) {
                logger.error('Trying to call showReportDialog with Sentry Client disabled');
                return;
            }
            injectReportDialog(__assign(__assign({}, options), { dsn: options.dsn || this.getDsn() }));
        };
        /**
         * @inheritDoc
         */
        BrowserClient.prototype._prepareEvent = function (event, scope, hint) {
            event.platform = event.platform || 'javascript';
            return _super.prototype._prepareEvent.call(this, event, scope, hint);
        };
        /**
         * @inheritDoc
         */
        BrowserClient.prototype._sendEvent = function (event) {
            var integration = this.getIntegration(Breadcrumbs);
            if (integration) {
                integration.addSentryBreadcrumb(event);
            }
            _super.prototype._sendEvent.call(this, event);
        };
        return BrowserClient;
    }(BaseClient));

    var defaultIntegrations = [
        new InboundFilters(),
        new FunctionToString(),
        new TryCatch(),
        new Breadcrumbs(),
        new GlobalHandlers(),
        new LinkedErrors(),
        new UserAgent(),
    ];
    /**
     * The Sentry Browser SDK Client.
     *
     * To use this SDK, call the {@link init} function as early as possible when
     * loading the web page. To set context information or send manual events, use
     * the provided methods.
     *
     * @example
     *
     * ```
     *
     * import { init } from '@sentry/browser';
     *
     * init({
     *   dsn: '__DSN__',
     *   // ...
     * });
     * ```
     *
     * @example
     * ```
     *
     * import { configureScope } from '@sentry/browser';
     * configureScope((scope: Scope) => {
     *   scope.setExtra({ battery: 0.7 });
     *   scope.setTag({ user_mode: 'admin' });
     *   scope.setUser({ id: '4711' });
     * });
     * ```
     *
     * @example
     * ```
     *
     * import { addBreadcrumb } from '@sentry/browser';
     * addBreadcrumb({
     *   message: 'My Breadcrumb',
     *   // ...
     * });
     * ```
     *
     * @example
     *
     * ```
     *
     * import * as Sentry from '@sentry/browser';
     * Sentry.captureMessage('Hello, world!');
     * Sentry.captureException(new Error('Good bye'));
     * Sentry.captureEvent({
     *   message: 'Manual',
     *   stacktrace: [
     *     // ...
     *   ],
     * });
     * ```
     *
     * @see {@link BrowserOptions} for documentation on configuration options.
     */
    function init$1(options) {
        if (options === void 0) { options = {}; }
        if (options.defaultIntegrations === undefined) {
            options.defaultIntegrations = defaultIntegrations;
        }
        if (options.release === undefined) {
            var window_1 = getGlobalObject();
            // This supports the variable that sentry-webpack-plugin injects
            if (window_1.SENTRY_RELEASE && window_1.SENTRY_RELEASE.id) {
                options.release = window_1.SENTRY_RELEASE.id;
            }
        }
        if (options.autoSessionTracking === undefined) {
            options.autoSessionTracking = true;
        }
        options._metadata = options._metadata || {};
        options._metadata.sdk = {
            name: 'sentry.javascript.browser',
            packages: [
                {
                    name: 'npm:@sentry/browser',
                    version: SDK_VERSION,
                },
            ],
            version: SDK_VERSION,
        };
        initAndBind(BrowserClient, options);
        if (options.autoSessionTracking) {
            startSessionTracking();
        }
    }
    /**
     * Enable automatic Session Tracking for the initial page load.
     */
    function startSessionTracking() {
        var window = getGlobalObject();
        var document = window.document;
        if (typeof document === 'undefined') {
            logger.warn('Session tracking in non-browser environment with @sentry/browser is not supported.');
            return;
        }
        var hub = getCurrentHub();
        hub.startSession();
        hub.captureSession();
        // We want to create a session for every navigation as well
        addInstrumentationHandler({
            callback: function () {
                hub.startSession();
                hub.captureSession();
            },
            type: 'history',
        });
    }

    /** The status of an Span. */
    // eslint-disable-next-line import/export
    var SpanStatus;
    (function (SpanStatus) {
        /** The operation completed successfully. */
        SpanStatus["Ok"] = "ok";
        /** Deadline expired before operation could complete. */
        SpanStatus["DeadlineExceeded"] = "deadline_exceeded";
        /** 401 Unauthorized (actually does mean unauthenticated according to RFC 7235) */
        SpanStatus["Unauthenticated"] = "unauthenticated";
        /** 403 Forbidden */
        SpanStatus["PermissionDenied"] = "permission_denied";
        /** 404 Not Found. Some requested entity (file or directory) was not found. */
        SpanStatus["NotFound"] = "not_found";
        /** 429 Too Many Requests */
        SpanStatus["ResourceExhausted"] = "resource_exhausted";
        /** Client specified an invalid argument. 4xx. */
        SpanStatus["InvalidArgument"] = "invalid_argument";
        /** 501 Not Implemented */
        SpanStatus["Unimplemented"] = "unimplemented";
        /** 503 Service Unavailable */
        SpanStatus["Unavailable"] = "unavailable";
        /** Other/generic 5xx. */
        SpanStatus["InternalError"] = "internal_error";
        /** Unknown. Any non-standard HTTP status code. */
        SpanStatus["UnknownError"] = "unknown_error";
        /** The operation was cancelled (typically by the user). */
        SpanStatus["Cancelled"] = "cancelled";
        /** Already exists (409) */
        SpanStatus["AlreadyExists"] = "already_exists";
        /** Operation was rejected because the system is not in a state required for the operation's */
        SpanStatus["FailedPrecondition"] = "failed_precondition";
        /** The operation was aborted, typically due to a concurrency issue. */
        SpanStatus["Aborted"] = "aborted";
        /** Operation was attempted past the valid range. */
        SpanStatus["OutOfRange"] = "out_of_range";
        /** Unrecoverable data loss or corruption */
        SpanStatus["DataLoss"] = "data_loss";
    })(SpanStatus || (SpanStatus = {}));
    // eslint-disable-next-line @typescript-eslint/no-namespace, import/export
    (function (SpanStatus) {
        /**
         * Converts a HTTP status code into a {@link SpanStatus}.
         *
         * @param httpStatus The HTTP response status code.
         * @returns The span status or {@link SpanStatus.UnknownError}.
         */
        function fromHttpCode(httpStatus) {
            if (httpStatus < 400) {
                return SpanStatus.Ok;
            }
            if (httpStatus >= 400 && httpStatus < 500) {
                switch (httpStatus) {
                    case 401:
                        return SpanStatus.Unauthenticated;
                    case 403:
                        return SpanStatus.PermissionDenied;
                    case 404:
                        return SpanStatus.NotFound;
                    case 409:
                        return SpanStatus.AlreadyExists;
                    case 413:
                        return SpanStatus.FailedPrecondition;
                    case 429:
                        return SpanStatus.ResourceExhausted;
                    default:
                        return SpanStatus.InvalidArgument;
                }
            }
            if (httpStatus >= 500 && httpStatus < 600) {
                switch (httpStatus) {
                    case 501:
                        return SpanStatus.Unimplemented;
                    case 503:
                        return SpanStatus.Unavailable;
                    case 504:
                        return SpanStatus.DeadlineExceeded;
                    default:
                        return SpanStatus.InternalError;
                }
            }
            return SpanStatus.UnknownError;
        }
        SpanStatus.fromHttpCode = fromHttpCode;
    })(SpanStatus || (SpanStatus = {}));

    var TRACEPARENT_REGEXP = new RegExp('^[ \\t]*' + // whitespace
        '([0-9a-f]{32})?' + // trace_id
        '-?([0-9a-f]{16})?' + // span_id
        '-?([01])?' + // sampled
        '[ \\t]*$');
    /**
     * Determines if tracing is currently enabled.
     *
     * Tracing is enabled when at least one of `tracesSampleRate` and `tracesSampler` is defined in the SDK config.
     */
    function hasTracingEnabled(options) {
        return 'tracesSampleRate' in options || 'tracesSampler' in options;
    }
    /**
     * Extract transaction context data from a `sentry-trace` header.
     *
     * @param traceparent Traceparent string
     *
     * @returns Object containing data from the header, or undefined if traceparent string is malformed
     */
    function extractTraceparentData(traceparent) {
        var matches = traceparent.match(TRACEPARENT_REGEXP);
        if (matches) {
            var parentSampled = void 0;
            if (matches[3] === '1') {
                parentSampled = true;
            }
            else if (matches[3] === '0') {
                parentSampled = false;
            }
            return {
                traceId: matches[1],
                parentSampled: parentSampled,
                parentSpanId: matches[2],
            };
        }
        return undefined;
    }
    /** Grabs active transaction off scope, if any */
    function getActiveTransaction(hub) {
        if (hub === void 0) { hub = getCurrentHub(); }
        var _a, _b;
        return (_b = (_a = hub) === null || _a === void 0 ? void 0 : _a.getScope()) === null || _b === void 0 ? void 0 : _b.getTransaction();
    }
    /**
     * Converts from milliseconds to seconds
     * @param time time in ms
     */
    function msToSec(time) {
        return time / 1000;
    }
    /**
     * Converts from seconds to milliseconds
     * @param time time in seconds
     */
    function secToMs(time) {
        return time * 1000;
    }

    /**
     * Configures global error listeners
     */
    function registerErrorInstrumentation() {
        addInstrumentationHandler({
            callback: errorCallback,
            type: 'error',
        });
        addInstrumentationHandler({
            callback: errorCallback,
            type: 'unhandledrejection',
        });
    }
    /**
     * If an error or unhandled promise occurs, we mark the active transaction as failed
     */
    function errorCallback() {
        var activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            logger.log("[Tracing] Transaction: " + SpanStatus.InternalError + " -> Global error occured");
            activeTransaction.setStatus(SpanStatus.InternalError);
        }
    }

    /**
     * Keeps track of finished spans for a given transaction
     * @internal
     * @hideconstructor
     * @hidden
     */
    var SpanRecorder = /** @class */ (function () {
        function SpanRecorder(maxlen) {
            if (maxlen === void 0) { maxlen = 1000; }
            this.spans = [];
            this._maxlen = maxlen;
        }
        /**
         * This is just so that we don't run out of memory while recording a lot
         * of spans. At some point we just stop and flush out the start of the
         * trace tree (i.e.the first n spans with the smallest
         * start_timestamp).
         */
        SpanRecorder.prototype.add = function (span) {
            if (this.spans.length > this._maxlen) {
                span.spanRecorder = undefined;
            }
            else {
                this.spans.push(span);
            }
        };
        return SpanRecorder;
    }());
    /**
     * Span contains all data about a span
     */
    var Span = /** @class */ (function () {
        /**
         * You should never call the constructor manually, always use `Sentry.startTransaction()`
         * or call `startChild()` on an existing span.
         * @internal
         * @hideconstructor
         * @hidden
         */
        function Span(spanContext) {
            /**
             * @inheritDoc
             */
            this.traceId = uuid4();
            /**
             * @inheritDoc
             */
            this.spanId = uuid4().substring(16);
            /**
             * Timestamp in seconds when the span was created.
             */
            this.startTimestamp = timestampWithMs();
            /**
             * @inheritDoc
             */
            this.tags = {};
            /**
             * @inheritDoc
             */
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            this.data = {};
            if (!spanContext) {
                return this;
            }
            if (spanContext.traceId) {
                this.traceId = spanContext.traceId;
            }
            if (spanContext.spanId) {
                this.spanId = spanContext.spanId;
            }
            if (spanContext.parentSpanId) {
                this.parentSpanId = spanContext.parentSpanId;
            }
            // We want to include booleans as well here
            if ('sampled' in spanContext) {
                this.sampled = spanContext.sampled;
            }
            if (spanContext.op) {
                this.op = spanContext.op;
            }
            if (spanContext.description) {
                this.description = spanContext.description;
            }
            if (spanContext.data) {
                this.data = spanContext.data;
            }
            if (spanContext.tags) {
                this.tags = spanContext.tags;
            }
            if (spanContext.status) {
                this.status = spanContext.status;
            }
            if (spanContext.startTimestamp) {
                this.startTimestamp = spanContext.startTimestamp;
            }
            if (spanContext.endTimestamp) {
                this.endTimestamp = spanContext.endTimestamp;
            }
        }
        /**
         * @inheritDoc
         * @deprecated
         */
        Span.prototype.child = function (spanContext) {
            return this.startChild(spanContext);
        };
        /**
         * @inheritDoc
         */
        Span.prototype.startChild = function (spanContext) {
            var childSpan = new Span(__assign(__assign({}, spanContext), { parentSpanId: this.spanId, sampled: this.sampled, traceId: this.traceId }));
            childSpan.spanRecorder = this.spanRecorder;
            if (childSpan.spanRecorder) {
                childSpan.spanRecorder.add(childSpan);
            }
            childSpan.transaction = this.transaction;
            return childSpan;
        };
        /**
         * @inheritDoc
         */
        Span.prototype.setTag = function (key, value) {
            var _a;
            this.tags = __assign(__assign({}, this.tags), (_a = {}, _a[key] = value, _a));
            return this;
        };
        /**
         * @inheritDoc
         */
        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types
        Span.prototype.setData = function (key, value) {
            var _a;
            this.data = __assign(__assign({}, this.data), (_a = {}, _a[key] = value, _a));
            return this;
        };
        /**
         * @inheritDoc
         */
        Span.prototype.setStatus = function (value) {
            this.status = value;
            return this;
        };
        /**
         * @inheritDoc
         */
        Span.prototype.setHttpStatus = function (httpStatus) {
            this.setTag('http.status_code', String(httpStatus));
            var spanStatus = SpanStatus.fromHttpCode(httpStatus);
            if (spanStatus !== SpanStatus.UnknownError) {
                this.setStatus(spanStatus);
            }
            return this;
        };
        /**
         * @inheritDoc
         */
        Span.prototype.isSuccess = function () {
            return this.status === SpanStatus.Ok;
        };
        /**
         * @inheritDoc
         */
        Span.prototype.finish = function (endTimestamp) {
            this.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();
        };
        /**
         * @inheritDoc
         */
        Span.prototype.toTraceparent = function () {
            var sampledString = '';
            if (this.sampled !== undefined) {
                sampledString = this.sampled ? '-1' : '-0';
            }
            return this.traceId + "-" + this.spanId + sampledString;
        };
        /**
         * @inheritDoc
         */
        Span.prototype.toContext = function () {
            return dropUndefinedKeys({
                data: this.data,
                description: this.description,
                endTimestamp: this.endTimestamp,
                op: this.op,
                parentSpanId: this.parentSpanId,
                sampled: this.sampled,
                spanId: this.spanId,
                startTimestamp: this.startTimestamp,
                status: this.status,
                tags: this.tags,
                traceId: this.traceId,
            });
        };
        /**
         * @inheritDoc
         */
        Span.prototype.updateWithContext = function (spanContext) {
            var _a, _b, _c, _d, _e;
            this.data = (_a = spanContext.data, (_a !== null && _a !== void 0 ? _a : {}));
            this.description = spanContext.description;
            this.endTimestamp = spanContext.endTimestamp;
            this.op = spanContext.op;
            this.parentSpanId = spanContext.parentSpanId;
            this.sampled = spanContext.sampled;
            this.spanId = (_b = spanContext.spanId, (_b !== null && _b !== void 0 ? _b : this.spanId));
            this.startTimestamp = (_c = spanContext.startTimestamp, (_c !== null && _c !== void 0 ? _c : this.startTimestamp));
            this.status = spanContext.status;
            this.tags = (_d = spanContext.tags, (_d !== null && _d !== void 0 ? _d : {}));
            this.traceId = (_e = spanContext.traceId, (_e !== null && _e !== void 0 ? _e : this.traceId));
            return this;
        };
        /**
         * @inheritDoc
         */
        Span.prototype.getTraceContext = function () {
            return dropUndefinedKeys({
                data: Object.keys(this.data).length > 0 ? this.data : undefined,
                description: this.description,
                op: this.op,
                parent_span_id: this.parentSpanId,
                span_id: this.spanId,
                status: this.status,
                tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
                trace_id: this.traceId,
            });
        };
        /**
         * @inheritDoc
         */
        Span.prototype.toJSON = function () {
            return dropUndefinedKeys({
                data: Object.keys(this.data).length > 0 ? this.data : undefined,
                description: this.description,
                op: this.op,
                parent_span_id: this.parentSpanId,
                span_id: this.spanId,
                start_timestamp: this.startTimestamp,
                status: this.status,
                tags: Object.keys(this.tags).length > 0 ? this.tags : undefined,
                timestamp: this.endTimestamp,
                trace_id: this.traceId,
            });
        };
        return Span;
    }());

    /** JSDoc */
    var Transaction = /** @class */ (function (_super) {
        __extends(Transaction, _super);
        /**
         * This constructor should never be called manually. Those instrumenting tracing should use
         * `Sentry.startTransaction()`, and internal methods should use `hub.startTransaction()`.
         * @internal
         * @hideconstructor
         * @hidden
         */
        function Transaction(transactionContext, hub) {
            var _this = _super.call(this, transactionContext) || this;
            _this._metadata = {};
            _this._measurements = {};
            /**
             * The reference to the current hub.
             */
            _this._hub = getCurrentHub();
            if (isInstanceOf(hub, Hub)) {
                _this._hub = hub;
            }
            _this.name = transactionContext.name || '';
            _this._trimEnd = transactionContext.trimEnd;
            // this is because transactions are also spans, and spans have a transaction pointer
            _this.transaction = _this;
            return _this;
        }
        /**
         * JSDoc
         */
        Transaction.prototype.setName = function (name) {
            this.name = name;
        };
        /**
         * Attaches SpanRecorder to the span itself
         * @param maxlen maximum number of spans that can be recorded
         */
        Transaction.prototype.initSpanRecorder = function (maxlen) {
            if (maxlen === void 0) { maxlen = 1000; }
            if (!this.spanRecorder) {
                this.spanRecorder = new SpanRecorder(maxlen);
            }
            this.spanRecorder.add(this);
        };
        /**
         * Set observed measurements for this transaction.
         * @hidden
         */
        Transaction.prototype.setMeasurements = function (measurements) {
            this._measurements = __assign({}, measurements);
        };
        /**
         * Set metadata for this transaction.
         * @hidden
         */
        Transaction.prototype.setMetadata = function (newMetadata) {
            this._metadata = __assign(__assign({}, this._metadata), newMetadata);
        };
        /**
         * @inheritDoc
         */
        Transaction.prototype.finish = function (endTimestamp) {
            var _this = this;
            // This transaction is already finished, so we should not flush it again.
            if (this.endTimestamp !== undefined) {
                return undefined;
            }
            if (!this.name) {
                logger.warn('Transaction has no name, falling back to `<unlabeled transaction>`.');
                this.name = '<unlabeled transaction>';
            }
            // just sets the end timestamp
            _super.prototype.finish.call(this, endTimestamp);
            if (this.sampled !== true) {
                // At this point if `sampled !== true` we want to discard the transaction.
                logger.log('[Tracing] Discarding transaction because its trace was not chosen to be sampled.');
                return undefined;
            }
            var finishedSpans = this.spanRecorder ? this.spanRecorder.spans.filter(function (s) { return s !== _this && s.endTimestamp; }) : [];
            if (this._trimEnd && finishedSpans.length > 0) {
                this.endTimestamp = finishedSpans.reduce(function (prev, current) {
                    if (prev.endTimestamp && current.endTimestamp) {
                        return prev.endTimestamp > current.endTimestamp ? prev : current;
                    }
                    return prev;
                }).endTimestamp;
            }
            var transaction = {
                contexts: {
                    trace: this.getTraceContext(),
                },
                spans: finishedSpans,
                start_timestamp: this.startTimestamp,
                tags: this.tags,
                timestamp: this.endTimestamp,
                transaction: this.name,
                type: 'transaction',
                debug_meta: this._metadata,
            };
            var hasMeasurements = Object.keys(this._measurements).length > 0;
            if (hasMeasurements) {
                logger.log('[Measurements] Adding measurements to transaction', JSON.stringify(this._measurements, undefined, 2));
                transaction.measurements = this._measurements;
            }
            return this._hub.captureEvent(transaction);
        };
        /**
         * @inheritDoc
         */
        Transaction.prototype.toContext = function () {
            var spanContext = _super.prototype.toContext.call(this);
            return dropUndefinedKeys(__assign(__assign({}, spanContext), { name: this.name, trimEnd: this._trimEnd }));
        };
        /**
         * @inheritDoc
         */
        Transaction.prototype.updateWithContext = function (transactionContext) {
            var _a;
            _super.prototype.updateWithContext.call(this, transactionContext);
            this.name = (_a = transactionContext.name, (_a !== null && _a !== void 0 ? _a : ''));
            this._trimEnd = transactionContext.trimEnd;
            return this;
        };
        return Transaction;
    }(Span));

    var DEFAULT_IDLE_TIMEOUT = 1000;
    /**
     * @inheritDoc
     */
    var IdleTransactionSpanRecorder = /** @class */ (function (_super) {
        __extends(IdleTransactionSpanRecorder, _super);
        function IdleTransactionSpanRecorder(_pushActivity, _popActivity, transactionSpanId, maxlen) {
            if (transactionSpanId === void 0) { transactionSpanId = ''; }
            var _this = _super.call(this, maxlen) || this;
            _this._pushActivity = _pushActivity;
            _this._popActivity = _popActivity;
            _this.transactionSpanId = transactionSpanId;
            return _this;
        }
        /**
         * @inheritDoc
         */
        IdleTransactionSpanRecorder.prototype.add = function (span) {
            var _this = this;
            // We should make sure we do not push and pop activities for
            // the transaction that this span recorder belongs to.
            if (span.spanId !== this.transactionSpanId) {
                // We patch span.finish() to pop an activity after setting an endTimestamp.
                span.finish = function (endTimestamp) {
                    span.endTimestamp = typeof endTimestamp === 'number' ? endTimestamp : timestampWithMs();
                    _this._popActivity(span.spanId);
                };
                // We should only push new activities if the span does not have an end timestamp.
                if (span.endTimestamp === undefined) {
                    this._pushActivity(span.spanId);
                }
            }
            _super.prototype.add.call(this, span);
        };
        return IdleTransactionSpanRecorder;
    }(SpanRecorder));
    /**
     * An IdleTransaction is a transaction that automatically finishes. It does this by tracking child spans as activities.
     * You can have multiple IdleTransactions active, but if the `onScope` option is specified, the idle transaction will
     * put itself on the scope on creation.
     */
    var IdleTransaction = /** @class */ (function (_super) {
        __extends(IdleTransaction, _super);
        function IdleTransaction(transactionContext, _idleHub, 
        // The time to wait in ms until the idle transaction will be finished. Default: 1000
        _idleTimeout, 
        // If an idle transaction should be put itself on and off the scope automatically.
        _onScope) {
            if (_idleTimeout === void 0) { _idleTimeout = DEFAULT_IDLE_TIMEOUT; }
            if (_onScope === void 0) { _onScope = false; }
            var _this = _super.call(this, transactionContext, _idleHub) || this;
            _this._idleHub = _idleHub;
            _this._idleTimeout = _idleTimeout;
            _this._onScope = _onScope;
            // Activities store a list of active spans
            _this.activities = {};
            // Stores reference to the timeout that calls _beat().
            _this._heartbeatTimer = 0;
            // Amount of times heartbeat has counted. Will cause transaction to finish after 3 beats.
            _this._heartbeatCounter = 0;
            // We should not use heartbeat if we finished a transaction
            _this._finished = false;
            _this._beforeFinishCallbacks = [];
            if (_idleHub && _onScope) {
                // There should only be one active transaction on the scope
                clearActiveTransaction(_idleHub);
                // We set the transaction here on the scope so error events pick up the trace
                // context and attach it to the error.
                logger.log("Setting idle transaction on scope. Span ID: " + _this.spanId);
                _idleHub.configureScope(function (scope) { return scope.setSpan(_this); });
            }
            _this._initTimeout = setTimeout(function () {
                if (!_this._finished) {
                    _this.finish();
                }
            }, _this._idleTimeout);
            return _this;
        }
        /** {@inheritDoc} */
        IdleTransaction.prototype.finish = function (endTimestamp) {
            var e_1, _a;
            var _this = this;
            if (endTimestamp === void 0) { endTimestamp = timestampWithMs(); }
            this._finished = true;
            this.activities = {};
            if (this.spanRecorder) {
                logger.log('[Tracing] finishing IdleTransaction', new Date(endTimestamp * 1000).toISOString(), this.op);
                try {
                    for (var _b = __values(this._beforeFinishCallbacks), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var callback = _c.value;
                        callback(this, endTimestamp);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                this.spanRecorder.spans = this.spanRecorder.spans.filter(function (span) {
                    // If we are dealing with the transaction itself, we just return it
                    if (span.spanId === _this.spanId) {
                        return true;
                    }
                    // We cancel all pending spans with status "cancelled" to indicate the idle transaction was finished early
                    if (!span.endTimestamp) {
                        span.endTimestamp = endTimestamp;
                        span.setStatus(SpanStatus.Cancelled);
                        logger.log('[Tracing] cancelling span since transaction ended early', JSON.stringify(span, undefined, 2));
                    }
                    var keepSpan = span.startTimestamp < endTimestamp;
                    if (!keepSpan) {
                        logger.log('[Tracing] discarding Span since it happened after Transaction was finished', JSON.stringify(span, undefined, 2));
                    }
                    return keepSpan;
                });
                logger.log('[Tracing] flushing IdleTransaction');
            }
            else {
                logger.log('[Tracing] No active IdleTransaction');
            }
            // this._onScope is true if the transaction was previously on the scope.
            if (this._onScope) {
                clearActiveTransaction(this._idleHub);
            }
            return _super.prototype.finish.call(this, endTimestamp);
        };
        /**
         * Register a callback function that gets excecuted before the transaction finishes.
         * Useful for cleanup or if you want to add any additional spans based on current context.
         *
         * This is exposed because users have no other way of running something before an idle transaction
         * finishes.
         */
        IdleTransaction.prototype.registerBeforeFinishCallback = function (callback) {
            this._beforeFinishCallbacks.push(callback);
        };
        /**
         * @inheritDoc
         */
        IdleTransaction.prototype.initSpanRecorder = function (maxlen) {
            var _this = this;
            if (!this.spanRecorder) {
                var pushActivity = function (id) {
                    if (_this._finished) {
                        return;
                    }
                    _this._pushActivity(id);
                };
                var popActivity = function (id) {
                    if (_this._finished) {
                        return;
                    }
                    _this._popActivity(id);
                };
                this.spanRecorder = new IdleTransactionSpanRecorder(pushActivity, popActivity, this.spanId, maxlen);
                // Start heartbeat so that transactions do not run forever.
                logger.log('Starting heartbeat');
                this._pingHeartbeat();
            }
            this.spanRecorder.add(this);
        };
        /**
         * Start tracking a specific activity.
         * @param spanId The span id that represents the activity
         */
        IdleTransaction.prototype._pushActivity = function (spanId) {
            if (this._initTimeout) {
                clearTimeout(this._initTimeout);
                this._initTimeout = undefined;
            }
            logger.log("[Tracing] pushActivity: " + spanId);
            this.activities[spanId] = true;
            logger.log('[Tracing] new activities count', Object.keys(this.activities).length);
        };
        /**
         * Remove an activity from usage
         * @param spanId The span id that represents the activity
         */
        IdleTransaction.prototype._popActivity = function (spanId) {
            var _this = this;
            if (this.activities[spanId]) {
                logger.log("[Tracing] popActivity " + spanId);
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete this.activities[spanId];
                logger.log('[Tracing] new activities count', Object.keys(this.activities).length);
            }
            if (Object.keys(this.activities).length === 0) {
                var timeout = this._idleTimeout;
                // We need to add the timeout here to have the real endtimestamp of the transaction
                // Remember timestampWithMs is in seconds, timeout is in ms
                var end_1 = timestampWithMs() + timeout / 1000;
                setTimeout(function () {
                    if (!_this._finished) {
                        _this.finish(end_1);
                    }
                }, timeout);
            }
        };
        /**
         * Checks when entries of this.activities are not changing for 3 beats.
         * If this occurs we finish the transaction.
         */
        IdleTransaction.prototype._beat = function () {
            clearTimeout(this._heartbeatTimer);
            // We should not be running heartbeat if the idle transaction is finished.
            if (this._finished) {
                return;
            }
            var keys = Object.keys(this.activities);
            var heartbeatString = keys.length ? keys.reduce(function (prev, current) { return prev + current; }) : '';
            if (heartbeatString === this._prevHeartbeatString) {
                this._heartbeatCounter += 1;
            }
            else {
                this._heartbeatCounter = 1;
            }
            this._prevHeartbeatString = heartbeatString;
            if (this._heartbeatCounter >= 3) {
                logger.log("[Tracing] Transaction finished because of no change for 3 heart beats");
                this.setStatus(SpanStatus.DeadlineExceeded);
                this.setTag('heartbeat', 'failed');
                this.finish();
            }
            else {
                this._pingHeartbeat();
            }
        };
        /**
         * Pings the heartbeat
         */
        IdleTransaction.prototype._pingHeartbeat = function () {
            var _this = this;
            logger.log("pinging Heartbeat -> current counter: " + this._heartbeatCounter);
            this._heartbeatTimer = setTimeout(function () {
                _this._beat();
            }, 5000);
        };
        return IdleTransaction;
    }(Transaction));
    /**
     * Reset active transaction on scope
     */
    function clearActiveTransaction(hub) {
        if (hub) {
            var scope = hub.getScope();
            if (scope) {
                var transaction = scope.getTransaction();
                if (transaction) {
                    scope.setSpan(undefined);
                }
            }
        }
    }

    /** Returns all trace headers that are currently on the top scope. */
    function traceHeaders() {
        var scope = this.getScope();
        if (scope) {
            var span = scope.getSpan();
            if (span) {
                return {
                    'sentry-trace': span.toTraceparent(),
                };
            }
        }
        return {};
    }
    /**
     * Makes a sampling decision for the given transaction and stores it on the transaction.
     *
     * Called every time a transaction is created. Only transactions which emerge with a `sampled` value of `true` will be
     * sent to Sentry.
     *
     * @param hub: The hub off of which to read config options
     * @param transaction: The transaction needing a sampling decision
     * @param samplingContext: Default and user-provided data which may be used to help make the decision
     *
     * @returns The given transaction with its `sampled` value set
     */
    function sample(transaction, options, samplingContext) {
        // nothing to do if tracing is not enabled
        if (!hasTracingEnabled(options)) {
            transaction.sampled = false;
            return transaction;
        }
        // if the user has forced a sampling decision by passing a `sampled` value in their transaction context, go with that
        if (transaction.sampled !== undefined) {
            transaction.setMetadata({
                transactionSampling: { method: TransactionSamplingMethod.Explicit },
            });
            return transaction;
        }
        // we would have bailed already if neither `tracesSampler` nor `tracesSampleRate` were defined, so one of these should
        // work; prefer the hook if so
        var sampleRate;
        if (typeof options.tracesSampler === 'function') {
            sampleRate = options.tracesSampler(samplingContext);
            transaction.setMetadata({
                transactionSampling: {
                    method: TransactionSamplingMethod.Sampler,
                    // cast to number in case it's a boolean
                    rate: Number(sampleRate),
                },
            });
        }
        else if (samplingContext.parentSampled !== undefined) {
            sampleRate = samplingContext.parentSampled;
            transaction.setMetadata({
                transactionSampling: { method: TransactionSamplingMethod.Inheritance },
            });
        }
        else {
            sampleRate = options.tracesSampleRate;
            transaction.setMetadata({
                transactionSampling: {
                    method: TransactionSamplingMethod.Rate,
                    // cast to number in case it's a boolean
                    rate: Number(sampleRate),
                },
            });
        }
        // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The
        // only valid values are booleans or numbers between 0 and 1.)
        if (!isValidSampleRate(sampleRate)) {
            logger.warn("[Tracing] Discarding transaction because of invalid sample rate.");
            transaction.sampled = false;
            return transaction;
        }
        // if the function returned 0 (or false), or if `tracesSampleRate` is 0, it's a sign the transaction should be dropped
        if (!sampleRate) {
            logger.log("[Tracing] Discarding transaction because " + (typeof options.tracesSampler === 'function'
                ? 'tracesSampler returned 0 or false'
                : 'a negative sampling decision was inherited or tracesSampleRate is set to 0'));
            transaction.sampled = false;
            return transaction;
        }
        // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is
        // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.
        transaction.sampled = Math.random() < sampleRate;
        // if we're not going to keep it, we're done
        if (!transaction.sampled) {
            logger.log("[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = " + Number(sampleRate) + ")");
            return transaction;
        }
        logger.log("[Tracing] starting " + transaction.op + " transaction - " + transaction.name);
        return transaction;
    }
    /**
     * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).
     */
    function isValidSampleRate(rate) {
        // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        if (isNaN(rate) || !(typeof rate === 'number' || typeof rate === 'boolean')) {
            logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got " + JSON.stringify(rate) + " of type " + JSON.stringify(typeof rate) + ".");
            return false;
        }
        // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false
        if (rate < 0 || rate > 1) {
            logger.warn("[Tracing] Given sample rate is invalid. Sample rate must be between 0 and 1. Got " + rate + ".");
            return false;
        }
        return true;
    }
    /**
     * Creates a new transaction and adds a sampling decision if it doesn't yet have one.
     *
     * The Hub.startTransaction method delegates to this method to do its work, passing the Hub instance in as `this`, as if
     * it had been called on the hub directly. Exists as a separate function so that it can be injected into the class as an
     * "extension method."
     *
     * @param this: The Hub starting the transaction
     * @param transactionContext: Data used to configure the transaction
     * @param CustomSamplingContext: Optional data to be provided to the `tracesSampler` function (if any)
     *
     * @returns The new transaction
     *
     * @see {@link Hub.startTransaction}
     */
    function _startTransaction(transactionContext, customSamplingContext) {
        var _a, _b;
        var options = ((_a = this.getClient()) === null || _a === void 0 ? void 0 : _a.getOptions()) || {};
        var transaction = new Transaction(transactionContext, this);
        transaction = sample(transaction, options, __assign({ parentSampled: transactionContext.parentSampled, transactionContext: transactionContext }, customSamplingContext));
        if (transaction.sampled) {
            transaction.initSpanRecorder((_b = options._experiments) === null || _b === void 0 ? void 0 : _b.maxSpans);
        }
        return transaction;
    }
    /**
     * Create new idle transaction.
     */
    function startIdleTransaction(hub, transactionContext, idleTimeout, onScope, customSamplingContext) {
        var _a, _b;
        var options = ((_a = hub.getClient()) === null || _a === void 0 ? void 0 : _a.getOptions()) || {};
        var transaction = new IdleTransaction(transactionContext, hub, idleTimeout, onScope);
        transaction = sample(transaction, options, __assign({ parentSampled: transactionContext.parentSampled, transactionContext: transactionContext }, customSamplingContext));
        if (transaction.sampled) {
            transaction.initSpanRecorder((_b = options._experiments) === null || _b === void 0 ? void 0 : _b.maxSpans);
        }
        return transaction;
    }
    /**
     * @private
     */
    function _addTracingExtensions() {
        var carrier = getMainCarrier();
        if (carrier.__SENTRY__) {
            carrier.__SENTRY__.extensions = carrier.__SENTRY__.extensions || {};
            if (!carrier.__SENTRY__.extensions.startTransaction) {
                carrier.__SENTRY__.extensions.startTransaction = _startTransaction;
            }
            if (!carrier.__SENTRY__.extensions.traceHeaders) {
                carrier.__SENTRY__.extensions.traceHeaders = traceHeaders;
            }
        }
    }
    /**
     * This patches the global object and injects the Tracing extensions methods
     */
    function addExtensionMethods() {
        _addTracingExtensions();
        // If an error happens globally, we should make sure transaction status is set to error.
        registerErrorInstrumentation();
    }

    var global$5 = getGlobalObject();
    /**
     * Add a listener that cancels and finishes a transaction when the global
     * document is hidden.
     */
    function registerBackgroundTabDetection() {
        if (global$5 && global$5.document) {
            global$5.document.addEventListener('visibilitychange', function () {
                var activeTransaction = getActiveTransaction();
                if (global$5.document.hidden && activeTransaction) {
                    logger.log("[Tracing] Transaction: " + SpanStatus.Cancelled + " -> since tab moved to the background, op: " + activeTransaction.op);
                    // We should not set status if it is already set, this prevent important statuses like
                    // error or data loss from being overwritten on transaction.
                    if (!activeTransaction.status) {
                        activeTransaction.setStatus(SpanStatus.Cancelled);
                    }
                    activeTransaction.setTag('visibilitychange', 'document.hidden');
                    activeTransaction.finish();
                }
            });
        }
        else {
            logger.warn('[Tracing] Could not set up background tab detection due to lack of global document');
        }
    }

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var bindReporter = function (callback, metric, po, observeAllUpdates) {
        var prevValue;
        return function () {
            if (po && metric.isFinal) {
                po.disconnect();
            }
            if (metric.value >= 0) {
                if (observeAllUpdates || metric.isFinal || document.visibilityState === 'hidden') {
                    metric.delta = metric.value - (prevValue || 0);
                    // Report the metric if there's a non-zero delta, if the metric is
                    // final, or if no previous value exists (which can happen in the case
                    // of the document becoming hidden when the metric value is 0).
                    // See: https://github.com/GoogleChrome/web-vitals/issues/14
                    if (metric.delta || metric.isFinal || prevValue === undefined) {
                        callback(metric);
                        prevValue = metric.value;
                    }
                }
            }
        };
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Performantly generate a unique, 27-char string by combining the current
     * timestamp with a 13-digit random number.
     * @return {string}
     */
    var generateUniqueID = function () {
        return Date.now() + "-" + (Math.floor(Math.random() * (9e12 - 1)) + 1e12);
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var initMetric = function (name, value) {
        if (value === void 0) { value = -1; }
        return {
            name: name,
            value: value,
            delta: 0,
            entries: [],
            id: generateUniqueID(),
            isFinal: false,
        };
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    /**
     * Takes a performance entry type and a callback function, and creates a
     * `PerformanceObserver` instance that will observe the specified entry type
     * with buffering enabled and call the callback _for each entry_.
     *
     * This function also feature-detects entry support and wraps the logic in a
     * try/catch to avoid errors in unsupporting browsers.
     */
    var observe = function (type, callback) {
        try {
            if (PerformanceObserver.supportedEntryTypes.includes(type)) {
                var po = new PerformanceObserver(function (l) { return l.getEntries().map(callback); });
                po.observe({ type: type, buffered: true });
                return po;
            }
        }
        catch (e) {
            // Do nothing.
        }
        return;
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var isUnloading = false;
    var listenersAdded = false;
    var onPageHide = function (event) {
        isUnloading = !event.persisted;
    };
    var addListeners = function () {
        addEventListener('pagehide', onPageHide);
        // `beforeunload` is needed to fix this bug:
        // https://bugs.chromium.org/p/chromium/issues/detail?id=987409
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        addEventListener('beforeunload', function () { });
    };
    var onHidden = function (cb, once) {
        if (once === void 0) { once = false; }
        if (!listenersAdded) {
            addListeners();
            listenersAdded = true;
        }
        addEventListener('visibilitychange', function (_a) {
            var timeStamp = _a.timeStamp;
            if (document.visibilityState === 'hidden') {
                cb({ timeStamp: timeStamp, isUnloading: isUnloading });
            }
        }, { capture: true, once: once });
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var getCLS = function (onReport, reportAllChanges) {
        if (reportAllChanges === void 0) { reportAllChanges = false; }
        var metric = initMetric('CLS', 0);
        var report;
        var entryHandler = function (entry) {
            // Only count layout shifts without recent user input.
            if (!entry.hadRecentInput) {
                metric.value += entry.value;
                metric.entries.push(entry);
                report();
            }
        };
        var po = observe('layout-shift', entryHandler);
        if (po) {
            report = bindReporter(onReport, metric, po, reportAllChanges);
            onHidden(function (_a) {
                var isUnloading = _a.isUnloading;
                po.takeRecords().map(entryHandler);
                if (isUnloading) {
                    metric.isFinal = true;
                }
                report();
            });
        }
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var firstHiddenTime;
    var getFirstHidden = function () {
        if (firstHiddenTime === undefined) {
            // If the document is hidden when this code runs, assume it was hidden
            // since navigation start. This isn't a perfect heuristic, but it's the
            // best we can do until an API is available to support querying past
            // visibilityState.
            firstHiddenTime = document.visibilityState === 'hidden' ? 0 : Infinity;
            // Update the time if/when the document becomes hidden.
            onHidden(function (_a) {
                var timeStamp = _a.timeStamp;
                return (firstHiddenTime = timeStamp);
            }, true);
        }
        return {
            get timeStamp() {
                return firstHiddenTime;
            },
        };
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var getFID = function (onReport) {
        var metric = initMetric('FID');
        var firstHidden = getFirstHidden();
        var entryHandler = function (entry) {
            // Only report if the page wasn't hidden prior to the first input.
            if (entry.startTime < firstHidden.timeStamp) {
                metric.value = entry.processingStart - entry.startTime;
                metric.entries.push(entry);
                metric.isFinal = true;
                report();
            }
        };
        var po = observe('first-input', entryHandler);
        var report = bindReporter(onReport, metric, po);
        if (po) {
            onHidden(function () {
                po.takeRecords().map(entryHandler);
                po.disconnect();
            }, true);
        }
        else {
            if (window.perfMetrics && window.perfMetrics.onFirstInputDelay) {
                window.perfMetrics.onFirstInputDelay(function (value, event) {
                    // Only report if the page wasn't hidden prior to the first input.
                    if (event.timeStamp < firstHidden.timeStamp) {
                        metric.value = value;
                        metric.isFinal = true;
                        metric.entries = [
                            {
                                entryType: 'first-input',
                                name: event.type,
                                target: event.target,
                                cancelable: event.cancelable,
                                startTime: event.timeStamp,
                                processingStart: event.timeStamp + value,
                            },
                        ];
                        report();
                    }
                });
            }
        }
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var inputPromise;
    var whenInput = function () {
        if (!inputPromise) {
            inputPromise = new Promise(function (r) {
                return ['scroll', 'keydown', 'pointerdown'].map(function (type) {
                    addEventListener(type, r, {
                        once: true,
                        passive: true,
                        capture: true,
                    });
                });
            });
        }
        return inputPromise;
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var getLCP = function (onReport, reportAllChanges) {
        if (reportAllChanges === void 0) { reportAllChanges = false; }
        var metric = initMetric('LCP');
        var firstHidden = getFirstHidden();
        var report;
        var entryHandler = function (entry) {
            // The startTime attribute returns the value of the renderTime if it is not 0,
            // and the value of the loadTime otherwise.
            var value = entry.startTime;
            // If the page was hidden prior to paint time of the entry,
            // ignore it and mark the metric as final, otherwise add the entry.
            if (value < firstHidden.timeStamp) {
                metric.value = value;
                metric.entries.push(entry);
            }
            else {
                metric.isFinal = true;
            }
            report();
        };
        var po = observe('largest-contentful-paint', entryHandler);
        if (po) {
            report = bindReporter(onReport, metric, po, reportAllChanges);
            var onFinal = function () {
                if (!metric.isFinal) {
                    po.takeRecords().map(entryHandler);
                    metric.isFinal = true;
                    report();
                }
            };
            void whenInput().then(onFinal);
            onHidden(onFinal, true);
        }
    };

    /*
     * Copyright 2020 Google LLC
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *     https://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */
    var global$6 = getGlobalObject();
    var afterLoad = function (callback) {
        if (document.readyState === 'complete') {
            // Queue a task so the callback runs after `loadEventEnd`.
            setTimeout(callback, 0);
        }
        else {
            // Use `pageshow` so the callback runs after `loadEventEnd`.
            addEventListener('pageshow', callback);
        }
    };
    var getNavigationEntryFromPerformanceTiming = function () {
        // Really annoying that TypeScript errors when using `PerformanceTiming`.
        // eslint-disable-next-line deprecation/deprecation
        var timing = global$6.performance.timing;
        var navigationEntry = {
            entryType: 'navigation',
            startTime: 0,
        };
        for (var key in timing) {
            if (key !== 'navigationStart' && key !== 'toJSON') {
                navigationEntry[key] = Math.max(timing[key] - timing.navigationStart, 0);
            }
        }
        return navigationEntry;
    };
    var getTTFB = function (onReport) {
        var metric = initMetric('TTFB');
        afterLoad(function () {
            try {
                // Use the NavigationTiming L2 entry if available.
                var navigationEntry = global$6.performance.getEntriesByType('navigation')[0] || getNavigationEntryFromPerformanceTiming();
                metric.value = metric.delta = navigationEntry.responseStart;
                metric.entries = [navigationEntry];
                onReport(metric);
            }
            catch (error) {
                // Do nothing.
            }
        });
    };

    var global$7 = getGlobalObject();
    /** Class tracking metrics  */
    var MetricsInstrumentation = /** @class */ (function () {
        function MetricsInstrumentation() {
            this._measurements = {};
            this._performanceCursor = 0;
            if (global$7 && global$7.performance) {
                if (global$7.performance.mark) {
                    global$7.performance.mark('sentry-tracing-init');
                }
                this._trackCLS();
                this._trackLCP();
                this._trackFID();
                this._trackTTFB();
            }
        }
        /** Add performance related spans to a transaction */
        MetricsInstrumentation.prototype.addPerformanceEntries = function (transaction) {
            var _this = this;
            if (!global$7 || !global$7.performance || !global$7.performance.getEntries || !browserPerformanceTimeOrigin) {
                // Gatekeeper if performance API not available
                return;
            }
            logger.log('[Tracing] Adding & adjusting spans using Performance API');
            var timeOrigin = msToSec(browserPerformanceTimeOrigin);
            var entryScriptSrc;
            if (global$7.document) {
                // eslint-disable-next-line @typescript-eslint/prefer-for-of
                for (var i = 0; i < document.scripts.length; i++) {
                    // We go through all scripts on the page and look for 'data-entry'
                    // We remember the name and measure the time between this script finished loading and
                    // our mark 'sentry-tracing-init'
                    if (document.scripts[i].dataset.entry === 'true') {
                        entryScriptSrc = document.scripts[i].src;
                        break;
                    }
                }
            }
            var entryScriptStartTimestamp;
            var tracingInitMarkStartTime;
            global$7.performance
                .getEntries()
                .slice(this._performanceCursor)
                .forEach(function (entry) {
                var startTime = msToSec(entry.startTime);
                var duration = msToSec(entry.duration);
                if (transaction.op === 'navigation' && timeOrigin + startTime < transaction.startTimestamp) {
                    return;
                }
                switch (entry.entryType) {
                    case 'navigation':
                        addNavigationSpans(transaction, entry, timeOrigin);
                        break;
                    case 'mark':
                    case 'paint':
                    case 'measure': {
                        var startTimestamp = addMeasureSpans(transaction, entry, startTime, duration, timeOrigin);
                        if (tracingInitMarkStartTime === undefined && entry.name === 'sentry-tracing-init') {
                            tracingInitMarkStartTime = startTimestamp;
                        }
                        // capture web vitals
                        var firstHidden = getFirstHidden();
                        // Only report if the page wasn't hidden prior to the web vital.
                        var shouldRecord = entry.startTime < firstHidden.timeStamp;
                        if (entry.name === 'first-paint' && shouldRecord) {
                            logger.log('[Measurements] Adding FP');
                            _this._measurements['fp'] = { value: entry.startTime };
                            _this._measurements['mark.fp'] = { value: startTimestamp };
                        }
                        if (entry.name === 'first-contentful-paint' && shouldRecord) {
                            logger.log('[Measurements] Adding FCP');
                            _this._measurements['fcp'] = { value: entry.startTime };
                            _this._measurements['mark.fcp'] = { value: startTimestamp };
                        }
                        break;
                    }
                    case 'resource': {
                        var resourceName = entry.name.replace(window.location.origin, '');
                        var endTimestamp = addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin);
                        // We remember the entry script end time to calculate the difference to the first init mark
                        if (entryScriptStartTimestamp === undefined && (entryScriptSrc || '').indexOf(resourceName) > -1) {
                            entryScriptStartTimestamp = endTimestamp;
                        }
                        break;
                    }
                    // Ignore other entry types.
                }
            });
            if (entryScriptStartTimestamp !== undefined && tracingInitMarkStartTime !== undefined) {
                _startChild(transaction, {
                    description: 'evaluation',
                    endTimestamp: tracingInitMarkStartTime,
                    op: 'script',
                    startTimestamp: entryScriptStartTimestamp,
                });
            }
            this._performanceCursor = Math.max(performance.getEntries().length - 1, 0);
            this._trackNavigator(transaction);
            // Measurements are only available for pageload transactions
            if (transaction.op === 'pageload') {
                // normalize applicable web vital values to be relative to transaction.startTimestamp
                var timeOrigin_1 = msToSec(browserPerformanceTimeOrigin);
                ['fcp', 'fp', 'lcp', 'ttfb'].forEach(function (name) {
                    if (!_this._measurements[name] || timeOrigin_1 >= transaction.startTimestamp) {
                        return;
                    }
                    // The web vitals, fcp, fp, lcp, and ttfb, all measure relative to timeOrigin.
                    // Unfortunately, timeOrigin is not captured within the transaction span data, so these web vitals will need
                    // to be adjusted to be relative to transaction.startTimestamp.
                    var oldValue = _this._measurements[name].value;
                    var measurementTimestamp = timeOrigin_1 + msToSec(oldValue);
                    // normalizedValue should be in milliseconds
                    var normalizedValue = Math.abs((measurementTimestamp - transaction.startTimestamp) * 1000);
                    var delta = normalizedValue - oldValue;
                    logger.log("[Measurements] Normalized " + name + " from " + oldValue + " to " + normalizedValue + " (" + delta + ")");
                    _this._measurements[name].value = normalizedValue;
                });
                if (this._measurements['mark.fid'] && this._measurements['fid']) {
                    // create span for FID
                    _startChild(transaction, {
                        description: 'first input delay',
                        endTimestamp: this._measurements['mark.fid'].value + msToSec(this._measurements['fid'].value),
                        op: 'web.vitals',
                        startTimestamp: this._measurements['mark.fid'].value,
                    });
                }
                transaction.setMeasurements(this._measurements);
            }
        };
        /** Starts tracking the Cumulative Layout Shift on the current page. */
        MetricsInstrumentation.prototype._trackCLS = function () {
            var _this = this;
            getCLS(function (metric) {
                var entry = metric.entries.pop();
                if (!entry) {
                    return;
                }
                logger.log('[Measurements] Adding CLS');
                _this._measurements['cls'] = { value: metric.value };
            });
        };
        /**
         * Capture the information of the user agent.
         */
        MetricsInstrumentation.prototype._trackNavigator = function (transaction) {
            var navigator = global$7.navigator;
            if (!navigator) {
                return;
            }
            // track network connectivity
            var connection = navigator.connection;
            if (connection) {
                if (connection.effectiveType) {
                    transaction.setTag('effectiveConnectionType', connection.effectiveType);
                }
                if (connection.type) {
                    transaction.setTag('connectionType', connection.type);
                }
                if (isMeasurementValue(connection.rtt)) {
                    this._measurements['connection.rtt'] = { value: connection.rtt };
                }
                if (isMeasurementValue(connection.downlink)) {
                    this._measurements['connection.downlink'] = { value: connection.downlink };
                }
            }
            if (isMeasurementValue(navigator.deviceMemory)) {
                transaction.setTag('deviceMemory', String(navigator.deviceMemory));
            }
            if (isMeasurementValue(navigator.hardwareConcurrency)) {
                transaction.setTag('hardwareConcurrency', String(navigator.hardwareConcurrency));
            }
        };
        /** Starts tracking the Largest Contentful Paint on the current page. */
        MetricsInstrumentation.prototype._trackLCP = function () {
            var _this = this;
            getLCP(function (metric) {
                var entry = metric.entries.pop();
                if (!entry) {
                    return;
                }
                var timeOrigin = msToSec(performance.timeOrigin);
                var startTime = msToSec(entry.startTime);
                logger.log('[Measurements] Adding LCP');
                _this._measurements['lcp'] = { value: metric.value };
                _this._measurements['mark.lcp'] = { value: timeOrigin + startTime };
            });
        };
        /** Starts tracking the First Input Delay on the current page. */
        MetricsInstrumentation.prototype._trackFID = function () {
            var _this = this;
            getFID(function (metric) {
                var entry = metric.entries.pop();
                if (!entry) {
                    return;
                }
                var timeOrigin = msToSec(performance.timeOrigin);
                var startTime = msToSec(entry.startTime);
                logger.log('[Measurements] Adding FID');
                _this._measurements['fid'] = { value: metric.value };
                _this._measurements['mark.fid'] = { value: timeOrigin + startTime };
            });
        };
        /** Starts tracking the Time to First Byte on the current page. */
        MetricsInstrumentation.prototype._trackTTFB = function () {
            var _this = this;
            getTTFB(function (metric) {
                var _a;
                var entry = metric.entries.pop();
                if (!entry) {
                    return;
                }
                logger.log('[Measurements] Adding TTFB');
                _this._measurements['ttfb'] = { value: metric.value };
                // Capture the time spent making the request and receiving the first byte of the response
                var requestTime = metric.value - (_a = metric.entries[0], (_a !== null && _a !== void 0 ? _a : entry)).requestStart;
                _this._measurements['ttfb.requestTime'] = { value: requestTime };
            });
        };
        return MetricsInstrumentation;
    }());
    /** Instrument navigation entries */
    function addNavigationSpans(transaction, entry, timeOrigin) {
        addPerformanceNavigationTiming(transaction, entry, 'unloadEvent', timeOrigin);
        addPerformanceNavigationTiming(transaction, entry, 'redirect', timeOrigin);
        addPerformanceNavigationTiming(transaction, entry, 'domContentLoadedEvent', timeOrigin);
        addPerformanceNavigationTiming(transaction, entry, 'loadEvent', timeOrigin);
        addPerformanceNavigationTiming(transaction, entry, 'connect', timeOrigin);
        addPerformanceNavigationTiming(transaction, entry, 'secureConnection', timeOrigin, 'connectEnd');
        addPerformanceNavigationTiming(transaction, entry, 'fetch', timeOrigin, 'domainLookupStart');
        addPerformanceNavigationTiming(transaction, entry, 'domainLookup', timeOrigin);
        addRequest(transaction, entry, timeOrigin);
    }
    /** Create measure related spans */
    function addMeasureSpans(transaction, entry, startTime, duration, timeOrigin) {
        var measureStartTimestamp = timeOrigin + startTime;
        var measureEndTimestamp = measureStartTimestamp + duration;
        _startChild(transaction, {
            description: entry.name,
            endTimestamp: measureEndTimestamp,
            op: entry.entryType,
            startTimestamp: measureStartTimestamp,
        });
        return measureStartTimestamp;
    }
    /** Create resource-related spans */
    function addResourceSpans(transaction, entry, resourceName, startTime, duration, timeOrigin) {
        // we already instrument based on fetch and xhr, so we don't need to
        // duplicate spans here.
        if (entry.initiatorType === 'xmlhttprequest' || entry.initiatorType === 'fetch') {
            return undefined;
        }
        var data = {};
        if ('transferSize' in entry) {
            data['Transfer Size'] = entry.transferSize;
        }
        if ('encodedBodySize' in entry) {
            data['Encoded Body Size'] = entry.encodedBodySize;
        }
        if ('decodedBodySize' in entry) {
            data['Decoded Body Size'] = entry.decodedBodySize;
        }
        var startTimestamp = timeOrigin + startTime;
        var endTimestamp = startTimestamp + duration;
        _startChild(transaction, {
            description: resourceName,
            endTimestamp: endTimestamp,
            op: entry.initiatorType ? "resource." + entry.initiatorType : 'resource',
            startTimestamp: startTimestamp,
            data: data,
        });
        return endTimestamp;
    }
    /** Create performance navigation related spans */
    function addPerformanceNavigationTiming(transaction, entry, event, timeOrigin, eventEnd) {
        var end = eventEnd ? entry[eventEnd] : entry[event + "End"];
        var start = entry[event + "Start"];
        if (!start || !end) {
            return;
        }
        _startChild(transaction, {
            op: 'browser',
            description: event,
            startTimestamp: timeOrigin + msToSec(start),
            endTimestamp: timeOrigin + msToSec(end),
        });
    }
    /** Create request and response related spans */
    function addRequest(transaction, entry, timeOrigin) {
        _startChild(transaction, {
            op: 'browser',
            description: 'request',
            startTimestamp: timeOrigin + msToSec(entry.requestStart),
            endTimestamp: timeOrigin + msToSec(entry.responseEnd),
        });
        _startChild(transaction, {
            op: 'browser',
            description: 'response',
            startTimestamp: timeOrigin + msToSec(entry.responseStart),
            endTimestamp: timeOrigin + msToSec(entry.responseEnd),
        });
    }
    /**
     * Helper function to start child on transactions. This function will make sure that the transaction will
     * use the start timestamp of the created child span if it is earlier than the transactions actual
     * start timestamp.
     */
    function _startChild(transaction, _a) {
        var startTimestamp = _a.startTimestamp, ctx = __rest(_a, ["startTimestamp"]);
        if (startTimestamp && transaction.startTimestamp > startTimestamp) {
            transaction.startTimestamp = startTimestamp;
        }
        return transaction.startChild(__assign({ startTimestamp: startTimestamp }, ctx));
    }
    /**
     * Checks if a given value is a valid measurement value.
     */
    function isMeasurementValue(value) {
        return typeof value === 'number' && isFinite(value);
    }

    var DEFAULT_TRACING_ORIGINS = ['localhost', /^\//];
    var defaultRequestInstrumentationOptions = {
        traceFetch: true,
        traceXHR: true,
        tracingOrigins: DEFAULT_TRACING_ORIGINS,
    };
    /** Registers span creators for xhr and fetch requests  */
    function registerRequestInstrumentation(_options) {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        var _a = __assign(__assign({}, defaultRequestInstrumentationOptions), _options), traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
        // We should cache url -> decision so that we don't have to compute
        // regexp everytime we create a request.
        var urlMap = {};
        var defaultShouldCreateSpan = function (url) {
            if (urlMap[url]) {
                return urlMap[url];
            }
            var origins = tracingOrigins;
            urlMap[url] =
                origins.some(function (origin) { return isMatchingPattern(url, origin); }) &&
                    !isMatchingPattern(url, 'sentry_key');
            return urlMap[url];
        };
        // We want that our users don't have to re-implement shouldCreateSpanForRequest themselves
        // That's why we filter out already unwanted Spans from tracingOrigins
        var shouldCreateSpan = defaultShouldCreateSpan;
        if (typeof shouldCreateSpanForRequest === 'function') {
            shouldCreateSpan = function (url) {
                return defaultShouldCreateSpan(url) && shouldCreateSpanForRequest(url);
            };
        }
        var spans = {};
        if (traceFetch) {
            addInstrumentationHandler({
                callback: function (handlerData) {
                    fetchCallback(handlerData, shouldCreateSpan, spans);
                },
                type: 'fetch',
            });
        }
        if (traceXHR) {
            addInstrumentationHandler({
                callback: function (handlerData) {
                    xhrCallback(handlerData, shouldCreateSpan, spans);
                },
                type: 'xhr',
            });
        }
    }
    /**
     * Create and track fetch request spans
     */
    function fetchCallback(handlerData, shouldCreateSpan, spans) {
        var _a;
        var currentClientOptions = (_a = getCurrentHub()
            .getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();
        if (!(currentClientOptions && hasTracingEnabled(currentClientOptions)) ||
            !(handlerData.fetchData && shouldCreateSpan(handlerData.fetchData.url))) {
            return;
        }
        if (handlerData.endTimestamp && handlerData.fetchData.__span) {
            var span = spans[handlerData.fetchData.__span];
            if (span) {
                var response = handlerData.response;
                if (response) {
                    // TODO (kmclb) remove this once types PR goes through
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    span.setHttpStatus(response.status);
                }
                span.finish();
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete spans[handlerData.fetchData.__span];
            }
            return;
        }
        var activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            var span = activeTransaction.startChild({
                data: __assign(__assign({}, handlerData.fetchData), { type: 'fetch' }),
                description: handlerData.fetchData.method + " " + handlerData.fetchData.url,
                op: 'http',
            });
            handlerData.fetchData.__span = span.spanId;
            spans[span.spanId] = span;
            var request = (handlerData.args[0] = handlerData.args[0]);
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            var options = (handlerData.args[1] = handlerData.args[1] || {});
            var headers = options.headers;
            if (isInstanceOf(request, Request)) {
                headers = request.headers;
            }
            if (headers) {
                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                if (typeof headers.append === 'function') {
                    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
                    headers.append('sentry-trace', span.toTraceparent());
                }
                else if (Array.isArray(headers)) {
                    headers = __spread(headers, [['sentry-trace', span.toTraceparent()]]);
                }
                else {
                    headers = __assign(__assign({}, headers), { 'sentry-trace': span.toTraceparent() });
                }
            }
            else {
                headers = { 'sentry-trace': span.toTraceparent() };
            }
            options.headers = headers;
        }
    }
    /**
     * Create and track xhr request spans
     */
    function xhrCallback(handlerData, shouldCreateSpan, spans) {
        var _a;
        var currentClientOptions = (_a = getCurrentHub()
            .getClient()) === null || _a === void 0 ? void 0 : _a.getOptions();
        if (!(currentClientOptions && hasTracingEnabled(currentClientOptions)) ||
            !(handlerData.xhr && handlerData.xhr.__sentry_xhr__ && shouldCreateSpan(handlerData.xhr.__sentry_xhr__.url)) ||
            handlerData.xhr.__sentry_own_request__) {
            return;
        }
        var xhr = handlerData.xhr.__sentry_xhr__;
        // check first if the request has finished and is tracked by an existing span which should now end
        if (handlerData.endTimestamp && handlerData.xhr.__sentry_xhr_span_id__) {
            var span = spans[handlerData.xhr.__sentry_xhr_span_id__];
            if (span) {
                span.setHttpStatus(xhr.status_code);
                span.finish();
                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                delete spans[handlerData.xhr.__sentry_xhr_span_id__];
            }
            return;
        }
        // if not, create a new span to track it
        var activeTransaction = getActiveTransaction();
        if (activeTransaction) {
            var span = activeTransaction.startChild({
                data: __assign(__assign({}, xhr.data), { type: 'xhr', method: xhr.method, url: xhr.url }),
                description: xhr.method + " " + xhr.url,
                op: 'http',
            });
            handlerData.xhr.__sentry_xhr_span_id__ = span.spanId;
            spans[handlerData.xhr.__sentry_xhr_span_id__] = span;
            if (handlerData.xhr.setRequestHeader) {
                try {
                    handlerData.xhr.setRequestHeader('sentry-trace', span.toTraceparent());
                }
                catch (_) {
                    // Error: InvalidStateError: Failed to execute 'setRequestHeader' on 'XMLHttpRequest': The object's state must be OPENED.
                }
            }
        }
    }

    var global$8 = getGlobalObject();
    /**
     * Default function implementing pageload and navigation transactions
     */
    function defaultRoutingInstrumentation(startTransaction, startTransactionOnPageLoad, startTransactionOnLocationChange) {
        if (startTransactionOnPageLoad === void 0) { startTransactionOnPageLoad = true; }
        if (startTransactionOnLocationChange === void 0) { startTransactionOnLocationChange = true; }
        if (!global$8 || !global$8.location) {
            logger.warn('Could not initialize routing instrumentation due to invalid location');
            return;
        }
        var startingUrl = global$8.location.href;
        var activeTransaction;
        if (startTransactionOnPageLoad) {
            activeTransaction = startTransaction({ name: global$8.location.pathname, op: 'pageload' });
        }
        if (startTransactionOnLocationChange) {
            addInstrumentationHandler({
                callback: function (_a) {
                    var to = _a.to, from = _a.from;
                    /**
                     * This early return is there to account for some cases where a navigation transaction starts right after
                     * long-running pageload. We make sure that if `from` is undefined and a valid `startingURL` exists, we don't
                     * create an uneccessary navigation transaction.
                     *
                     * This was hard to duplicate, but this behavior stopped as soon as this fix was applied. This issue might also
                     * only be caused in certain development environments where the usage of a hot module reloader is causing
                     * errors.
                     */
                    if (from === undefined && startingUrl && startingUrl.indexOf(to) !== -1) {
                        startingUrl = undefined;
                        return;
                    }
                    if (from !== to) {
                        startingUrl = undefined;
                        if (activeTransaction) {
                            logger.log("[Tracing] Finishing current transaction with op: " + activeTransaction.op);
                            // If there's an open transaction on the scope, we need to finish it before creating an new one.
                            activeTransaction.finish();
                        }
                        activeTransaction = startTransaction({ name: global$8.location.pathname, op: 'navigation' });
                    }
                },
                type: 'history',
            });
        }
    }

    var DEFAULT_MAX_TRANSACTION_DURATION_SECONDS = 600;
    var DEFAULT_BROWSER_TRACING_OPTIONS = __assign({ idleTimeout: DEFAULT_IDLE_TIMEOUT, markBackgroundTransactions: true, maxTransactionDuration: DEFAULT_MAX_TRANSACTION_DURATION_SECONDS, routingInstrumentation: defaultRoutingInstrumentation, startTransactionOnLocationChange: true, startTransactionOnPageLoad: true }, defaultRequestInstrumentationOptions);
    /**
     * The Browser Tracing integration automatically instruments browser pageload/navigation
     * actions as transactions, and captures requests, metrics and errors as spans.
     *
     * The integration can be configured with a variety of options, and can be extended to use
     * any routing library. This integration uses {@see IdleTransaction} to create transactions.
     */
    var BrowserTracing = /** @class */ (function () {
        function BrowserTracing(_options) {
            /**
             * @inheritDoc
             */
            this.name = BrowserTracing.id;
            this._metrics = new MetricsInstrumentation();
            this._emitOptionsWarning = false;
            var tracingOrigins = defaultRequestInstrumentationOptions.tracingOrigins;
            // NOTE: Logger doesn't work in constructors, as it's initialized after integrations instances
            if (_options &&
                _options.tracingOrigins &&
                Array.isArray(_options.tracingOrigins) &&
                _options.tracingOrigins.length !== 0) {
                tracingOrigins = _options.tracingOrigins;
            }
            else {
                this._emitOptionsWarning = true;
            }
            this.options = __assign(__assign(__assign({}, DEFAULT_BROWSER_TRACING_OPTIONS), _options), { tracingOrigins: tracingOrigins });
        }
        /**
         * @inheritDoc
         */
        BrowserTracing.prototype.setupOnce = function (_, getCurrentHub) {
            var _this = this;
            this._getCurrentHub = getCurrentHub;
            if (this._emitOptionsWarning) {
                logger.warn('[Tracing] You need to define `tracingOrigins` in the options. Set an array of urls or patterns to trace.');
                logger.warn("[Tracing] We added a reasonable default for you: " + defaultRequestInstrumentationOptions.tracingOrigins);
            }
            // eslint-disable-next-line @typescript-eslint/unbound-method
            var _a = this.options, routingInstrumentation = _a.routingInstrumentation, startTransactionOnLocationChange = _a.startTransactionOnLocationChange, startTransactionOnPageLoad = _a.startTransactionOnPageLoad, markBackgroundTransactions = _a.markBackgroundTransactions, traceFetch = _a.traceFetch, traceXHR = _a.traceXHR, tracingOrigins = _a.tracingOrigins, shouldCreateSpanForRequest = _a.shouldCreateSpanForRequest;
            routingInstrumentation(function (context) { return _this._createRouteTransaction(context); }, startTransactionOnPageLoad, startTransactionOnLocationChange);
            if (markBackgroundTransactions) {
                registerBackgroundTabDetection();
            }
            registerRequestInstrumentation({ traceFetch: traceFetch, traceXHR: traceXHR, tracingOrigins: tracingOrigins, shouldCreateSpanForRequest: shouldCreateSpanForRequest });
        };
        /** Create routing idle transaction. */
        BrowserTracing.prototype._createRouteTransaction = function (context) {
            var _this = this;
            if (!this._getCurrentHub) {
                logger.warn("[Tracing] Did not create " + context.op + " transaction because _getCurrentHub is invalid.");
                return undefined;
            }
            // eslint-disable-next-line @typescript-eslint/unbound-method
            var _a = this.options, beforeNavigate = _a.beforeNavigate, idleTimeout = _a.idleTimeout, maxTransactionDuration = _a.maxTransactionDuration;
            var parentContextFromHeader = context.op === 'pageload' ? getHeaderContext() : undefined;
            var expandedContext = __assign(__assign(__assign({}, context), parentContextFromHeader), { trimEnd: true });
            var modifiedContext = typeof beforeNavigate === 'function' ? beforeNavigate(expandedContext) : expandedContext;
            // For backwards compatibility reasons, beforeNavigate can return undefined to "drop" the transaction (prevent it
            // from being sent to Sentry).
            var finalContext = modifiedContext === undefined ? __assign(__assign({}, expandedContext), { sampled: false }) : modifiedContext;
            if (finalContext.sampled === false) {
                logger.log("[Tracing] Will not send " + finalContext.op + " transaction because of beforeNavigate.");
            }
            logger.log("[Tracing] Starting " + finalContext.op + " transaction on scope");
            var hub = this._getCurrentHub();
            var location = getGlobalObject().location;
            var idleTransaction = startIdleTransaction(hub, finalContext, idleTimeout, true, { location: location });
            idleTransaction.registerBeforeFinishCallback(function (transaction, endTimestamp) {
                _this._metrics.addPerformanceEntries(transaction);
                adjustTransactionDuration(secToMs(maxTransactionDuration), transaction, endTimestamp);
            });
            return idleTransaction;
        };
        /**
         * @inheritDoc
         */
        BrowserTracing.id = 'BrowserTracing';
        return BrowserTracing;
    }());
    /**
     * Gets transaction context from a sentry-trace meta.
     *
     * @returns Transaction context data from the header or undefined if there's no header or the header is malformed
     */
    function getHeaderContext() {
        var header = getMetaContent('sentry-trace');
        if (header) {
            return extractTraceparentData(header);
        }
        return undefined;
    }
    /** Returns the value of a meta tag */
    function getMetaContent(metaName) {
        var el = document.querySelector("meta[name=" + metaName + "]");
        return el ? el.getAttribute('content') : null;
    }
    /** Adjusts transaction value based on max transaction duration */
    function adjustTransactionDuration(maxDuration, transaction, endTimestamp) {
        var diff = endTimestamp - transaction.startTimestamp;
        var isOutdatedTransaction = endTimestamp && (diff > maxDuration || diff < 0);
        if (isOutdatedTransaction) {
            transaction.setStatus(SpanStatus.DeadlineExceeded);
            transaction.setTag('maxTransactionDurationExceeded', 'true');
        }
    }

    /**
     * Express integration
     *
     * Provides an request and error handler for Express framework as well as tracing capabilities
     */
    var Express = /** @class */ (function () {
        /**
         * @inheritDoc
         */
        function Express(options) {
            if (options === void 0) { options = {}; }
            /**
             * @inheritDoc
             */
            this.name = Express.id;
            this._router = options.router || options.app;
            this._methods = (Array.isArray(options.methods) ? options.methods : []).concat('use');
        }
        /**
         * @inheritDoc
         */
        Express.prototype.setupOnce = function () {
            if (!this._router) {
                logger.error('ExpressIntegration is missing an Express instance');
                return;
            }
            instrumentMiddlewares(this._router, this._methods);
        };
        /**
         * @inheritDoc
         */
        Express.id = 'Express';
        return Express;
    }());
    /**
     * Wraps original middleware function in a tracing call, which stores the info about the call as a span,
     * and finishes it once the middleware is done invoking.
     *
     * Express middlewares have 3 various forms, thus we have to take care of all of them:
     * // sync
     * app.use(function (req, res) { ... })
     * // async
     * app.use(function (req, res, next) { ... })
     * // error handler
     * app.use(function (err, req, res, next) { ... })
     *
     * They all internally delegate to the `router[method]` of the given application instance.
     */
    // eslint-disable-next-line @typescript-eslint/ban-types, @typescript-eslint/no-explicit-any
    function wrap$1(fn, method) {
        var arity = fn.length;
        switch (arity) {
            case 2: {
                return function (req, res) {
                    var transaction = res.__sentry_transaction;
                    if (transaction) {
                        var span_1 = transaction.startChild({
                            description: fn.name,
                            op: "middleware." + method,
                        });
                        res.once('finish', function () {
                            span_1.finish();
                        });
                    }
                    return fn.call(this, req, res);
                };
            }
            case 3: {
                return function (req, res, next) {
                    var _a;
                    var transaction = res.__sentry_transaction;
                    var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
                        description: fn.name,
                        op: "middleware." + method,
                    });
                    fn.call(this, req, res, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var _a;
                        (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                        next.call.apply(next, __spread([this], args));
                    });
                };
            }
            case 4: {
                return function (err, req, res, next) {
                    var _a;
                    var transaction = res.__sentry_transaction;
                    var span = (_a = transaction) === null || _a === void 0 ? void 0 : _a.startChild({
                        description: fn.name,
                        op: "middleware." + method,
                    });
                    fn.call(this, err, req, res, function () {
                        var args = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            args[_i] = arguments[_i];
                        }
                        var _a;
                        (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                        next.call.apply(next, __spread([this], args));
                    });
                };
            }
            default: {
                throw new Error("Express middleware takes 2-4 arguments. Got: " + arity);
            }
        }
    }
    /**
     * Takes all the function arguments passed to the original `app` or `router` method, eg. `app.use` or `router.use`
     * and wraps every function, as well as array of functions with a call to our `wrap` method.
     * We have to take care of the arrays as well as iterate over all of the arguments,
     * as `app.use` can accept middlewares in few various forms.
     *
     * app.use([<path>], <fn>)
     * app.use([<path>], <fn>, ...<fn>)
     * app.use([<path>], ...<fn>[])
     */
    function wrapMiddlewareArgs(args, method) {
        return args.map(function (arg) {
            if (typeof arg === 'function') {
                return wrap$1(arg, method);
            }
            if (Array.isArray(arg)) {
                return arg.map(function (a) {
                    if (typeof a === 'function') {
                        return wrap$1(a, method);
                    }
                    return a;
                });
            }
            return arg;
        });
    }
    /**
     * Patches original router to utilize our tracing functionality
     */
    function patchMiddleware(router, method) {
        var originalCallback = router[method];
        router[method] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return originalCallback.call.apply(originalCallback, __spread([this], wrapMiddlewareArgs(args, method)));
        };
        return router;
    }
    /**
     * Patches original router methods
     */
    function instrumentMiddlewares(router, methods) {
        if (methods === void 0) { methods = []; }
        methods.forEach(function (method) { return patchMiddleware(router, method); });
    }

    /** Tracing integration for node-postgres package */
    var Postgres = /** @class */ (function () {
        function Postgres() {
            /**
             * @inheritDoc
             */
            this.name = Postgres.id;
        }
        /**
         * @inheritDoc
         */
        Postgres.prototype.setupOnce = function (_, getCurrentHub) {
            var client;
            try {
                var pgModule = dynamicRequire(module, 'pg');
                client = pgModule.Client;
            }
            catch (e) {
                logger.error('Postgres Integration was unable to require `pg` package.');
                return;
            }
            /**
             * function (query, callback) => void
             * function (query, params, callback) => void
             * function (query) => Promise
             * function (query, params) => Promise
             */
            fill(client.prototype, 'query', function (orig) {
                return function (config, values, callback) {
                    var _a, _b;
                    var scope = getCurrentHub().getScope();
                    var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
                    var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
                        description: typeof config === 'string' ? config : config.text,
                        op: "db",
                    });
                    if (typeof callback === 'function') {
                        return orig.call(this, config, values, function (err, result) {
                            var _a;
                            (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                            callback(err, result);
                        });
                    }
                    if (typeof values === 'function') {
                        return orig.call(this, config, function (err, result) {
                            var _a;
                            (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                            values(err, result);
                        });
                    }
                    return orig.call(this, config, values).then(function (res) {
                        var _a;
                        (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                        return res;
                    });
                };
            });
        };
        /**
         * @inheritDoc
         */
        Postgres.id = 'Postgres';
        return Postgres;
    }());

    /** Tracing integration for node-mysql package */
    var Mysql = /** @class */ (function () {
        function Mysql() {
            /**
             * @inheritDoc
             */
            this.name = Mysql.id;
        }
        /**
         * @inheritDoc
         */
        Mysql.prototype.setupOnce = function (_, getCurrentHub) {
            var connection;
            try {
                // Unfortunatelly mysql is using some custom loading system and `Connection` is not exported directly.
                connection = dynamicRequire(module, 'mysql/lib/Connection.js');
            }
            catch (e) {
                logger.error('Mysql Integration was unable to require `mysql` package.');
                return;
            }
            // The original function will have one of these signatures:
            //    function (callback) => void
            //    function (options, callback) => void
            //    function (options, values, callback) => void
            fill(connection.prototype, 'query', function (orig) {
                return function (options, values, callback) {
                    var _a, _b;
                    var scope = getCurrentHub().getScope();
                    var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
                    var span = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild({
                        description: typeof options === 'string' ? options : options.sql,
                        op: "db",
                    });
                    if (typeof callback === 'function') {
                        return orig.call(this, options, values, function (err, result, fields) {
                            var _a;
                            (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                            callback(err, result, fields);
                        });
                    }
                    if (typeof values === 'function') {
                        return orig.call(this, options, function (err, result, fields) {
                            var _a;
                            (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                            values(err, result, fields);
                        });
                    }
                    return orig.call(this, options, values, callback);
                };
            });
        };
        /**
         * @inheritDoc
         */
        Mysql.id = 'Mysql';
        return Mysql;
    }());

    var OPERATIONS = [
        'aggregate',
        'bulkWrite',
        'countDocuments',
        'createIndex',
        'createIndexes',
        'deleteMany',
        'deleteOne',
        'distinct',
        'drop',
        'dropIndex',
        'dropIndexes',
        'estimatedDocumentCount',
        'find',
        'findOne',
        'findOneAndDelete',
        'findOneAndReplace',
        'findOneAndUpdate',
        'indexes',
        'indexExists',
        'indexInformation',
        'initializeOrderedBulkOp',
        'insertMany',
        'insertOne',
        'isCapped',
        'mapReduce',
        'options',
        'parallelCollectionScan',
        'rename',
        'replaceOne',
        'stats',
        'updateMany',
        'updateOne',
    ];
    // All of the operations above take `options` and `callback` as their final parameters, but some of them
    // take additional parameters as well. For those operations, this is a map of
    // { <operation name>:  [<names of additional parameters>] }, as a way to know what to call the operation's
    // positional arguments when we add them to the span's `data` object later
    var OPERATION_SIGNATURES = {
        // aggregate intentionally not included because `pipeline` arguments are too complex to serialize well
        // see https://github.com/getsentry/sentry-javascript/pull/3102
        bulkWrite: ['operations'],
        countDocuments: ['query'],
        createIndex: ['fieldOrSpec'],
        createIndexes: ['indexSpecs'],
        deleteMany: ['filter'],
        deleteOne: ['filter'],
        distinct: ['key', 'query'],
        dropIndex: ['indexName'],
        find: ['query'],
        findOne: ['query'],
        findOneAndDelete: ['filter'],
        findOneAndReplace: ['filter', 'replacement'],
        findOneAndUpdate: ['filter', 'update'],
        indexExists: ['indexes'],
        insertMany: ['docs'],
        insertOne: ['doc'],
        mapReduce: ['map', 'reduce'],
        rename: ['newName'],
        replaceOne: ['filter', 'doc'],
        updateMany: ['filter', 'update'],
        updateOne: ['filter', 'update'],
    };
    /** Tracing integration for mongo package */
    var Mongo = /** @class */ (function () {
        /**
         * @inheritDoc
         */
        function Mongo(options) {
            if (options === void 0) { options = {}; }
            /**
             * @inheritDoc
             */
            this.name = Mongo.id;
            this._operations = Array.isArray(options.operations)
                ? options.operations
                : OPERATIONS;
            this._describeOperations = 'describeOperations' in options ? options.describeOperations : true;
            this._useMongoose = !!options.useMongoose;
        }
        /**
         * @inheritDoc
         */
        Mongo.prototype.setupOnce = function (_, getCurrentHub) {
            var collection;
            var moduleName = this._useMongoose ? 'mongoose' : 'mongodb';
            try {
                var mongodbModule = dynamicRequire(module, moduleName);
                collection = mongodbModule.Collection;
            }
            catch (e) {
                logger.error("Mongo Integration was unable to require `" + moduleName + "` package.");
                return;
            }
            this._instrumentOperations(collection, this._operations, getCurrentHub);
        };
        /**
         * Patches original collection methods
         */
        Mongo.prototype._instrumentOperations = function (collection, operations, getCurrentHub) {
            var _this = this;
            operations.forEach(function (operation) { return _this._patchOperation(collection, operation, getCurrentHub); });
        };
        /**
         * Patches original collection to utilize our tracing functionality
         */
        Mongo.prototype._patchOperation = function (collection, operation, getCurrentHub) {
            if (!(operation in collection.prototype))
                return;
            var getSpanContext = this._getSpanContextFromOperationArguments.bind(this);
            fill(collection.prototype, operation, function (orig) {
                return function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var _a, _b, _c, _d;
                    var lastArg = args[args.length - 1];
                    var scope = getCurrentHub().getScope();
                    var parentSpan = (_a = scope) === null || _a === void 0 ? void 0 : _a.getSpan();
                    // Check if the operation was passed a callback. (mapReduce requires a different check, as
                    // its (non-callback) arguments can also be functions.)
                    if (typeof lastArg !== 'function' || (operation === 'mapReduce' && args.length === 2)) {
                        var span_1 = (_b = parentSpan) === null || _b === void 0 ? void 0 : _b.startChild(getSpanContext(this, operation, args));
                        var maybePromise = orig.call.apply(orig, __spread([this], args));
                        if (isThenable(maybePromise)) {
                            return maybePromise.then(function (res) {
                                var _a;
                                (_a = span_1) === null || _a === void 0 ? void 0 : _a.finish();
                                return res;
                            });
                        }
                        else {
                            (_c = span_1) === null || _c === void 0 ? void 0 : _c.finish();
                            return maybePromise;
                        }
                    }
                    var span = (_d = parentSpan) === null || _d === void 0 ? void 0 : _d.startChild(getSpanContext(this, operation, args.slice(0, -1)));
                    return orig.call.apply(orig, __spread([this], args.slice(0, -1), [function (err, result) {
                            var _a;
                            (_a = span) === null || _a === void 0 ? void 0 : _a.finish();
                            lastArg(err, result);
                        }]));
                };
            });
        };
        /**
         * Form a SpanContext based on the user input to a given operation.
         */
        Mongo.prototype._getSpanContextFromOperationArguments = function (collection, operation, args) {
            var data = {
                collectionName: collection.collectionName,
                dbName: collection.dbName,
                namespace: collection.namespace,
            };
            var spanContext = {
                op: "db",
                description: operation,
                data: data,
            };
            // If the operation takes no arguments besides `options` and `callback`, or if argument
            // collection is disabled for this operation, just return early.
            var signature = OPERATION_SIGNATURES[operation];
            var shouldDescribe = Array.isArray(this._describeOperations)
                ? this._describeOperations.includes(operation)
                : this._describeOperations;
            if (!signature || !shouldDescribe) {
                return spanContext;
            }
            try {
                // Special case for `mapReduce`, as the only one accepting functions as arguments.
                if (operation === 'mapReduce') {
                    var _a = __read(args, 2), map = _a[0], reduce = _a[1];
                    data[signature[0]] = typeof map === 'string' ? map : map.name || '<anonymous>';
                    data[signature[1]] = typeof reduce === 'string' ? reduce : reduce.name || '<anonymous>';
                }
                else {
                    for (var i = 0; i < signature.length; i++) {
                        data[signature[i]] = JSON.stringify(args[i]);
                    }
                }
            }
            catch (_oO) {
                // no-empty
            }
            return spanContext;
        };
        /**
         * @inheritDoc
         */
        Mongo.id = 'Mongo';
        return Mongo;
    }());

    var TracingIntegrations = /*#__PURE__*/Object.freeze({
        __proto__: null,
        Express: Express,
        Postgres: Postgres,
        Mysql: Mysql,
        Mongo: Mongo
    });

    var Integrations = __assign(__assign({}, TracingIntegrations), { BrowserTracing: BrowserTracing });
    // We are patching the global object with our hub extension methods
    addExtensionMethods();

    // This file replaces `index.js` in bundlers like webpack or Rollup,

    {
      // All bundlers will remove this block in the production bundle.
      if (
        typeof navigator !== 'undefined' &&
        navigator.product === 'ReactNative' &&
        typeof crypto === 'undefined'
      ) {
        throw new Error(
          'React Native does not have a built-in secure random generator. ' +
            'If you don’t need unpredictable IDs use `nanoid/non-secure`. ' +
            'For secure IDs, import `react-native-get-random-values` ' +
            'before Nano ID. If you use Expo, install `expo-random` ' +
            'and use `nanoid/async`.'
        )
      }
      if (typeof msCrypto !== 'undefined' && typeof crypto === 'undefined') {
        throw new Error(
          'Import file with `if (!window.crypto) window.crypto = window.msCrypto`' +
            ' before importing Nano ID to fix IE 11 support'
        )
      }
      if (typeof crypto === 'undefined') {
        throw new Error(
          'Your browser does not have secure random generator. ' +
            'If you don’t need unpredictable IDs, you can use nanoid/non-secure.'
        )
      }
    }

    let random = bytes => crypto.getRandomValues(new Uint8Array(bytes));

    let customRandom = (alphabet, size, getRandom) => {
      // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
      // values closer to the alphabet size. The bitmask calculates the closest
      // `2^31 - 1` number, which exceeds the alphabet size.
      // For example, the bitmask for the alphabet size 30 is 31 (00011111).
      // `Math.clz32` is not used, because it is not available in browsers.
      let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1;
      // Though, the bitmask solution is not perfect since the bytes exceeding
      // the alphabet size are refused. Therefore, to reliably generate the ID,
      // the random bytes redundancy has to be satisfied.

      // Note: every hardware random generator call is performance expensive,
      // because the system call for entropy collection takes a lot of time.
      // So, to avoid additional system calls, extra bytes are requested in advance.

      // Next, a step determines how many random bytes to generate.
      // The number of random bytes gets decided upon the ID size, mask,
      // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
      // according to benchmarks).

      // `-~f => Math.ceil(f)` if f is a float
      // `-~i => i + 1` if i is an integer
      let step = -~((1.6 * mask * size) / alphabet.length);

      return () => {
        let id = '';
        while (true) {
          let bytes = getRandom(step);
          // A compact alternative for `for (var i = 0; i < step; i++)`.
          let j = step;
          while (j--) {
            // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
            id += alphabet[bytes[j] & mask] || '';
            if (id.length === size) return id
          }
        }
      }
    };

    let customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);

    init$1({
        dsn: "https://0ed5871989214c1ea8393862f38c626f@o530304.ingest.sentry.io/5649635",
        integrations: [new Integrations.BrowserTracing()],
        tracesSampleRate: 1.0,
    });
    const alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    const nanoid = customAlphabet(alphabet, 10);


    const lang = writable("fr");
    let upColor = writable("#45B877");
    let downColor = writable("#FFFFFF");


    function createCartStore() {
        let saved = localStorage.getItem('cart') || '{}';


        try {
            saved = JSON.parse(saved);
        } catch {
            saved = {
                cartID: nanoid(),
                items: {}
            };
        }
        console.log(saved);

        if (saved.cartID == undefined) {
            saved.cartID = nanoid();
            localStorage.setItem('cart', JSON.stringify(saved));
        }
        if (saved.items == undefined) {
            saved.items = [];
        }
        console.log(saved);
        const { subscribe, set, update } = writable(saved);

        return {
            subscribe,
            set: (newV) => {
                Object.entries(newV).forEach((item) => {
                    if (item.quantity == undefined) {
                        item.quantity = 1;
                    }
                });
                localStorage.setItem('cart', JSON.stringify(newV));

                set(newV);
            },
            add: (newV) => {
                update((oldV) => {
                    oldV.items = {...oldV.items, ...newV };
                    Object.entries(oldV.items).forEach((item) => {
                        if (item.quantity == undefined) {
                            item.quantity = 1;
                        }
                    });
                    localStorage.setItem('cart', JSON.stringify(oldV));
                    return oldV
                });
            },
            remove: (key) => {
                update((oldV) => {
                    if (oldV.items[key]) {
                        delete oldV.items[key];
                    }
                    localStorage.setItem('cart', JSON.stringify(oldV));
                    return oldV
                });
            },
            reset: () => {
                localStorage.setItem('cart', JSON.stringify({}));
                set({
                    cartID: nanoid(),
                    items: []
                });
            }

        };
    }

    const cart = createCartStore();

    /* src\routes\LandingPage.svelte generated by Svelte v3.32.3 */
    const file$1 = "src\\routes\\LandingPage.svelte";

    function create_fragment$4(ctx) {
    	let header;
    	let div4;
    	let div3;

    	let t0_value = ({
    		en: "Tools for Gamers.",
    		fr: "Outils pour Gamers. "
    	})[/*$lang*/ ctx[0]] + "";

    	let t0;
    	let br;
    	let t1;

    	let t2_value = ({
    		en: "Creators. Brands.",
    		fr: "Createurs. Brands."
    	})[/*$lang*/ ctx[0]] + "";

    	let t2;
    	let t3;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t4;
    	let img1;
    	let img1_src_value;
    	let t5;
    	let img2;
    	let img2_src_value;
    	let t6;
    	let img3;
    	let img3_src_value;
    	let t7;
    	let img4;
    	let img4_src_value;
    	let t8;
    	let div1;

    	let t9_value = ({
    		en: "Design and sell branded merch",
    		fr: "Conception et vente de marchandise"
    	})[/*$lang*/ ctx[0]] + "";

    	let t9;
    	let t10;
    	let div2;
    	let button0;
    	let a0;

    	let t11_value = ({
    		en: "Get Started Now",
    		fr: "Commencez maintenant"
    	})[/*$lang*/ ctx[0]] + "";

    	let t11;
    	let t12;
    	let div9;
    	let div7;
    	let div6;
    	let div5;
    	let t13_value = ({ en: "Start", fr: "Commencez" })[/*$lang*/ ctx[0]] + "";
    	let t13;
    	let t14;
    	let span0;
    	let t15_value = ({ en: "Generating", fr: "À Générer" })[/*$lang*/ ctx[0]] + "";
    	let t15;
    	let t16;
    	let t17_value = ({ en: "Revenues", fr: "Des Revenus" })[/*$lang*/ ctx[0]] + "";
    	let t17;
    	let t18;
    	let p;

    	let t19_value = ({
    		en: "From Your Hobby",
    		fr: " à Partir De Votre Passion"
    	})[/*$lang*/ ctx[0]] + "";

    	let t19;
    	let t20;
    	let div8;
    	let img5;
    	let img5_src_value;
    	let t21;
    	let img6;
    	let img6_src_value;
    	let t22;
    	let img7;
    	let img7_src_value;
    	let t23;
    	let img8;
    	let img8_src_value;
    	let t24;
    	let img9;
    	let img9_src_value;
    	let t25;
    	let div15;
    	let div13;
    	let div10;

    	let t26_value = ({
    		en: "Start Selling Your",
    		fr: "Commencez à Vendre Votre"
    	})[/*$lang*/ ctx[0]] + "";

    	let t26;
    	let t27;
    	let span1;
    	let t28_value = ({ en: "Customized", fr: "Marchandise" })[/*$lang*/ ctx[0]] + "";
    	let t28;
    	let t29;

    	let t30_value = ({
    		en: "Merch Online",
    		fr: "Personnalisée En Ligne"
    	})[/*$lang*/ ctx[0]] + "";

    	let t30;
    	let t31;
    	let div12;

    	let t32_value = ({
    		en: " We handle it all from printing to support.",
    		fr: "Nous nous occupons de tout, de l'impression et la livraison au support client."
    	})[/*$lang*/ ctx[0]] + "";

    	let t32;
    	let t33;
    	let div11;

    	let t34_value = ({
    		en: "focus on your hobby. we'll take care of the printing, shipping,customer support and more.",
    		fr: "Concentrez-vous sur votre passion. nous nous occuperons de l'impression, de l'expédition, du support client et plus."
    	})[/*$lang*/ ctx[0]] + "";

    	let t34;
    	let t35;
    	let button1;
    	let a1;

    	let t36_value = ({
    		en: "Start Now",
    		fr: "Démarrez Maintenant"
    	})[/*$lang*/ ctx[0]] + "";

    	let t36;
    	let t37;
    	let div14;
    	let img10;
    	let img10_src_value;

    	const block = {
    		c: function create() {
    			header = element("header");
    			div4 = element("div");
    			div3 = element("div");
    			t0 = text(t0_value);
    			br = element("br");
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			div0 = element("div");
    			img0 = element("img");
    			t4 = space();
    			img1 = element("img");
    			t5 = space();
    			img2 = element("img");
    			t6 = space();
    			img3 = element("img");
    			t7 = space();
    			img4 = element("img");
    			t8 = space();
    			div1 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			div2 = element("div");
    			button0 = element("button");
    			a0 = element("a");
    			t11 = text(t11_value);
    			t12 = space();
    			div9 = element("div");
    			div7 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			t13 = text(t13_value);
    			t14 = space();
    			span0 = element("span");
    			t15 = text(t15_value);
    			t16 = space();
    			t17 = text(t17_value);
    			t18 = space();
    			p = element("p");
    			t19 = text(t19_value);
    			t20 = space();
    			div8 = element("div");
    			img5 = element("img");
    			t21 = space();
    			img6 = element("img");
    			t22 = space();
    			img7 = element("img");
    			t23 = space();
    			img8 = element("img");
    			t24 = space();
    			img9 = element("img");
    			t25 = space();
    			div15 = element("div");
    			div13 = element("div");
    			div10 = element("div");
    			t26 = text(t26_value);
    			t27 = space();
    			span1 = element("span");
    			t28 = text(t28_value);
    			t29 = space();
    			t30 = text(t30_value);
    			t31 = space();
    			div12 = element("div");
    			t32 = text(t32_value);
    			t33 = space();
    			div11 = element("div");
    			t34 = text(t34_value);
    			t35 = space();
    			button1 = element("button");
    			a1 = element("a");
    			t36 = text(t36_value);
    			t37 = space();
    			div14 = element("div");
    			img10 = element("img");
    			add_location(br, file$1, 373, 76, 8700);
    			if (img0.src !== (img0_src_value = "/img/socialMedia/instagram_colored.svg")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "instagram");
    			attr_dev(img0, "class", "instagram svelte-f4kv9m");
    			add_location(img0, file$1, 377, 12, 8913);
    			if (img1.src !== (img1_src_value = "/img/socialMedia/twitch_colored.svg")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "twitch");
    			attr_dev(img1, "class", "twitch svelte-f4kv9m");
    			add_location(img1, file$1, 378, 12, 9013);
    			if (img2.src !== (img2_src_value = "/img/socialMedia/youtube_colored.svg")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "yt");
    			attr_dev(img2, "class", "svelte-f4kv9m");
    			add_location(img2, file$1, 379, 12, 9104);
    			if (img3.src !== (img3_src_value = "/img/socialMedia/facebook_colored.svg")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "fb");
    			attr_dev(img3, "class", "fb svelte-f4kv9m");
    			add_location(img3, file$1, 380, 12, 9177);
    			if (img4.src !== (img4_src_value = "/img/socialMedia/nimo_colored.svg")) attr_dev(img4, "src", img4_src_value);
    			attr_dev(img4, "alt", "nimo");
    			attr_dev(img4, "class", "svelte-f4kv9m");
    			add_location(img4, file$1, 381, 12, 9262);
    			attr_dev(div0, "class", "socialMedia part_two svelte-f4kv9m");
    			attr_dev(div0, "data-aos", "fade-right");
    			attr_dev(div0, "data-aos-delay", "800");
    			attr_dev(div0, "data-aos-duration", "1000");
    			add_location(div0, file$1, 376, 12, 8796);
    			attr_dev(div1, "class", "sub_title svelte-f4kv9m");
    			attr_dev(div1, "data-aos", "fade-right");
    			attr_dev(div1, "data-aos-delay", "400");
    			attr_dev(div1, "data-aos-duration", "1000");
    			add_location(div1, file$1, 384, 12, 9356);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", "https://creator.unify.tn/register");
    			attr_dev(a0, "class", "svelte-f4kv9m");
    			add_location(a0, file$1, 389, 20, 9719);
    			attr_dev(button0, "class", "btn svelte-f4kv9m");
    			attr_dev(button0, "data-aos", "fade-up");
    			attr_dev(button0, "data-aos-delay", "1000");
    			attr_dev(button0, "data-aos-duration", "600");
    			add_location(button0, file$1, 388, 16, 9612);
    			attr_dev(div2, "class", "get_started_btn svelte-f4kv9m");
    			add_location(div2, file$1, 387, 12, 9565);
    			attr_dev(div3, "class", "title svelte-f4kv9m");
    			attr_dev(div3, "data-aos", "fade-right");
    			attr_dev(div3, "data-aos-duration", "1000");
    			add_location(div3, file$1, 372, 8, 8556);
    			attr_dev(div4, "class", "left_part svelte-f4kv9m");
    			add_location(div4, file$1, 371, 4, 8523);
    			attr_dev(header, "class", "svelte-f4kv9m");
    			add_location(header, file$1, 370, 0, 8509);
    			set_style(span0, "color", "#00CE7C", 1);
    			add_location(span0, file$1, 406, 16, 10360);
    			attr_dev(div5, "class", "div_p svelte-f4kv9m");
    			add_location(div5, file$1, 404, 12, 10264);
    			set_style(p, "color", "#747474", 1);
    			attr_dev(p, "class", "div_sub svelte-f4kv9m");
    			add_location(p, file$1, 410, 12, 10552);
    			attr_dev(div6, "class", "paragraph svelte-f4kv9m");
    			add_location(div6, file$1, 403, 8, 10227);
    			attr_dev(div7, "class", "part_one svelte-f4kv9m");
    			add_location(div7, file$1, 402, 4, 10195);
    			if (img5.src !== (img5_src_value = "/img/socialMedia/youtube_colored.svg")) attr_dev(img5, "src", img5_src_value);
    			attr_dev(img5, "alt", "yt");
    			attr_dev(img5, "class", "svelte-f4kv9m");
    			add_location(img5, file$1, 414, 8, 10773);
    			if (img6.src !== (img6_src_value = "/img/socialMedia/twitch_colored.svg")) attr_dev(img6, "src", img6_src_value);
    			attr_dev(img6, "alt", "twitch");
    			attr_dev(img6, "class", "svelte-f4kv9m");
    			add_location(img6, file$1, 415, 8, 10842);
    			if (img7.src !== (img7_src_value = "/img/socialMedia/facebook_colored.svg")) attr_dev(img7, "src", img7_src_value);
    			attr_dev(img7, "alt", "fb");
    			attr_dev(img7, "class", "svelte-f4kv9m");
    			add_location(img7, file$1, 416, 8, 10914);
    			if (img8.src !== (img8_src_value = "/img/socialMedia/instagram_colored.svg")) attr_dev(img8, "src", img8_src_value);
    			attr_dev(img8, "alt", "instagram");
    			attr_dev(img8, "class", "svelte-f4kv9m");
    			add_location(img8, file$1, 417, 8, 10984);
    			if (img9.src !== (img9_src_value = "/img/socialMedia/nimo_colored.svg")) attr_dev(img9, "src", img9_src_value);
    			attr_dev(img9, "alt", "nimo");
    			attr_dev(img9, "class", "svelte-f4kv9m");
    			add_location(img9, file$1, 418, 8, 11062);
    			attr_dev(div8, "class", "socialMedia part_two svelte-f4kv9m");
    			attr_dev(div8, "data-aos", "fade-up");
    			add_location(div8, file$1, 413, 4, 10710);
    			attr_dev(div9, "class", "section1 svelte-f4kv9m");
    			add_location(div9, file$1, 401, 0, 10167);
    			set_style(span1, "color", "#00CE7C", 1);
    			add_location(span1, file$1, 429, 12, 11393);
    			attr_dev(div10, "class", "title svelte-f4kv9m");
    			add_location(div10, file$1, 426, 8, 11263);
    			attr_dev(div11, "class", "svelte-f4kv9m");
    			add_location(div11, file$1, 435, 12, 11800);
    			attr_dev(div12, "class", "paragraph svelte-f4kv9m");
    			add_location(div12, file$1, 432, 8, 11588);
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", "https://creator.unify.tn/register");
    			attr_dev(a1, "class", "svelte-f4kv9m");
    			add_location(a1, file$1, 443, 16, 12176);
    			attr_dev(button1, "class", "svelte-f4kv9m");
    			add_location(button1, file$1, 443, 8, 12168);
    			attr_dev(div13, "class", "part_one svelte-f4kv9m");
    			add_location(div13, file$1, 425, 4, 11231);
    			if (img10.src !== (img10_src_value = "/img/section2.png")) attr_dev(img10, "src", img10_src_value);
    			attr_dev(img10, "alt", "section2");
    			attr_dev(img10, "class", "svelte-f4kv9m");
    			add_location(img10, file$1, 449, 48, 12433);
    			attr_dev(div14, "class", "part_two svelte-f4kv9m");
    			attr_dev(div14, "data-aos", "fade-right");
    			add_location(div14, file$1, 449, 4, 12389);
    			attr_dev(div15, "class", "section2 svelte-f4kv9m");
    			add_location(div15, file$1, 424, 0, 11203);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, div4);
    			append_dev(div4, div3);
    			append_dev(div3, t0);
    			append_dev(div3, br);
    			append_dev(div3, t1);
    			append_dev(div3, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div0);
    			append_dev(div0, img0);
    			append_dev(div0, t4);
    			append_dev(div0, img1);
    			append_dev(div0, t5);
    			append_dev(div0, img2);
    			append_dev(div0, t6);
    			append_dev(div0, img3);
    			append_dev(div0, t7);
    			append_dev(div0, img4);
    			append_dev(div3, t8);
    			append_dev(div3, div1);
    			append_dev(div1, t9);
    			append_dev(div3, t10);
    			append_dev(div3, div2);
    			append_dev(div2, button0);
    			append_dev(button0, a0);
    			append_dev(a0, t11);
    			insert_dev(target, t12, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div7);
    			append_dev(div7, div6);
    			append_dev(div6, div5);
    			append_dev(div5, t13);
    			append_dev(div5, t14);
    			append_dev(div5, span0);
    			append_dev(span0, t15);
    			append_dev(div5, t16);
    			append_dev(div5, t17);
    			append_dev(div6, t18);
    			append_dev(div6, p);
    			append_dev(p, t19);
    			append_dev(div9, t20);
    			append_dev(div9, div8);
    			append_dev(div8, img5);
    			append_dev(div8, t21);
    			append_dev(div8, img6);
    			append_dev(div8, t22);
    			append_dev(div8, img7);
    			append_dev(div8, t23);
    			append_dev(div8, img8);
    			append_dev(div8, t24);
    			append_dev(div8, img9);
    			insert_dev(target, t25, anchor);
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div13);
    			append_dev(div13, div10);
    			append_dev(div10, t26);
    			append_dev(div10, t27);
    			append_dev(div10, span1);
    			append_dev(span1, t28);
    			append_dev(div10, t29);
    			append_dev(div10, t30);
    			append_dev(div13, t31);
    			append_dev(div13, div12);
    			append_dev(div12, t32);
    			append_dev(div12, t33);
    			append_dev(div12, div11);
    			append_dev(div11, t34);
    			append_dev(div13, t35);
    			append_dev(div13, button1);
    			append_dev(button1, a1);
    			append_dev(a1, t36);
    			append_dev(div15, t37);
    			append_dev(div15, div14);
    			append_dev(div14, img10);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$lang*/ 1 && t0_value !== (t0_value = ({
    				en: "Tools for Gamers.",
    				fr: "Outils pour Gamers. "
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$lang*/ 1 && t2_value !== (t2_value = ({
    				en: "Creators. Brands.",
    				fr: "Createurs. Brands."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*$lang*/ 1 && t9_value !== (t9_value = ({
    				en: "Design and sell branded merch",
    				fr: "Conception et vente de marchandise"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*$lang*/ 1 && t11_value !== (t11_value = ({
    				en: "Get Started Now",
    				fr: "Commencez maintenant"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t11, t11_value);

    			if (dirty & /*$lang*/ 1 && t13_value !== (t13_value = ({ en: "Start", fr: "Commencez" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t13, t13_value);
    			if (dirty & /*$lang*/ 1 && t15_value !== (t15_value = ({ en: "Generating", fr: "À Générer" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t15, t15_value);
    			if (dirty & /*$lang*/ 1 && t17_value !== (t17_value = ({ en: "Revenues", fr: "Des Revenus" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*$lang*/ 1 && t19_value !== (t19_value = ({
    				en: "From Your Hobby",
    				fr: " à Partir De Votre Passion"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t19, t19_value);

    			if (dirty & /*$lang*/ 1 && t26_value !== (t26_value = ({
    				en: "Start Selling Your",
    				fr: "Commencez à Vendre Votre"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t26, t26_value);

    			if (dirty & /*$lang*/ 1 && t28_value !== (t28_value = ({ en: "Customized", fr: "Marchandise" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t28, t28_value);

    			if (dirty & /*$lang*/ 1 && t30_value !== (t30_value = ({
    				en: "Merch Online",
    				fr: "Personnalisée En Ligne"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t30, t30_value);

    			if (dirty & /*$lang*/ 1 && t32_value !== (t32_value = ({
    				en: " We handle it all from printing to support.",
    				fr: "Nous nous occupons de tout, de l'impression et la livraison au support client."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t32, t32_value);

    			if (dirty & /*$lang*/ 1 && t34_value !== (t34_value = ({
    				en: "focus on your hobby. we'll take care of the printing, shipping,customer support and more.",
    				fr: "Concentrez-vous sur votre passion. nous nous occuperons de l'impression, de l'expédition, du support client et plus."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t34, t34_value);

    			if (dirty & /*$lang*/ 1 && t36_value !== (t36_value = ({
    				en: "Start Now",
    				fr: "Démarrez Maintenant"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t36, t36_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if (detaching) detach_dev(t12);
    			if (detaching) detach_dev(div9);
    			if (detaching) detach_dev(t25);
    			if (detaching) detach_dev(div15);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(0, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("LandingPage", slots, []);
    	let { params = {} } = $$props;
    	document.title = "Unify";

    	onMount(async () => {
    		AOS__default['default'].init();
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LandingPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ onMount, AOS: AOS__default['default'], lang, params, $lang });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$lang, params];
    }

    class LandingPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, { params: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LandingPage",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get params() {
    		throw new Error("<LandingPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<LandingPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const firebaseConfig = {
        apiKey: "AIzaSyDucnhtBFM0HOg8dxk3lUIRcV8pHmifzXc",
        authDomain: "unify-tn.firebaseapp.com",
        databaseURL: "https://unify-tn.firebaseio.com",
        projectId: "unify-tn",
        storageBucket: "unify-tn.appspot.com",
        messagingSenderId: "393516846997",
        appId: "1:393516846997:web:616a0b2f63d1ab7d82b09c",
        measurementId: "G-RL31WXNRB9"
    };

    firebase.initializeApp(firebaseConfig);
    const analytics = firebase.analytics();
    analytics.logEvent('front-initialized');
    const auth = firebase.auth();
    const db = firebase.firestore();
        /* 0 => uninitialized 
            undefined => there is no user logged in
            else (object) => user logged in
        */
    const user = writable(0);
    auth.onAuthStateChanged(async function(kuser) {
        if (kuser) {

            console.log(kuser);
            kuser.docData = (await db.collection('users').doc(kuser.uid).get()).data() || {};
            user.set(kuser);
        } else {
            // No user is signed in.
            console.log('no user');
            user.set(undefined);
        }
    });

    let cacheHours = 0;
    class FirebaseDBWrapper {
        constructor(db) {
            this.db = db;
            this.activeListeners = {};


        }

        async get(path, fresh = false, showCached = false) {
            if (fresh) {
                console.log(path);
                let doc = await this.db.doc(path).get();
                let docData = doc.data();
                console.log(docData);
                    //console.log(docData)
                    //console.log(path)
                if (docData) {
                    let writing = {
                        data: docData,
                        timestamp: Date.now() / 1000
                    };
                    localStorage.setItem(path, JSON.stringify(writing));
                        //console.log("serving from db and saving")
                    return showCached ? {...docData, fromCache: false } : docData
                } else {
                    localStorage.setItem(path, JSON.stringify({}));
                    return {}
                }
            }
            let lData = localStorage.getItem(path);
            if (lData != null) {
                /* if we have cached data send it */
                let pData = JSON.parse(lData);
                if (pData.data) {
                    if (((Date.now() / 1000) - pData.timestamp) < cacheHours * 3600) {
                        console.log("serving from localStorage for " + path);
                        return showCached ? {...pData.data, fromCache: true } : pData.data
                    }
                } else {
                    //console.log(path + " is unavaiable")
                    return {}
                }


            }
            /* no cache, read from db then cache */
            let doc = await this.db.doc(path).get();
            let docData = doc.data();

            //console.log(docData)
            //console.log(path)
            if (docData) {
                let writing = {
                    data: docData,
                    timestamp: Date.now() / 1000
                };
                console.log("from db for " + path);
                localStorage.setItem(path, JSON.stringify(writing));
                    //console.log("serving from db and saving")
                return showCached ? {...docData, fromCache: false } : docData
            } else {
                localStorage.setItem(path, JSON.stringify({}));
            }


            /* code should never reach here */
            console.warn("no documents in path " + path);
            return {}


        }



        onsnapshot(path) {
            /* we are here making sure that each path has only ONE active firebase connection */

            if (this.activeListeners[path] != undefined) {

                this.activeListeners[path]['hasListener'] = true;
                    /* if we have an active listening store 
                        return that store
                    */


                return this.activeListeners[path]['store']
            } else {
                /* create a read only store cause we'll be just listening for new 
                docs no need for writing to the store externally
                */


                const activeListeners = this.activeListeners;
                const db = this.db;
                activeListeners[path] = {};
                activeListeners[path]['hasListener'] = true;
                activeListeners[path]['emits'] = 0;
                let unsubscribe = () => console.log("store unsubscribe from store.js uniti");
                const resp = readable(undefined, function start(set) {





                    if (!activeListeners[path]['listening']) {
                        activeListeners[path]['listening'] = true;
                        unsubscribe = db.doc(path).onSnapshot(function(xdoc) {


                            activeListeners[path]['emits']++;
                                set(xdoc);
                        });
                    }


                    return function stop() {

                        activeListeners[path]['hasListener'] = false;

                        setTimeout(() => {

                            if (activeListeners[path]['hasListener'] == true) {

                                return
                            }

                            unsubscribe();
                            delete activeListeners[path];
                        }, 4000);

                    };
                });
                activeListeners[path]['store'] = resp;

                return activeListeners[path]['store']
            }
        }

    }

    const dbWrapper = new FirebaseDBWrapper(db);

    /* src\routes\ProfilePage.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1, console: console_1 } = globals;

    function create_fragment$5(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ProfilePage", slots, []);
    	let { params } = $$props;

    	onMount(async () => {
    		console.log("mounted");
    		let data = await dbWrapper.get("/creators/" + params.userid);

    		if (Object.keys(data).length == 0) {
    			console.log("homepage send");
    			navigate("/");
    		} else {
    			console.log("sending");
    			navigate("/" + params.userid + "/merch", { replace: true });
    		}
    	});

    	const writable_props = ["params"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<ProfilePage> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({ navigate, onMount, dbWrapper, params });

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params];
    }

    class ProfilePage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ProfilePage",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[0] === undefined && !("params" in props)) {
    			console_1.warn("<ProfilePage> was created without expected prop 'params'");
    		}
    	}

    	get params() {
    		throw new Error("<ProfilePage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<ProfilePage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    class Color {
        constructor(r, g, b) {
            this.set(r, g, b);
        }

        toString() {
            return `rgb(${Math.round(this.r)}, ${Math.round(this.g)}, ${Math.round(this.b)})`;
        }

        set(r, g, b) {
            this.r = this.clamp(r);
            this.g = this.clamp(g);
            this.b = this.clamp(b);
        }

        hueRotate(angle = 0) {
            angle = angle / 180 * Math.PI;
            const sin = Math.sin(angle);
            const cos = Math.cos(angle);

            this.multiply([
                0.213 + cos * 0.787 - sin * 0.213,
                0.715 - cos * 0.715 - sin * 0.715,
                0.072 - cos * 0.072 + sin * 0.928,
                0.213 - cos * 0.213 + sin * 0.143,
                0.715 + cos * 0.285 + sin * 0.140,
                0.072 - cos * 0.072 - sin * 0.283,
                0.213 - cos * 0.213 - sin * 0.787,
                0.715 - cos * 0.715 + sin * 0.715,
                0.072 + cos * 0.928 + sin * 0.072,
            ]);
        }

        grayscale(value = 1) {
            this.multiply([
                0.2126 + 0.7874 * (1 - value),
                0.7152 - 0.7152 * (1 - value),
                0.0722 - 0.0722 * (1 - value),
                0.2126 - 0.2126 * (1 - value),
                0.7152 + 0.2848 * (1 - value),
                0.0722 - 0.0722 * (1 - value),
                0.2126 - 0.2126 * (1 - value),
                0.7152 - 0.7152 * (1 - value),
                0.0722 + 0.9278 * (1 - value),
            ]);
        }
        sepia(value = 1) {
            this.multiply([
                0.393 + 0.607 * (1 - value),
                0.769 - 0.769 * (1 - value),
                0.189 - 0.189 * (1 - value),
                0.349 - 0.349 * (1 - value),
                0.686 + 0.314 * (1 - value),
                0.168 - 0.168 * (1 - value),
                0.272 - 0.272 * (1 - value),
                0.534 - 0.534 * (1 - value),
                0.131 + 0.869 * (1 - value),
            ]);
        }

        saturate(value = 1) {
            this.multiply([
                0.213 + 0.787 * value,
                0.715 - 0.715 * value,
                0.072 - 0.072 * value,
                0.213 - 0.213 * value,
                0.715 + 0.285 * value,
                0.072 - 0.072 * value,
                0.213 - 0.213 * value,
                0.715 - 0.715 * value,
                0.072 + 0.928 * value,
            ]);
        }

        multiply(matrix) {
            const newR = this.clamp(this.r * matrix[0] + this.g * matrix[1] + this.b * matrix[2]);
            const newG = this.clamp(this.r * matrix[3] + this.g * matrix[4] + this.b * matrix[5]);
            const newB = this.clamp(this.r * matrix[6] + this.g * matrix[7] + this.b * matrix[8]);
            this.r = newR;
            this.g = newG;
            this.b = newB;
        }

        brightness(value = 1) {
            this.linear(value);
        }
        contrast(value = 1) {
            this.linear(value, -(0.5 * value) + 0.5);
        }

        linear(slope = 1, intercept = 0) {
            this.r = this.clamp(this.r * slope + intercept * 255);
            this.g = this.clamp(this.g * slope + intercept * 255);
            this.b = this.clamp(this.b * slope + intercept * 255);
        }

        invert(value = 1) {
            this.r = this.clamp((value + this.r / 255 * (1 - 2 * value)) * 255);
            this.g = this.clamp((value + this.g / 255 * (1 - 2 * value)) * 255);
            this.b = this.clamp((value + this.b / 255 * (1 - 2 * value)) * 255);
        }

        hsl() {
            // Code taken from https://stackoverflow.com/a/9493060/2688027, licensed under CC BY-SA.
            const r = this.r / 255;
            const g = this.g / 255;
            const b = this.b / 255;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;

            if (max === min) {
                h = s = 0;
            } else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;

                    case g:
                        h = (b - r) / d + 2;
                        break;

                    case b:
                        h = (r - g) / d + 4;
                        break;
                }
                h /= 6;
            }

            return {
                h: h * 100,
                s: s * 100,
                l: l * 100,
            };
        }

        clamp(value) {
            if (value > 255) {
                value = 255;
            } else if (value < 0) {
                value = 0;
            }
            return value;
        }
    }

    class Solver {
        constructor(target, baseColor) {
            this.target = target;
            this.targetHSL = target.hsl();
            this.reusedColor = new Color(0, 0, 0);
        }

        solve() {
            const result = this.solveNarrow(this.solveWide());
            return {
                values: result.values,
                loss: result.loss,
                filter: this.css(result.values),
            };
        }

        solveWide() {
            const A = 5;
            const c = 15;
            const a = [60, 180, 18000, 600, 1.2, 1.2];

            let best = { loss: Infinity };
            for (let i = 0; best.loss > 25 && i < 3; i++) {
                const initial = [50, 20, 3750, 50, 100, 100];
                const result = this.spsa(A, a, c, initial, 1000);
                if (result.loss < best.loss) {
                    best = result;
                }
            }
            return best;
        }

        solveNarrow(wide) {
            const A = wide.loss;
            const c = 2;
            const A1 = A + 1;
            const a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];
            return this.spsa(A, a, c, wide.values, 500);
        }

        spsa(A, a, c, values, iters) {
            const alpha = 1;
            const gamma = 0.16666666666666666;

            let best = null;
            let bestLoss = Infinity;
            const deltas = new Array(6);
            const highArgs = new Array(6);
            const lowArgs = new Array(6);

            for (let k = 0; k < iters; k++) {
                const ck = c / Math.pow(k + 1, gamma);
                for (let i = 0; i < 6; i++) {
                    deltas[i] = Math.random() > 0.5 ? 1 : -1;
                    highArgs[i] = values[i] + ck * deltas[i];
                    lowArgs[i] = values[i] - ck * deltas[i];
                }

                const lossDiff = this.loss(highArgs) - this.loss(lowArgs);
                for (let i = 0; i < 6; i++) {
                    const g = lossDiff / (2 * ck) * deltas[i];
                    const ak = a[i] / Math.pow(A + k + 1, alpha);
                    values[i] = fix(values[i] - ak * g, i);
                }

                const loss = this.loss(values);
                if (loss < bestLoss) {
                    best = values.slice(0);
                    bestLoss = loss;
                }
            }
            return { values: best, loss: bestLoss };

            function fix(value, idx) {
                let max = 100;
                if (idx === 2 /* saturate */) {
                    max = 7500;
                } else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {
                    max = 200;
                }

                if (idx === 3 /* hue-rotate */) {
                    if (value > max) {
                        value %= max;
                    } else if (value < 0) {
                        value = max + value % max;
                    }
                } else if (value < 0) {
                    value = 0;
                } else if (value > max) {
                    value = max;
                }
                return value;
            }
        }

        loss(filters) {
            // Argument is array of percentages.
            const color = this.reusedColor;
            color.set(0, 0, 0);

            color.invert(filters[0] / 100);
            color.sepia(filters[1] / 100);
            color.saturate(filters[2] / 100);
            color.hueRotate(filters[3] * 3.6);
            color.brightness(filters[4] / 100);
            color.contrast(filters[5] / 100);

            const colorHSL = color.hsl();
            return (
                Math.abs(color.r - this.target.r) +
                Math.abs(color.g - this.target.g) +
                Math.abs(color.b - this.target.b) +
                Math.abs(colorHSL.h - this.targetHSL.h) +
                Math.abs(colorHSL.s - this.targetHSL.s) +
                Math.abs(colorHSL.l - this.targetHSL.l)
            );
        }

        css(filters) {
            function fmt(idx, multiplier = 1) {
                return Math.round(filters[idx] * multiplier);
            }
            return `filter: invert(${fmt(0)}%) sepia(${fmt(1)}%) saturate(${fmt(2)}%) hue-rotate(${fmt(3, 3.6)}deg) brightness(${fmt(4)}%) contrast(${fmt(5)}%);`;
        }
    }

    const hexToRgb= (hex) => {
        // Expand shorthand form (e.g. "03F") to full form (e.g. "0033FF")
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (m, r, g, b) => {
            return r + r + g + g + b + b;
        });

        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result
            ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16),
            ]
            : null;
    };


    const convert = (hex) => {
            let rgb = hexToRgb(hex);
            

            const color = new Color(rgb[0], rgb[1], rgb[2]);
            const solver = new Solver(color);
            const result = solver.solve();
            if (result.loss < 1) ; else if (result.loss < 5) ; else if (result.loss < 15) ; else ;
            /*
            $('.realPixel').css('background-color', color.toString());
            $('.filterPixel').attr('style', result.filter);
            $('.filterDetail').text(result.filter);
            $('.lossDetail').html(`Loss: ${result.loss.toFixed(1)}. <b>${lossMsg}</b>`);
            */
            return result.filter
        };

    const itemBaseStorageLink = "https://firebasestorage.googleapis.com/v0/b/unify-tn.appspot.com/o/";

    const uuidToImageLink = (uuid, path) => {
        return itemBaseStorageLink + encodeURIComponent(path) + "?alt=media&token=" + uuid
    };
    const socialMedias = [
        { type: 'facebook' },
        { type: 'youtube' },
        { type: 'instagram' },
        { type: 'twitch' },
        { type: 'nimo' },
        { type: 'twitter' },
        { type: 'Tiktok' },
        { type: 'baaz' },
        { type: 'pinterest' }
    ];

    const colors = {
        "black": "#000000",
        "grey": "#e5e5e5",
        "red": "#941E1E",
        "white": "#ffffff",
        "green": "#3B922D"
    };
    const textToHex = (text) => {


        if (colors[text.toLowerCase()] != undefined) {
            return colors[text.toLowerCase()]
        }
        return colors["black"]
    };
    const notification = writable(0);

    const urlPostReq = async(url, xdata) => {
        let data = JSON.parse(JSON.stringify(xdata));
        const headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            "Access-Control-Origin": "*"
        };
        Object.entries(data).forEach(([key, value]) => {
            if (typeof value === 'object' && value !== null) {
                data[key] = JSON.stringify(value);
            }
        });
        console.log(data);
        console.log(data.cart.items);
        let resp = await fetch(url, {
            method: "POST",
            headers: headers,
            mode: 'cors',
            body: new URLSearchParams(data)
        });
        return resp
    };

    const generateDeliveryDate = () => {
        let d = new Date();
        const date = new Date(d.getFullYear(), d.getMonth(), d.getDate(), 0, 0, 0);
        let todayUnix = date.getTime() / 1000;
        let minWaitDays = 5;
        let maxWaitDays = minWaitDays + 3;
        const minWaitStamp = todayUnix + minWaitDays * 3600 * 24;
        const minDate = new Date(minWaitStamp * 1000);
        const maxWaitStamp = todayUnix + maxWaitDays * 3600 * 24;
        const maxDate = new Date(maxWaitStamp * 1000);

        let days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
        let months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        let minFormat = String(days[minDate.getDay()] + " " + minDate.getDate() + " " + months[minDate.getMonth()]);
        let maxFormat = String(days[maxDate.getDay()] + " " + maxDate.getDate() + " " + months[minDate.getMonth()]);

        return [minFormat, maxFormat]
    };

    const getBackurl = () => {
        let params = new URLSearchParams(location.search);
        if (params.get('backurl')) {
            return params.get('backurl')
        } else {
            return ""
        }
    };

    /* src\components\SingleProductPage\singleProduct.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$1, console: console_1$1 } = globals;
    const file$2 = "src\\components\\SingleProductPage\\singleProduct.svelte";

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[51] = list[i];
    	return child_ctx;
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[51] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[56] = list[i];
    	return child_ctx;
    }

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[59] = list[i][0];
    	child_ctx[60] = list[i][1];
    	return child_ctx;
    }

    // (731:0) {#if validated}
    function create_if_block$1(ctx) {
    	let div17;
    	let div16;
    	let div4;
    	let div2;
    	let svg0;
    	let defs;
    	let style;
    	let t0;
    	let linearGradient;
    	let stop0;
    	let stop1;
    	let stop2;
    	let stop3;
    	let stop4;
    	let filter_1;
    	let feFlood;
    	let feComposite;
    	let feBlend;
    	let g;
    	let circle;
    	let use;
    	let t1;
    	let div1;
    	let div0;
    	let t2;
    	let t3;
    	let div3;
    	let svg1;
    	let path0;
    	let t4;
    	let t5;
    	let svg2;
    	let path1;
    	let t6;
    	let div15;
    	let div6;
    	let div5;
    	let span0;
    	let t7_value = /*activeItem*/ ctx[0].name + "";
    	let t7;
    	let t8;
    	let button0;
    	let img;
    	let img_src_value;
    	let t9;
    	let span1;

    	let t10_value = (/*$user*/ ctx[16] && /*$user*/ ctx[16].docData && /*$user*/ ctx[16].docData.wishlist && /*$user*/ ctx[16].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*activeItem*/ ctx[0].id]
    	? "Remove from "
    	: "Add to ") + "";

    	let t10;
    	let t11;
    	let t12;
    	let span2;
    	let t13;
    	let hr0;
    	let t14;
    	let span4;
    	let t15_value = /*activeItem*/ ctx[0].price + "";
    	let t15;
    	let t16;
    	let span3;
    	let t17;
    	let t18;
    	let div12;
    	let div7;
    	let span5;
    	let t19_value = ({ en: "Colors", fr: "couleurs" })[/*$lang*/ ctx[15]] + "";
    	let t19;
    	let t20;
    	let t21;
    	let span6;
    	let t22;
    	let div8;
    	let span7;
    	let t23_value = ({ en: "Size", fr: "Taille" })[/*$lang*/ ctx[15]] + "";
    	let t23;
    	let t24;
    	let t25;
    	let t26;
    	let div10;
    	let span8;
    	let t27_value = ({ en: "Quantity", fr: "Quantité" })[/*$lang*/ ctx[15]] + "";
    	let t27;
    	let t28;
    	let t29;
    	let div9;
    	let svg3;
    	let path2;
    	let t30;
    	let input;
    	let t31;
    	let svg4;
    	let path3;
    	let t32;
    	let div11;
    	let button1;
    	let t33_value = ({ en: "Add to cart", fr: "J'achète" })[/*$lang*/ ctx[15]] + "";
    	let t33;
    	let t34;
    	let svg5;
    	let path4;
    	let path5;
    	let path6;
    	let path7;
    	let t35;
    	let hr1;
    	let t36;
    	let div14;
    	let div13;
    	let span9;
    	let t37_value = ({ en: "DELIVERY", fr: "LIVRAISON" })[/*$lang*/ ctx[15]] + "";
    	let t37;
    	let t38;
    	let span12;
    	let t39;
    	let span10;
    	let t40;
    	let t41;
    	let span11;
    	let t42;
    	let t43;
    	let mounted;
    	let dispose;
    	let if_block0 = /*activeItem*/ ctx[0] && /*activeItem*/ ctx[0].imgs && create_if_block_5(ctx);
    	let if_block1 = /*activeItem*/ ctx[0] && /*activeItem*/ ctx[0].imgs && /*activeItem*/ ctx[0].imgs[/*$activeColor*/ ctx[11]] && create_if_block_4(ctx);
    	let if_block2 = /*activeItem*/ ctx[0].creator && create_if_block_3(ctx);
    	let if_block3 = /*activeItem*/ ctx[0] && /*activeItem*/ ctx[0].colors && create_if_block_2(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*activeItem*/ ctx[0] && /*activeItem*/ ctx[0].sizes) return create_if_block_1$1;
    		return create_else_block$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block4 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div17 = element("div");
    			div16 = element("div");
    			div4 = element("div");
    			div2 = element("div");
    			svg0 = svg_element("svg");
    			defs = svg_element("defs");
    			style = svg_element("style");
    			t0 = text(".cls-1 {\r\n                                    fill: #bcbcbc;\r\n                                    stroke-linejoin: round;\r\n                                    stroke-width: 4px;\r\n                                    stroke: url(#linear-gradient);\r\n                                    filter: url(#filter);\r\n                                }\r\n                            ");
    			linearGradient = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			stop2 = svg_element("stop");
    			stop3 = svg_element("stop");
    			stop4 = svg_element("stop");
    			filter_1 = svg_element("filter");
    			feFlood = svg_element("feFlood");
    			feComposite = svg_element("feComposite");
    			feBlend = svg_element("feBlend");
    			g = svg_element("g");
    			circle = svg_element("circle");
    			use = svg_element("use");
    			t1 = space();
    			div1 = element("div");
    			div0 = element("div");
    			t2 = space();
    			if (if_block0) if_block0.c();
    			t3 = space();
    			div3 = element("div");
    			svg1 = svg_element("svg");
    			path0 = svg_element("path");
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			svg2 = svg_element("svg");
    			path1 = svg_element("path");
    			t6 = space();
    			div15 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			span0 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			button0 = element("button");
    			img = element("img");
    			t9 = space();
    			span1 = element("span");
    			t10 = text(t10_value);
    			t11 = text("\r\n                                    wishlist");
    			t12 = space();
    			span2 = element("span");
    			if (if_block2) if_block2.c();
    			t13 = space();
    			hr0 = element("hr");
    			t14 = space();
    			span4 = element("span");
    			t15 = text(t15_value);
    			t16 = space();
    			span3 = element("span");
    			t17 = text("TND");
    			t18 = space();
    			div12 = element("div");
    			div7 = element("div");
    			span5 = element("span");
    			t19 = text(t19_value);
    			t20 = text(":");
    			t21 = space();
    			span6 = element("span");
    			if (if_block3) if_block3.c();
    			t22 = space();
    			div8 = element("div");
    			span7 = element("span");
    			t23 = text(t23_value);
    			t24 = text(":");
    			t25 = space();
    			if_block4.c();
    			t26 = space();
    			div10 = element("div");
    			span8 = element("span");
    			t27 = text(t27_value);
    			t28 = text(":");
    			t29 = space();
    			div9 = element("div");
    			svg3 = svg_element("svg");
    			path2 = svg_element("path");
    			t30 = space();
    			input = element("input");
    			t31 = space();
    			svg4 = svg_element("svg");
    			path3 = svg_element("path");
    			t32 = space();
    			div11 = element("div");
    			button1 = element("button");
    			t33 = text(t33_value);
    			t34 = space();
    			svg5 = svg_element("svg");
    			path4 = svg_element("path");
    			path5 = svg_element("path");
    			path6 = svg_element("path");
    			path7 = svg_element("path");
    			t35 = space();
    			hr1 = element("hr");
    			t36 = space();
    			div14 = element("div");
    			div13 = element("div");
    			span9 = element("span");
    			t37 = text(t37_value);
    			t38 = space();
    			span12 = element("span");
    			t39 = text("Delivered between \r\n                            ");
    			span10 = element("span");
    			t40 = text(/*minDdate*/ ctx[18]);
    			t41 = text("\r\n                    and ");
    			span11 = element("span");
    			t42 = text(/*maxDdate*/ ctx[19]);
    			t43 = text(". Please check exact dates in the\r\n                            checkout page.");
    			add_location(style, file$2, 750, 28, 19460);
    			attr_dev(stop0, "offset", "0");
    			attr_dev(stop0, "stop-color", "#000");
    			add_location(stop0, file$2, 766, 32, 20242);
    			attr_dev(stop1, "offset", "0.093");
    			attr_dev(stop1, "stop-color", "#000");
    			attr_dev(stop1, "stop-opacity", "0");
    			add_location(stop1, file$2, 767, 32, 20313);
    			attr_dev(stop2, "offset", "0.729");
    			attr_dev(stop2, "stop-color", "#000");
    			attr_dev(stop2, "stop-opacity", "0");
    			add_location(stop2, file$2, 771, 32, 20516);
    			attr_dev(stop3, "offset", "0.918");
    			attr_dev(stop3, "stop-color", "#000");
    			add_location(stop3, file$2, 775, 32, 20719);
    			attr_dev(stop4, "offset", "1");
    			attr_dev(stop4, "stop-color", "#000");
    			add_location(stop4, file$2, 776, 32, 20794);
    			attr_dev(linearGradient, "id", "linear-gradient");
    			attr_dev(linearGradient, "x1", "367");
    			attr_dev(linearGradient, "y1", "728");
    			attr_dev(linearGradient, "x2", "367");
    			attr_dev(linearGradient, "y2", "6");
    			attr_dev(linearGradient, "gradientUnits", "userSpaceOnUse");
    			add_location(linearGradient, file$2, 759, 28, 19908);
    			attr_dev(feFlood, "result", "flood");
    			attr_dev(feFlood, "flood-color", "#f7f7f7");
    			add_location(feFlood, file$2, 785, 32, 21226);
    			attr_dev(feComposite, "result", "composite");
    			attr_dev(feComposite, "operator", "in");
    			attr_dev(feComposite, "in2", "SourceGraphic");
    			add_location(feComposite, file$2, 786, 32, 21308);
    			attr_dev(feBlend, "result", "blend");
    			attr_dev(feBlend, "in2", "SourceGraphic");
    			add_location(feBlend, file$2, 790, 32, 21521);
    			attr_dev(filter_1, "id", "filter");
    			attr_dev(filter_1, "x", "0");
    			attr_dev(filter_1, "y", "0");
    			attr_dev(filter_1, "width", "734");
    			attr_dev(filter_1, "height", "734");
    			attr_dev(filter_1, "filterUnits", "userSpaceOnUse");
    			add_location(filter_1, file$2, 778, 28, 20908);
    			add_location(defs, file$2, 749, 24, 19424);
    			attr_dev(circle, "id", "Ellipse_1_copie");
    			attr_dev(circle, "data-name", "Ellipse 1 copie");
    			attr_dev(circle, "class", "cls-1");
    			attr_dev(circle, "cx", "367");
    			attr_dev(circle, "cy", "367");
    			attr_dev(circle, "r", "361");
    			set_style(circle, "stroke", "inherit");
    			set_style(circle, "filter", "none");
    			set_style(circle, "fill", "inherit");
    			add_location(circle, file$2, 796, 28, 21821);
    			attr_dev(g, "class", "inside_color svelte-1664i8x");
    			set_style(g, "fill", "#bcbcbc");
    			set_style(g, "filter", "url(#filter)");
    			add_location(g, file$2, 793, 24, 21665);
    			xlink_attr(use, "xlink:href", "#Ellipse_1_copie");
    			set_style(use, "stroke", "url(#linear-gradient)");
    			set_style(use, "filter", "none");
    			set_style(use, "fill", "none");
    			add_location(use, file$2, 805, 24, 22260);
    			attr_dev(svg0, "class", "circle_border svelte-1664i8x");
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg0, "width", "734");
    			attr_dev(svg0, "height", "734");
    			attr_dev(svg0, "viewBox", "0 0 734 734");
    			attr_dev(svg0, "style", /*filter*/ ctx[17]);
    			toggle_class(svg0, "rotateLeft", /*rotateLeft*/ ctx[5]);
    			toggle_class(svg0, "rotateRight", /*rotateRight*/ ctx[6]);
    			add_location(svg0, file$2, 737, 20, 18917);
    			attr_dev(div0, "class", "gadgad svelte-1664i8x");
    			attr_dev(div0, "id", "gadgad_id");
    			add_location(div0, file$2, 814, 20, 22595);
    			attr_dev(div1, "class", "p_back_circle svelte-1664i8x");
    			add_location(div1, file$2, 811, 20, 22503);
    			attr_dev(div2, "class", "p_main_img svelte-1664i8x");
    			add_location(div2, file$2, 735, 16, 18837);
    			attr_dev(path0, "d", "M382.678,226.804L163.73,7.86C158.666,2.792,151.906,0,144.698,0s-13.968,2.792-19.032,7.86l-16.124,16.12\r\n            c-10.492,10.504-10.492,27.576,0,38.064L293.398,245.9l-184.06,184.06c-5.064,5.068-7.86,11.824-7.86,19.028\r\n            c0,7.212,2.796,13.968,7.86,19.04l16.124,16.116c5.068,5.068,11.824,7.86,19.032,7.86s13.968-2.792,19.032-7.86L382.678,265\r\n            c5.076-5.084,7.864-11.872,7.848-19.088C390.542,238.668,387.754,231.884,382.678,226.804z");
    			add_location(path0, file$2, 868, 24, 25276);
    			attr_dev(svg1, "version", "1.1");
    			attr_dev(svg1, "id", "Layer_1");
    			attr_dev(svg1, "class", "arrow_left svelte-1664i8x");
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg1, "x", "0px");
    			attr_dev(svg1, "y", "0px");
    			attr_dev(svg1, "viewBox", "0 0 492.004 492.004");
    			set_style(svg1, "enable-background", "new 0 0 492.004 492.004");
    			attr_dev(svg1, "xml:space", "preserve");
    			add_location(svg1, file$2, 854, 20, 24637);
    			attr_dev(path1, "d", "M382.678,226.804L163.73,7.86C158.666,2.792,151.906,0,144.698,0s-13.968,2.792-19.032,7.86l-16.124,16.12\r\n            c-10.492,10.504-10.492,27.576,0,38.064L293.398,245.9l-184.06,184.06c-5.064,5.068-7.86,11.824-7.86,19.028\r\n            c0,7.212,2.796,13.968,7.86,19.04l16.124,16.116c5.068,5.068,11.824,7.86,19.032,7.86s13.968-2.792,19.032-7.86L382.678,265\r\n            c5.076-5.084,7.864-11.872,7.848-19.088C390.542,238.668,387.754,231.884,382.678,226.804z");
    			add_location(path1, file$2, 901, 24, 27085);
    			attr_dev(svg2, "version", "1.1");
    			attr_dev(svg2, "id", "Layer_1");
    			attr_dev(svg2, "class", "arrow_right svelte-1664i8x");
    			attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg2, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg2, "x", "0px");
    			attr_dev(svg2, "y", "0px");
    			attr_dev(svg2, "viewBox", "0 0 492.004 492.004");
    			set_style(svg2, "enable-background", "new 0 0 492.004 492.004");
    			attr_dev(svg2, "xml:space", "preserve");
    			add_location(svg2, file$2, 887, 20, 26444);
    			attr_dev(div3, "class", "p_slider svelte-1664i8x");
    			add_location(div3, file$2, 852, 16, 24554);
    			attr_dev(div4, "class", "p_imgs svelte-1664i8x");
    			add_location(div4, file$2, 734, 12, 18799);
    			attr_dev(span0, "class", "p_title svelte-1664i8x");
    			add_location(span0, file$2, 914, 24, 27826);
    			attr_dev(img, "class", "heart-img svelte-1664i8x");

    			if (img.src !== (img_src_value = /*$user*/ ctx[16] && /*$user*/ ctx[16].docData && /*$user*/ ctx[16].docData.wishlist && /*$user*/ ctx[16].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*activeItem*/ ctx[0].id]
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/empty-heart.png")) attr_dev(img, "src", img_src_value);

    			attr_dev(img, "alt", "eart");
    			add_location(img, file$2, 926, 32, 28449);
    			attr_dev(span1, "class", "popuptext svelte-1664i8x");
    			set_style(span1, "background-color", /*creatorData*/ ctx[2].accentColor);
    			attr_dev(span1, "id", "myPopup");
    			toggle_class(span1, "show", /*show*/ ctx[4]);
    			add_location(span1, file$2, 930, 32, 28812);
    			attr_dev(button0, "type", "button");
    			attr_dev(button0, "class", "wishlist_btn svelte-1664i8x");
    			add_location(button0, file$2, 916, 28, 27928);
    			attr_dev(div5, "class", "u-heart-container svelte-1664i8x");
    			add_location(div5, file$2, 913, 20, 27769);
    			attr_dev(span2, "class", "p_subTitle svelte-1664i8x");
    			add_location(span2, file$2, 940, 20, 29392);
    			attr_dev(hr0, "class", "svelte-1664i8x");
    			add_location(hr0, file$2, 947, 20, 29765);
    			set_style(span3, "color", /*creatorData*/ ctx[2].accentColor);
    			attr_dev(span3, "class", "svelte-1664i8x");
    			add_location(span3, file$2, 950, 24, 29885);
    			attr_dev(span4, "class", "p_price svelte-1664i8x");
    			add_location(span4, file$2, 948, 20, 29793);
    			attr_dev(div6, "class", "p_info svelte-1664i8x");
    			add_location(div6, file$2, 912, 16, 27727);
    			attr_dev(span5, "class", "title svelte-1664i8x");
    			add_location(span5, file$2, 956, 24, 30129);
    			attr_dev(span6, "class", "colors svelte-1664i8x");
    			add_location(span6, file$2, 958, 24, 30253);
    			attr_dev(div7, "class", "p_colors svelte-1664i8x");
    			add_location(div7, file$2, 955, 20, 30081);
    			attr_dev(span7, "class", "title svelte-1664i8x");
    			add_location(span7, file$2, 978, 24, 31314);
    			attr_dev(div8, "class", "p_size svelte-1664i8x");
    			add_location(div8, file$2, 977, 20, 31268);
    			attr_dev(span8, "class", "title svelte-1664i8x");
    			add_location(span8, file$2, 1013, 24, 33175);
    			attr_dev(path2, "d", "M382.678,226.804L163.73,7.86C158.666,2.792,151.906,0,144.698,0s-13.968,2.792-19.032,7.86l-16.124,16.12\r\n              c-10.492,10.504-10.492,27.576,0,38.064L293.398,245.9l-184.06,184.06c-5.064,5.068-7.86,11.824-7.86,19.028\r\n              c0,7.212,2.796,13.968,7.86,19.04l16.124,16.116c5.068,5.068,11.824,7.86,19.032,7.86s13.968-2.792,19.032-7.86L382.678,265\r\n              c5.076-5.084,7.864-11.872,7.848-19.088C390.542,238.668,387.754,231.884,382.678,226.804z");
    			add_location(path2, file$2, 1032, 32, 34221);
    			attr_dev(svg3, "version", "1.1");
    			attr_dev(svg3, "id", "Layer_1");
    			attr_dev(svg3, "class", "arrow_left svelte-1664i8x");
    			attr_dev(svg3, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg3, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg3, "x", "0px");
    			attr_dev(svg3, "y", "0px");
    			attr_dev(svg3, "viewBox", "0 0 492.004 492.004");
    			set_style(svg3, "enable-background", "new 0 0 492.004 492.004");
    			set_style(svg3, "fill", "#181d22");
    			attr_dev(svg3, "xml:space", "preserve");
    			add_location(svg3, file$2, 1018, 28, 33413);
    			attr_dev(input, "type", "number");
    			attr_dev(input, "class", "svelte-1664i8x");
    			add_location(input, file$2, 1038, 28, 34797);
    			attr_dev(path3, "d", "M382.678,226.804L163.73,7.86C158.666,2.792,151.906,0,144.698,0s-13.968,2.792-19.032,7.86l-16.124,16.12\r\n              c-10.492,10.504-10.492,27.576,0,38.064L293.398,245.9l-184.06,184.06c-5.064,5.068-7.86,11.824-7.86,19.028\r\n              c0,7.212,2.796,13.968,7.86,19.04l16.124,16.116c5.068,5.068,11.824,7.86,19.032,7.86s13.968-2.792,19.032-7.86L382.678,265\r\n              c5.076-5.084,7.864-11.872,7.848-19.088C390.542,238.668,387.754,231.884,382.678,226.804z");
    			add_location(path3, file$2, 1055, 32, 35691);
    			attr_dev(svg4, "version", "1.1");
    			attr_dev(svg4, "id", "Layer_1");
    			attr_dev(svg4, "class", "arrow_right svelte-1664i8x");
    			attr_dev(svg4, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg4, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg4, "x", "0px");
    			attr_dev(svg4, "y", "0px");
    			attr_dev(svg4, "viewBox", "0 0 492.004 492.004");
    			set_style(svg4, "enable-background", "new 0 0 492.004 492.004");
    			set_style(svg4, "fill", "#181d22");
    			attr_dev(svg4, "xml:space", "preserve");
    			add_location(svg4, file$2, 1040, 28, 34881);
    			attr_dev(div9, "class", "input_number svelte-1664i8x");
    			add_location(div9, file$2, 1016, 24, 33327);
    			attr_dev(div10, "class", "p_quantity svelte-1664i8x");
    			add_location(div10, file$2, 1012, 20, 33125);
    			attr_dev(path4, "d", "m504.399\r\n              185.065c-6.761-8.482-16.904-13.348-27.83-13.348h-98.604l-53.469-122.433c-3.315-7.591-12.157-11.06-19.749-7.743-7.592\r\n              3.315-11.059 12.158-7.743 19.75l48.225\r\n              110.427h-178.458l48.225-110.427c3.315-7.592-.151-16.434-7.743-19.75-7.591-3.317-16.434.15-19.749\r\n              7.743l-53.469 122.434h-98.604c-10.926 0-21.069 4.865-27.83\r\n              13.348-6.637 8.328-9.086 19.034-6.719 29.376l52.657 230c3.677\r\n              16.06 17.884 27.276 34.549 27.276h335.824c16.665 0 30.872-11.216\r\n              34.549-27.276l52.657-230.001c2.367-10.342-.082-21.048-6.719-29.376zm-80.487\r\n              256.652h-335.824c-2.547\r\n              0-4.778-1.67-5.305-3.972l-52.657-229.998c-.413-1.805.28-3.163.936-3.984.608-.764\r\n              1.985-2.045 4.369-2.045h85.503l-3.929 8.997c-3.315 7.592.151\r\n              16.434 7.743 19.75 1.954.854 3.99 1.258 5.995 1.258 5.782 0\r\n              11.292-3.363 13.754-9l9.173-21.003h204.662l9.173 21.003c2.462\r\n              5.638 7.972 9 13.754 9 2.004 0 4.041-.404 5.995-1.258 7.592-3.315\r\n              11.059-12.158 7.743-19.75l-3.929-8.997h85.503c2.384 0 3.761 1.281\r\n              4.369 2.045.655.822 1.349 2.18.936 3.983l-52.657 230c-.528\r\n              2.301-2.76 3.971-5.307 3.971z");
    			add_location(path4, file$2, 1078, 32, 37069);
    			attr_dev(path5, "d", "m166 266.717c-8.284 0-15 6.716-15 15v110c0 8.284 6.716 15 15\r\n              15s15-6.716 15-15v-110c0-8.284-6.715-15-15-15z");
    			add_location(path5, file$2, 1096, 32, 38425);
    			attr_dev(path6, "d", "m256 266.717c-8.284 0-15 6.716-15 15v110c0 8.284 6.716 15 15\r\n              15s15-6.716 15-15v-110c0-8.284-6.716-15-15-15z");
    			add_location(path6, file$2, 1099, 32, 38631);
    			attr_dev(path7, "d", "m346 266.717c-8.284 0-15 6.716-15 15v110c0 8.284 6.716 15 15\r\n              15s15-6.716 15-15v-110c-.001-8.284-6.716-15-15-15z");
    			add_location(path7, file$2, 1102, 32, 38837);
    			attr_dev(svg5, "id", "Capa_1");
    			attr_dev(svg5, "enable-background", "new 0 0 512 512");
    			attr_dev(svg5, "height", "512");
    			attr_dev(svg5, "viewBox", "0 0 512 512");
    			attr_dev(svg5, "width", "512");
    			attr_dev(svg5, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg5, "class", "svelte-1664i8x");
    			add_location(svg5, file$2, 1071, 28, 36702);
    			attr_dev(button1, "type", "button");
    			set_style(button1, "background-color", /*creatorData*/ ctx[2].accentColor);
    			attr_dev(button1, "class", "add_cart_btn svelte-1664i8x");
    			add_location(button1, file$2, 1065, 24, 36365);
    			attr_dev(div11, "class", "btns svelte-1664i8x");
    			add_location(div11, file$2, 1064, 20, 36321);
    			attr_dev(div12, "class", "p_order_details svelte-1664i8x");
    			add_location(div12, file$2, 954, 16, 30030);
    			attr_dev(hr1, "class", "svelte-1664i8x");
    			add_location(hr1, file$2, 1118, 16, 39620);
    			add_location(span9, file$2, 1134, 24, 40271);
    			set_style(span10, "color", /*creatorData*/ ctx[2].accentColor);
    			set_style(span10, "font-weight", "600");
    			add_location(span10, file$2, 1137, 28, 40447);
    			set_style(span11, "color", /*creatorData*/ ctx[2].accentColor);
    			set_style(span11, "font-weight", "600");
    			add_location(span11, file$2, 1138, 24, 40553);
    			attr_dev(span12, "class", "desc svelte-1664i8x");
    			add_location(span12, file$2, 1136, 24, 40380);
    			attr_dev(div13, "class", "delivery svelte-1664i8x");
    			add_location(div13, file$2, 1133, 20, 40223);
    			attr_dev(div14, "class", "policies svelte-1664i8x");
    			add_location(div14, file$2, 1119, 16, 39644);
    			attr_dev(div15, "class", "all_info svelte-1664i8x");
    			add_location(div15, file$2, 910, 12, 27669);
    			attr_dev(div16, "class", "p_container svelte-1664i8x");
    			add_location(div16, file$2, 733, 8, 18760);
    			attr_dev(div17, "class", "container svelte-1664i8x");
    			add_location(div17, file$2, 731, 4, 18697);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div17, anchor);
    			append_dev(div17, div16);
    			append_dev(div16, div4);
    			append_dev(div4, div2);
    			append_dev(div2, svg0);
    			append_dev(svg0, defs);
    			append_dev(defs, style);
    			append_dev(style, t0);
    			append_dev(defs, linearGradient);
    			append_dev(linearGradient, stop0);
    			append_dev(linearGradient, stop1);
    			append_dev(linearGradient, stop2);
    			append_dev(linearGradient, stop3);
    			append_dev(linearGradient, stop4);
    			append_dev(defs, filter_1);
    			append_dev(filter_1, feFlood);
    			append_dev(filter_1, feComposite);
    			append_dev(filter_1, feBlend);
    			append_dev(svg0, g);
    			append_dev(g, circle);
    			append_dev(svg0, use);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t2);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, svg1);
    			append_dev(svg1, path0);
    			append_dev(div3, t4);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t5);
    			append_dev(div3, svg2);
    			append_dev(svg2, path1);
    			append_dev(div16, t6);
    			append_dev(div16, div15);
    			append_dev(div15, div6);
    			append_dev(div6, div5);
    			append_dev(div5, span0);
    			append_dev(span0, t7);
    			append_dev(div5, t8);
    			append_dev(div5, button0);
    			append_dev(button0, img);
    			append_dev(button0, t9);
    			append_dev(button0, span1);
    			append_dev(span1, t10);
    			append_dev(span1, t11);
    			append_dev(div6, t12);
    			append_dev(div6, span2);
    			if (if_block2) if_block2.m(span2, null);
    			append_dev(div6, t13);
    			append_dev(div6, hr0);
    			append_dev(div6, t14);
    			append_dev(div6, span4);
    			append_dev(span4, t15);
    			append_dev(span4, t16);
    			append_dev(span4, span3);
    			append_dev(span3, t17);
    			append_dev(div15, t18);
    			append_dev(div15, div12);
    			append_dev(div12, div7);
    			append_dev(div7, span5);
    			append_dev(span5, t19);
    			append_dev(span5, t20);
    			append_dev(div7, t21);
    			append_dev(div7, span6);
    			if (if_block3) if_block3.m(span6, null);
    			append_dev(div12, t22);
    			append_dev(div12, div8);
    			append_dev(div8, span7);
    			append_dev(span7, t23);
    			append_dev(span7, t24);
    			append_dev(div8, t25);
    			if_block4.m(div8, null);
    			append_dev(div12, t26);
    			append_dev(div12, div10);
    			append_dev(div10, span8);
    			append_dev(span8, t27);
    			append_dev(span8, t28);
    			append_dev(div10, t29);
    			append_dev(div10, div9);
    			append_dev(div9, svg3);
    			append_dev(svg3, path2);
    			append_dev(div9, t30);
    			append_dev(div9, input);
    			set_input_value(input, /*$activeQuantity*/ ctx[14]);
    			append_dev(div9, t31);
    			append_dev(div9, svg4);
    			append_dev(svg4, path3);
    			append_dev(div12, t32);
    			append_dev(div12, div11);
    			append_dev(div11, button1);
    			append_dev(button1, t33);
    			append_dev(button1, t34);
    			append_dev(button1, svg5);
    			append_dev(svg5, path4);
    			append_dev(svg5, path5);
    			append_dev(svg5, path6);
    			append_dev(svg5, path7);
    			append_dev(div15, t35);
    			append_dev(div15, hr1);
    			append_dev(div15, t36);
    			append_dev(div15, div14);
    			append_dev(div14, div13);
    			append_dev(div13, span9);
    			append_dev(span9, t37);
    			append_dev(div13, t38);
    			append_dev(div13, span12);
    			append_dev(span12, t39);
    			append_dev(span12, span10);
    			append_dev(span10, t40);
    			append_dev(span12, t41);
    			append_dev(span12, span11);
    			append_dev(span11, t42);
    			append_dev(span12, t43);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "mousemove", stop_propagation(prevent_default(/*mousemove_handler*/ ctx[31])), false, true, true),
    					listen_dev(div0, "touchmove", stop_propagation(prevent_default(/*touchmove_handler*/ ctx[32])), false, true, true),
    					listen_dev(div0, "touchstart", stop_propagation(prevent_default(/*touchstart_handler*/ ctx[33])), false, true, true),
    					listen_dev(div0, "touchend", stop_propagation(prevent_default(/*touchend_handler*/ ctx[34])), false, true, true),
    					listen_dev(div0, "mouseleave", stop_propagation(prevent_default(/*mouseleave_handler*/ ctx[35])), false, true, true),
    					listen_dev(svg1, "click", /*click_handler_1*/ ctx[36], false, false, false),
    					listen_dev(svg2, "click", /*click_handler_3*/ ctx[38], false, false, false),
    					listen_dev(button0, "mouseenter", /*mouseenter_handler*/ ctx[39], false, false, false),
    					listen_dev(button0, "mouseleave", /*mouseleave_handler_1*/ ctx[40], false, false, false),
    					listen_dev(
    						button0,
    						"click",
    						function () {
    							if (is_function(/*addWishlist*/ ctx[26](/*params*/ ctx[1].userid + "-" + /*activeItem*/ ctx[0].id))) /*addWishlist*/ ctx[26](/*params*/ ctx[1].userid + "-" + /*activeItem*/ ctx[0].id).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(svg3, "click", /*click_handler_7*/ ctx[44], false, false, false),
    					listen_dev(input, "input", /*input_input_handler*/ ctx[45]),
    					listen_dev(svg4, "click", /*click_handler_8*/ ctx[46], false, false, false),
    					listen_dev(button1, "click", /*addToCart*/ ctx[20], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*rotateLeft*/ 32) {
    				toggle_class(svg0, "rotateLeft", /*rotateLeft*/ ctx[5]);
    			}

    			if (dirty[0] & /*rotateRight*/ 64) {
    				toggle_class(svg0, "rotateRight", /*rotateRight*/ ctx[6]);
    			}

    			if (/*activeItem*/ ctx[0] && /*activeItem*/ ctx[0].imgs) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5(ctx);
    					if_block0.c();
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*activeItem*/ ctx[0] && /*activeItem*/ ctx[0].imgs && /*activeItem*/ ctx[0].imgs[/*$activeColor*/ ctx[11]]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4(ctx);
    					if_block1.c();
    					if_block1.m(div3, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (dirty[0] & /*activeItem*/ 1 && t7_value !== (t7_value = /*activeItem*/ ctx[0].name + "")) set_data_dev(t7, t7_value);

    			if (dirty[0] & /*$user, params, activeItem*/ 65539 && img.src !== (img_src_value = /*$user*/ ctx[16] && /*$user*/ ctx[16].docData && /*$user*/ ctx[16].docData.wishlist && /*$user*/ ctx[16].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*activeItem*/ ctx[0].id]
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/empty-heart.png")) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty[0] & /*$user, params, activeItem*/ 65539 && t10_value !== (t10_value = (/*$user*/ ctx[16] && /*$user*/ ctx[16].docData && /*$user*/ ctx[16].docData.wishlist && /*$user*/ ctx[16].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*activeItem*/ ctx[0].id]
    			? "Remove from "
    			: "Add to ") + "")) set_data_dev(t10, t10_value);

    			if (dirty[0] & /*creatorData*/ 4) {
    				set_style(span1, "background-color", /*creatorData*/ ctx[2].accentColor);
    			}

    			if (dirty[0] & /*show*/ 16) {
    				toggle_class(span1, "show", /*show*/ ctx[4]);
    			}

    			if (/*activeItem*/ ctx[0].creator) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3(ctx);
    					if_block2.c();
    					if_block2.m(span2, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (dirty[0] & /*activeItem*/ 1 && t15_value !== (t15_value = /*activeItem*/ ctx[0].price + "")) set_data_dev(t15, t15_value);

    			if (dirty[0] & /*creatorData*/ 4) {
    				set_style(span3, "color", /*creatorData*/ ctx[2].accentColor);
    			}

    			if (dirty[0] & /*$lang*/ 32768 && t19_value !== (t19_value = ({ en: "Colors", fr: "couleurs" })[/*$lang*/ ctx[15]] + "")) set_data_dev(t19, t19_value);

    			if (/*activeItem*/ ctx[0] && /*activeItem*/ ctx[0].colors) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_2(ctx);
    					if_block3.c();
    					if_block3.m(span6, null);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if (dirty[0] & /*$lang*/ 32768 && t23_value !== (t23_value = ({ en: "Size", fr: "Taille" })[/*$lang*/ ctx[15]] + "")) set_data_dev(t23, t23_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block4) {
    				if_block4.p(ctx, dirty);
    			} else {
    				if_block4.d(1);
    				if_block4 = current_block_type(ctx);

    				if (if_block4) {
    					if_block4.c();
    					if_block4.m(div8, null);
    				}
    			}

    			if (dirty[0] & /*$lang*/ 32768 && t27_value !== (t27_value = ({ en: "Quantity", fr: "Quantité" })[/*$lang*/ ctx[15]] + "")) set_data_dev(t27, t27_value);

    			if (dirty[0] & /*$activeQuantity*/ 16384 && to_number(input.value) !== /*$activeQuantity*/ ctx[14]) {
    				set_input_value(input, /*$activeQuantity*/ ctx[14]);
    			}

    			if (dirty[0] & /*$lang*/ 32768 && t33_value !== (t33_value = ({ en: "Add to cart", fr: "J'achète" })[/*$lang*/ ctx[15]] + "")) set_data_dev(t33, t33_value);

    			if (dirty[0] & /*creatorData*/ 4) {
    				set_style(button1, "background-color", /*creatorData*/ ctx[2].accentColor);
    			}

    			if (dirty[0] & /*$lang*/ 32768 && t37_value !== (t37_value = ({ en: "DELIVERY", fr: "LIVRAISON" })[/*$lang*/ ctx[15]] + "")) set_data_dev(t37, t37_value);

    			if (dirty[0] & /*creatorData*/ 4) {
    				set_style(span10, "color", /*creatorData*/ ctx[2].accentColor);
    			}

    			if (dirty[0] & /*creatorData*/ 4) {
    				set_style(span11, "color", /*creatorData*/ ctx[2].accentColor);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div17);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(731:0) {#if validated}",
    		ctx
    	});

    	return block;
    }

    // (839:20) {#if activeItem && activeItem.imgs}
    function create_if_block_5(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = /*activeItem*/ ctx[0].imgs[/*$activeColor*/ ctx[11]][/*$activeFacade*/ ctx[12]])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "product");
    			attr_dev(img, "class", "product_img svelte-1664i8x");
    			set_style(img, "top", /*topFinal*/ ctx[8] + "px");
    			set_style(img, "left", /*leftFinal*/ ctx[9] + "px");
    			set_style(img, "transform", "scale(" + /*scale*/ ctx[10] + ")");
    			toggle_class(img, "rotating", /*rotating*/ ctx[7]);
    			add_location(img, file$2, 839, 24, 24053);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*activeItem, $activeColor, $activeFacade*/ 6145 && img.src !== (img_src_value = /*activeItem*/ ctx[0].imgs[/*$activeColor*/ ctx[11]][/*$activeFacade*/ ctx[12]])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty[0] & /*topFinal*/ 256) {
    				set_style(img, "top", /*topFinal*/ ctx[8] + "px");
    			}

    			if (dirty[0] & /*leftFinal*/ 512) {
    				set_style(img, "left", /*leftFinal*/ ctx[9] + "px");
    			}

    			if (dirty[0] & /*scale*/ 1024) {
    				set_style(img, "transform", "scale(" + /*scale*/ ctx[10] + ")");
    			}

    			if (dirty[0] & /*rotating*/ 128) {
    				toggle_class(img, "rotating", /*rotating*/ ctx[7]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(839:20) {#if activeItem && activeItem.imgs}",
    		ctx
    	});

    	return block;
    }

    // (875:20) {#if activeItem && activeItem.imgs && activeItem.imgs[$activeColor]}
    function create_if_block_4(ctx) {
    	let each_1_anchor;
    	let each_value_3 = Object.entries(/*activeItem*/ ctx[0].imgs[/*$activeColor*/ ctx[11]]);
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*activeItem, $activeColor, $activeFacade*/ 6145) {
    				each_value_3 = Object.entries(/*activeItem*/ ctx[0].imgs[/*$activeColor*/ ctx[11]]);
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(875:20) {#if activeItem && activeItem.imgs && activeItem.imgs[$activeColor]}",
    		ctx
    	});

    	return block;
    }

    // (876:24) {#each Object.entries(activeItem.imgs[$activeColor]) as [facade, link]}
    function create_each_block_3(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[37](/*facade*/ ctx[59]);
    	}

    	const block = {
    		c: function create() {
    			img = element("img");
    			attr_dev(img, "crossorigin", "anonymous");
    			if (img.src !== (img_src_value = /*link*/ ctx[60])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "product");
    			attr_dev(img, "class", "svelte-1664i8x");
    			add_location(img, file$2, 876, 28, 26017);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*activeItem, $activeColor*/ 2049 && img.src !== (img_src_value = /*link*/ ctx[60])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(876:24) {#each Object.entries(activeItem.imgs[$activeColor]) as [facade, link]}",
    		ctx
    	});

    	return block;
    }

    // (942:24) {#if activeItem.creator}
    function create_if_block_3(ctx) {
    	let a;
    	let span;
    	let t_value = /*activeItem*/ ctx[0].creator + "";
    	let t;
    	let a_href_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a = element("a");
    			span = element("span");
    			t = text(t_value);
    			set_style(span, "color", /*creatorData*/ ctx[2].accentColor);
    			attr_dev(span, "class", "svelte-1664i8x");
    			add_location(span, file$2, 943, 28, 29576);
    			attr_dev(a, "href", a_href_value = "/" + /*activeItem*/ ctx[0].creator);
    			add_location(a, file$2, 942, 28, 29497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, span);
    			append_dev(span, t);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*activeItem*/ 1 && t_value !== (t_value = /*activeItem*/ ctx[0].creator + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*creatorData*/ 4) {
    				set_style(span, "color", /*creatorData*/ ctx[2].accentColor);
    			}

    			if (dirty[0] & /*activeItem*/ 1 && a_href_value !== (a_href_value = "/" + /*activeItem*/ ctx[0].creator)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(942:24) {#if activeItem.creator}",
    		ctx
    	});

    	return block;
    }

    // (960:28) {#if activeItem && activeItem.colors}
    function create_if_block_2(ctx) {
    	let each_1_anchor;
    	let each_value_2 = /*activeItem*/ ctx[0].colors;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$activeColor, activeItem*/ 2049) {
    				each_value_2 = /*activeItem*/ ctx[0].colors;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(960:28) {#if activeItem && activeItem.colors}",
    		ctx
    	});

    	return block;
    }

    // (961:32) {#each activeItem.colors as color}
    function create_each_block_2(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[41](/*color*/ ctx[56]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t = space();
    			attr_dev(div0, "class", "color svelte-1664i8x");
    			set_style(div0, "background-color", colors[/*color*/ ctx[56].toLowerCase()]);
    			add_location(div0, file$2, 968, 40, 30877);
    			attr_dev(div1, "class", "color_border svelte-1664i8x");
    			set_style(div1, "border", "0px solid black");
    			toggle_class(div1, "active", /*$activeColor*/ ctx[11] == /*color*/ ctx[56]);
    			add_location(div1, file$2, 961, 36, 30447);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_4, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*activeItem*/ 1) {
    				set_style(div0, "background-color", colors[/*color*/ ctx[56].toLowerCase()]);
    			}

    			if (dirty[0] & /*$activeColor, activeItem*/ 2049) {
    				toggle_class(div1, "active", /*$activeColor*/ ctx[11] == /*color*/ ctx[56]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(961:32) {#each activeItem.colors as color}",
    		ctx
    	});

    	return block;
    }

    // (993:24) {:else}
    function create_else_block$1(ctx) {
    	let span;
    	let each_value_1 = ["S", "M", "L", "XL"];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < 4; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			span = element("span");

    			for (let i = 0; i < 4; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span, "class", "sizes svelte-1664i8x");
    			add_location(span, file$2, 993, 28, 32154);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			for (let i = 0; i < 4; i += 1) {
    				each_blocks[i].m(span, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$activeSize, creatorData*/ 8196) {
    				each_value_1 = ["S", "M", "L", "XL"];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < 4; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(span, null);
    					}
    				}

    				for (; i < 4; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(993:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (981:24) {#if activeItem && activeItem.sizes}
    function create_if_block_1$1(ctx) {
    	let each_1_anchor;
    	let each_value = /*activeItem*/ ctx[0].sizes;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$activeSize, activeItem, creatorData*/ 8197) {
    				each_value = /*activeItem*/ ctx[0].sizes;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(981:24) {#if activeItem && activeItem.sizes}",
    		ctx
    	});

    	return block;
    }

    // (995:32) {#each ['S', 'M', 'L', 'XL'] as size}
    function create_each_block_1(ctx) {
    	let div;
    	let span;
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_6(...args) {
    		return /*click_handler_6*/ ctx[43](/*size*/ ctx[51], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = text(/*size*/ ctx[51]);
    			t1 = space();
    			add_location(span, file$2, 1005, 40, 32872);
    			attr_dev(div, "class", "size svelte-1664i8x");

    			set_style(div, "background-color", /*$activeSize*/ ctx[13] == /*size*/ ctx[51]
    			? /*creatorData*/ ctx[2].accentColor
    			: "");

    			toggle_class(div, "active", /*size*/ ctx[51] == /*$activeSize*/ ctx[13]);
    			add_location(div, file$2, 995, 36, 32283);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(span, "click", /*click_handler*/ ctx[30], false, false, false),
    					listen_dev(div, "click", click_handler_6, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$activeSize, creatorData*/ 8196) {
    				set_style(div, "background-color", /*$activeSize*/ ctx[13] == /*size*/ ctx[51]
    				? /*creatorData*/ ctx[2].accentColor
    				: "");
    			}

    			if (dirty[0] & /*$activeSize*/ 8192) {
    				toggle_class(div, "active", /*size*/ ctx[51] == /*$activeSize*/ ctx[13]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(995:32) {#each ['S', 'M', 'L', 'XL'] as size}",
    		ctx
    	});

    	return block;
    }

    // (982:28) {#each activeItem.sizes as size}
    function create_each_block(ctx) {
    	let div;
    	let t0_value = /*size*/ ctx[51] + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_5(...args) {
    		return /*click_handler_5*/ ctx[42](/*size*/ ctx[51], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();

    			set_style(div, "background-color", /*$activeSize*/ ctx[13] == /*size*/ ctx[51]
    			? /*creatorData*/ ctx[2].accentColor
    			: "");

    			attr_dev(div, "class", "size svelte-1664i8x");
    			toggle_class(div, "active", /*size*/ ctx[51] == /*$activeSize*/ ctx[13]);
    			add_location(div, file$2, 982, 32, 31566);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_5, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*activeItem*/ 1 && t0_value !== (t0_value = /*size*/ ctx[51] + "")) set_data_dev(t0, t0_value);

    			if (dirty[0] & /*$activeSize, activeItem, creatorData*/ 8197) {
    				set_style(div, "background-color", /*$activeSize*/ ctx[13] == /*size*/ ctx[51]
    				? /*creatorData*/ ctx[2].accentColor
    				: "");
    			}

    			if (dirty[0] & /*activeItem, $activeSize*/ 8193) {
    				toggle_class(div, "active", /*size*/ ctx[51] == /*$activeSize*/ ctx[13]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(982:28) {#each activeItem.sizes as size}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let if_block_anchor;
    	let if_block = /*validated*/ ctx[3] && create_if_block$1(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*validated*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$1(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $activeColor;
    	let $activeFacade;
    	let $activeSize;
    	let $activeQuantity;
    	let $cart;
    	let $lang;
    	let $user;
    	validate_store(cart, "cart");
    	component_subscribe($$self, cart, $$value => $$invalidate(49, $cart = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(15, $lang = $$value));
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(16, $user = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SingleProduct", slots, []);
    	let { activeItem } = $$props;
    	let { params } = $$props;
    	let { creatorData } = $$props;

    	if (activeItem == undefined) {
    		activeItem = {
    			name: "Ahmed Shirt",
    			img: "/img/tshirt.png",
    			price: 90,
    			type: "T-shirt",
    			id: "MMX8E7"
    		};
    	}

    	let filter = convert(creatorData.accentColor);
    	let [minDdate, maxDdate] = generateDeliveryDate();
    	console.log("in singe");
    	let validated = false;

    	onMount(async () => {
    		console.log("mounted");
    		let data = await dbWrapper.get("/creators/" + params.userid + "/merch/all");
    		console.log("sdf " + params);

    		if (data[params.itemid] == undefined) {
    			navigate("/" + params.userid, { replace: true });
    		} else if (data[params.itemid].deleted === true) {
    			navigate("/" + params.userid, { replace: true });
    		} else {
    			$$invalidate(3, validated = true);
    			$$invalidate(0, activeItem = data[params.itemid]);
    			set_store_value(activeColor, $activeColor = activeItem.featuredColor, $activeColor);
    			set_store_value(activeFacade, $activeFacade = activeItem.featuredFace, $activeFacade);

    			for (let [col, facades] of Object.entries(activeItem.imgs)) {
    				console.log(facades);

    				for (let [facade, id] of Object.entries(facades)) {
    					let path = "creators/" + params.userid + "/merch/" + params.itemid + "/" + facade + "-" + col;
    					console.log(id);
    					let link = uuidToImageLink(id, path);
    					console.log(link);
    					$$invalidate(0, activeItem.imgs[col][facade] = link, activeItem);
    					console.log(activeItem.imgs[col][facade]);
    				}
    			}

    			$$invalidate(0, activeItem);
    			console.log(activeItem);
    		}
    	});

    	const addToCart = () => {
    		if ($activeSize == "") {
    			notification.set({
    				accentColor: "error",
    				title: "Error",
    				content: "Please Select Size"
    			});

    			return;
    		}

    		cart.add({
    			[params.userid + "-" + params.itemid]: {
    				...activeItem,
    				quantity: $activeQuantity,
    				color: $activeColor,
    				size: $activeSize
    			}
    		});

    		console.log($cart);

    		notification.set({
    			accentColor: "success",
    			title: "Success",
    			content: ({
    				en: "Article Added to Cart",
    				fr: "Article ajouté au panier "
    			})[$lang],
    			uniqueActions: [
    				{
    					text: ({ en: "Checkout", fr: "Commander" })[$lang],
    					func: () => {
    						navigate("/cart");
    					}
    				}
    			]
    		});
    	};

    	console.log("doing init");
    	let show = false;
    	let quantity = 1;
    	let rotateLeft = false;
    	let rotateRight = false;
    	let rotating = false;
    	const activeColor = writable("Black");
    	validate_store(activeColor, "activeColor");
    	component_subscribe($$self, activeColor, value => $$invalidate(11, $activeColor = value));
    	const activeFacade = writable("front");
    	validate_store(activeFacade, "activeFacade");
    	component_subscribe($$self, activeFacade, value => $$invalidate(12, $activeFacade = value));
    	const activeSize = writable("");
    	validate_store(activeSize, "activeSize");
    	component_subscribe($$self, activeSize, value => $$invalidate(13, $activeSize = value));
    	const activeQuantity = writable(1);
    	validate_store(activeQuantity, "activeQuantity");
    	component_subscribe($$self, activeQuantity, value => $$invalidate(14, $activeQuantity = value));
    	console.log("ending iti");

    	const addWishlist = nid => {
    		if ($user == 0 || $user == undefined) {
    			navigate("/signin?backurl=/" + params.userid + "/merch/" + activeItem.id);
    			return;
    		}

    		if ($user.docData.wishlist && Object.keys($user.docData.wishlist).includes(nid)) {
    			// remove it
    			console.log("removing " + nid);

    			db.collection("users").doc($user.uid).update({
    				["wishlist." + nid]: firebase.firestore.FieldValue.delete()
    			});

    			delete $user.docData.wishlist[nid];
    			user.set($user);
    		} else {
    			notification.set({
    				accentColor: "success",
    				title: "success",
    				content: "Article Added to WishList"
    			});

    			console.log("adding " + nid);
    			db.collection("users").doc($user.uid).set({ wishlist: { [nid]: true } }, { merge: true });

    			set_store_value(
    				user,
    				$user = {
    					...$user,
    					docData: {
    						...$user.docData,
    						wishlist: { ...$user.docData.wishlist, [nid]: true }
    					}
    				},
    				$user
    			);
    		}
    	};

    	let rotate = type => {
    		$activeFacade == "front"
    		? set_store_value(activeFacade, $activeFacade = "back", $activeFacade)
    		: set_store_value(activeFacade, $activeFacade = "front", $activeFacade);

    		if (type == "left") {
    			$$invalidate(5, rotateLeft = true);
    			$$invalidate(7, rotating = true);
    		} else {
    			$$invalidate(6, rotateRight = true);
    			$$invalidate(7, rotating = true);
    		}

    		console.log(rotateLeft, rotateRight);

    		setTimeout(
    			() => {
    				$$invalidate(5, rotateLeft = false);
    				$$invalidate(6, rotateRight = false);
    				$$invalidate(7, rotating = false);
    			},
    			1000
    		);
    	};

    	console.log("ended script");
    	let topFinal = 0;
    	let leftFinal = 0;
    	let scale = 1;
    	let duration = 500;

    	let mouse_position = (e, DifWidth) => {
    		let myElement = e.target.getBoundingClientRect();
    		e.target.offsetTop;
    		e.target.offsetLeft;
    		let body = document.body;
    		let docEl = document.documentElement;
    		let scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
    		let scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
    		let clientTop = docEl.clientTop || body.clientTop || 0;
    		let clientLeft = docEl.clientLeft || body.clientLeft || 0;

    		//position of element
    		let top = myElement.top + scrollTop - clientTop;

    		let left = myElement.left + scrollLeft - clientLeft;
    		let winEv = window.event;

    		//position of mouse
    		let posY = winEv.clientY + scrollTop - clientTop;

    		let posX = winEv.clientX + scrollLeft - clientLeft;
    		$$invalidate(8, topFinal = top - posY + DifWidth);
    		$$invalidate(9, leftFinal = left - posX + DifWidth);
    		$$invalidate(10, scale = 2.5);
    	};

    	let clientX;
    	let clientY;

    	let touch_position = (e, DifWidth) => {
    		let myElement = e.target.getBoundingClientRect();
    		e.target.offsetTop;
    		e.target.offsetLeft;
    		let body = document.body;
    		let docEl = document.documentElement;
    		let scrollTop = window.pageYOffset || docEl.scrollTop || body.scrollTop;
    		let scrollLeft = window.pageXOffset || docEl.scrollLeft || body.scrollLeft;
    		let clientTop = docEl.clientTop || body.clientTop || 0;
    		let clientLeft = docEl.clientLeft || body.clientLeft || 0;

    		//position of element
    		let top = myElement.top + scrollTop - clientTop;

    		let left = myElement.left + scrollLeft - clientLeft;
    		clientX = e.touches[0].clientX;
    		clientY = e.touches[0].clientY;
    		$$invalidate(8, topFinal = top - clientY + DifWidth);
    		$$invalidate(9, leftFinal = left - clientX + DifWidth);
    		console.log(topFinal, leftFinal);
    		$$invalidate(10, scale = 2.5);
    	};

    	const writable_props = ["activeItem", "params", "creatorData"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<SingleProduct> was created with unknown prop '${key}'`);
    	});

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	const mousemove_handler = e => {
    		let DifWidth = e.target.offsetWidth - document.querySelector(".product_img").offsetWidth + e.target.offsetLeft;
    		mouse_position(e, DifWidth);
    	};

    	const touchmove_handler = e => {
    		let DifWidth = e.target.offsetWidth - document.querySelector(".product_img").offsetWidth + e.target.offsetLeft;
    		touch_position(e, DifWidth);
    	};

    	const touchstart_handler = e => {
    		let DifWidth = e.target.offsetWidth - document.querySelector(".product_img").offsetWidth + e.target.offsetLeft;
    		touch_position(e, DifWidth);
    	};

    	const touchend_handler = e => {
    		$$invalidate(10, scale = 1);
    		$$invalidate(8, topFinal = 0);
    		$$invalidate(9, leftFinal = 0);
    	};

    	const mouseleave_handler = e => {
    		$$invalidate(10, scale = 1);
    		$$invalidate(8, topFinal = 0);
    		$$invalidate(9, leftFinal = 0);
    	};

    	const click_handler_1 = () => {
    		rotate("left");
    	};

    	const click_handler_2 = facade => {
    		set_store_value(activeFacade, $activeFacade = facade, $activeFacade);
    	};

    	const click_handler_3 = () => {
    		rotate("right");
    	};

    	const mouseenter_handler = () => {
    		$$invalidate(4, show = true);
    	};

    	const mouseleave_handler_1 = () => {
    		$$invalidate(4, show = false);
    	};

    	const click_handler_4 = color => {
    		set_store_value(activeColor, $activeColor = color, $activeColor);
    	};

    	const click_handler_5 = (size, e) => {
    		set_store_value(activeSize, $activeSize = size, $activeSize);
    	};

    	const click_handler_6 = (size, e) => {
    		set_store_value(activeSize, $activeSize = size, $activeSize);
    	};

    	const click_handler_7 = () => {
    		quantity <= 1
    		? set_store_value(activeQuantity, $activeQuantity = 1, $activeQuantity)
    		: set_store_value(activeQuantity, $activeQuantity -= 1, $activeQuantity);
    	};

    	function input_input_handler() {
    		$activeQuantity = to_number(this.value);
    		activeQuantity.set($activeQuantity);
    	}

    	const click_handler_8 = e => {
    		set_store_value(activeQuantity, $activeQuantity += 1, $activeQuantity);
    	};

    	$$self.$$set = $$props => {
    		if ("activeItem" in $$props) $$invalidate(0, activeItem = $$props.activeItem);
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    		if ("creatorData" in $$props) $$invalidate(2, creatorData = $$props.creatorData);
    	};

    	$$self.$capture_state = () => ({
    		activeItem,
    		params,
    		creatorData,
    		lang,
    		cart,
    		onMount,
    		dbWrapper,
    		user,
    		db,
    		uuidToImageLink,
    		colors,
    		notification,
    		generateDeliveryDate,
    		navigate,
    		routlink: link,
    		writable,
    		convert,
    		filter,
    		minDdate,
    		maxDdate,
    		validated,
    		addToCart,
    		show,
    		quantity,
    		rotateLeft,
    		rotateRight,
    		rotating,
    		activeColor,
    		activeFacade,
    		activeSize,
    		activeQuantity,
    		addWishlist,
    		rotate,
    		topFinal,
    		leftFinal,
    		scale,
    		duration,
    		mouse_position,
    		clientX,
    		clientY,
    		touch_position,
    		$activeColor,
    		$activeFacade,
    		$activeSize,
    		$activeQuantity,
    		$cart,
    		$lang,
    		$user
    	});

    	$$self.$inject_state = $$props => {
    		if ("activeItem" in $$props) $$invalidate(0, activeItem = $$props.activeItem);
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    		if ("creatorData" in $$props) $$invalidate(2, creatorData = $$props.creatorData);
    		if ("filter" in $$props) $$invalidate(17, filter = $$props.filter);
    		if ("minDdate" in $$props) $$invalidate(18, minDdate = $$props.minDdate);
    		if ("maxDdate" in $$props) $$invalidate(19, maxDdate = $$props.maxDdate);
    		if ("validated" in $$props) $$invalidate(3, validated = $$props.validated);
    		if ("show" in $$props) $$invalidate(4, show = $$props.show);
    		if ("quantity" in $$props) $$invalidate(21, quantity = $$props.quantity);
    		if ("rotateLeft" in $$props) $$invalidate(5, rotateLeft = $$props.rotateLeft);
    		if ("rotateRight" in $$props) $$invalidate(6, rotateRight = $$props.rotateRight);
    		if ("rotating" in $$props) $$invalidate(7, rotating = $$props.rotating);
    		if ("rotate" in $$props) $$invalidate(27, rotate = $$props.rotate);
    		if ("topFinal" in $$props) $$invalidate(8, topFinal = $$props.topFinal);
    		if ("leftFinal" in $$props) $$invalidate(9, leftFinal = $$props.leftFinal);
    		if ("scale" in $$props) $$invalidate(10, scale = $$props.scale);
    		if ("duration" in $$props) duration = $$props.duration;
    		if ("mouse_position" in $$props) $$invalidate(28, mouse_position = $$props.mouse_position);
    		if ("clientX" in $$props) clientX = $$props.clientX;
    		if ("clientY" in $$props) clientY = $$props.clientY;
    		if ("touch_position" in $$props) $$invalidate(29, touch_position = $$props.touch_position);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		activeItem,
    		params,
    		creatorData,
    		validated,
    		show,
    		rotateLeft,
    		rotateRight,
    		rotating,
    		topFinal,
    		leftFinal,
    		scale,
    		$activeColor,
    		$activeFacade,
    		$activeSize,
    		$activeQuantity,
    		$lang,
    		$user,
    		filter,
    		minDdate,
    		maxDdate,
    		addToCart,
    		quantity,
    		activeColor,
    		activeFacade,
    		activeSize,
    		activeQuantity,
    		addWishlist,
    		rotate,
    		mouse_position,
    		touch_position,
    		click_handler,
    		mousemove_handler,
    		touchmove_handler,
    		touchstart_handler,
    		touchend_handler,
    		mouseleave_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		mouseenter_handler,
    		mouseleave_handler_1,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		input_input_handler,
    		click_handler_8
    	];
    }

    class SingleProduct extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, { activeItem: 0, params: 1, creatorData: 2 }, [-1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SingleProduct",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*activeItem*/ ctx[0] === undefined && !("activeItem" in props)) {
    			console_1$1.warn("<SingleProduct> was created without expected prop 'activeItem'");
    		}

    		if (/*params*/ ctx[1] === undefined && !("params" in props)) {
    			console_1$1.warn("<SingleProduct> was created without expected prop 'params'");
    		}

    		if (/*creatorData*/ ctx[2] === undefined && !("creatorData" in props)) {
    			console_1$1.warn("<SingleProduct> was created without expected prop 'creatorData'");
    		}
    	}

    	get activeItem() {
    		throw new Error("<SingleProduct>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeItem(value) {
    		throw new Error("<SingleProduct>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get params() {
    		throw new Error("<SingleProduct>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<SingleProduct>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get creatorData() {
    		throw new Error("<SingleProduct>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set creatorData(value) {
    		throw new Error("<SingleProduct>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\MerchPage\merch.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$2, console: console_1$2 } = globals;
    const file$3 = "src\\components\\MerchPage\\merch.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[12] = list;
    	child_ctx[13] = i;
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (391:16) {:else}
    function create_else_block_1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "none";
    			add_location(div, file$3, 391, 24, 11115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(391:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (383:20) {#if creatorData[media.type] && creatorData[media.type].length > 0}
    function create_if_block_1$2(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			t = space();
    			set_style(img, "width", /*media*/ ctx[17].type == "baaz" ? "50px" : " 30px");
    			if (img.src !== (img_src_value = "/img/socialMedia/" + /*media*/ ctx[17].type + ".svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-6d6bw4");
    			add_location(img, file$3, 384, 28, 10807);
    			attr_dev(a, "target", "_blank");

    			attr_dev(a, "href", a_href_value = /*creatorData*/ ctx[0][/*media*/ ctx[17].type].includes("http")
    			? /*creatorData*/ ctx[0][/*media*/ ctx[17].type]
    			: "https://" + /*creatorData*/ ctx[0][/*media*/ ctx[17].type]);

    			attr_dev(a, "class", "svelte-6d6bw4");
    			add_location(a, file$3, 383, 24, 10645);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*creatorData*/ 1 && a_href_value !== (a_href_value = /*creatorData*/ ctx[0][/*media*/ ctx[17].type].includes("http")
    			? /*creatorData*/ ctx[0][/*media*/ ctx[17].type]
    			: "https://" + /*creatorData*/ ctx[0][/*media*/ ctx[17].type])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(383:20) {#if creatorData[media.type] && creatorData[media.type].length > 0}",
    		ctx
    	});

    	return block;
    }

    // (382:16) {#each socialMedias as media}
    function create_each_block_2$1(ctx) {
    	let if_block_anchor;
    	let if_block = /*creatorData*/ ctx[0][/*media*/ ctx[17].type] && /*creatorData*/ ctx[0][/*media*/ ctx[17].type].length > 0 && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*creatorData*/ ctx[0][/*media*/ ctx[17].type] && /*creatorData*/ ctx[0][/*media*/ ctx[17].type].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(382:16) {#each socialMedias as media}",
    		ctx
    	});

    	return block;
    }

    // (467:28) {:else}
    function create_else_block$2(ctx) {
    	let span;
    	let t0_value = /*product*/ ctx[11].price + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text("\r\n                                    TND");
    			attr_dev(span, "class", "current_price svelte-6d6bw4");
    			add_location(span, file$3, 467, 32, 15296);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*displayProducts*/ 4 && t0_value !== (t0_value = /*product*/ ctx[11].price + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(467:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (458:28) {#if product.discount}
    function create_if_block$2(ctx) {
    	let span0;
    	let t0_value = /*product*/ ctx[11].price * (1 - /*product*/ ctx[11].discount) + "";
    	let t0;
    	let t1;
    	let t2;
    	let span3;
    	let span1;
    	let t3_value = /*product*/ ctx[11].price + "";
    	let t3;
    	let t4;
    	let span2;
    	let t5;
    	let t6_value = /*product*/ ctx[11].discount * 100 + "";
    	let t6;
    	let t7;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text("\r\n                                    TND");
    			t2 = space();
    			span3 = element("span");
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			span2 = element("span");
    			t5 = text("-");
    			t6 = text(t6_value);
    			t7 = text("%");
    			attr_dev(span0, "class", "current_price svelte-6d6bw4");
    			add_location(span0, file$3, 458, 32, 14747);
    			attr_dev(span1, "class", "price svelte-6d6bw4");
    			add_location(span1, file$3, 462, 36, 14996);
    			attr_dev(span2, "class", "percentage_discount svelte-6d6bw4");
    			add_location(span2, file$3, 463, 36, 15076);
    			attr_dev(span3, "class", "old_price");
    			add_location(span3, file$3, 461, 32, 14934);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, span3, anchor);
    			append_dev(span3, span1);
    			append_dev(span1, t3);
    			append_dev(span3, t4);
    			append_dev(span3, span2);
    			append_dev(span2, t5);
    			append_dev(span2, t6);
    			append_dev(span2, t7);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*displayProducts*/ 4 && t0_value !== (t0_value = /*product*/ ctx[11].price * (1 - /*product*/ ctx[11].discount) + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*displayProducts*/ 4 && t3_value !== (t3_value = /*product*/ ctx[11].price + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*displayProducts*/ 4 && t6_value !== (t6_value = /*product*/ ctx[11].discount * 100 + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(span3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(458:28) {#if product.discount}",
    		ctx
    	});

    	return block;
    }

    // (474:24) {#each product.colors as color}
    function create_each_block_1$1(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[8](/*product*/ ctx[11], /*color*/ ctx[14], /*each_value*/ ctx[12], /*product_index*/ ctx[13]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t = space();
    			attr_dev(div0, "class", "color svelte-6d6bw4");
    			set_style(div0, "background-color", colors[/*color*/ ctx[14].toLowerCase()]);
    			add_location(div0, file$3, 481, 32, 15985);
    			attr_dev(div1, "class", "color_border svelte-6d6bw4");
    			set_style(div1, "border", "0px solid black");
    			toggle_class(div1, "active", /*product*/ ctx[11].color == /*color*/ ctx[14]);
    			add_location(div1, file$3, 474, 28, 15609);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*displayProducts*/ 4) {
    				set_style(div0, "background-color", colors[/*color*/ ctx[14].toLowerCase()]);
    			}

    			if (dirty & /*displayProducts*/ 4) {
    				toggle_class(div1, "active", /*product*/ ctx[11].color == /*color*/ ctx[14]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(474:24) {#each product.colors as color}",
    		ctx
    	});

    	return block;
    }

    // (407:12) {#each displayProducts as product}
    function create_each_block$1(ctx) {
    	let div5;
    	let a0;
    	let img0;
    	let img0_src_value;
    	let a0_href_value;
    	let t0;
    	let div2;
    	let div0;
    	let img1;
    	let img1_src_value;
    	let t1;
    	let div1;
    	let img2;
    	let img2_src_value;
    	let img2_style_value;
    	let t2;
    	let a1;
    	let span;
    	let t3_value = /*product*/ ctx[11].name + "";
    	let t3;
    	let t4;
    	let div3;
    	let a1_href_value;
    	let t5;
    	let div4;
    	let t6;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[6](/*product*/ ctx[11]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[7](/*product*/ ctx[11]);
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*product*/ ctx[11].discount) return create_if_block$2;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);
    	let each_value_1 = /*product*/ ctx[11].colors;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			a0 = element("a");
    			img0 = element("img");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			img1 = element("img");
    			t1 = space();
    			div1 = element("div");
    			img2 = element("img");
    			t2 = space();
    			a1 = element("a");
    			span = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			div3 = element("div");
    			if_block.c();
    			t5 = space();
    			div4 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			attr_dev(img0, "class", "product_img svelte-6d6bw4");

    			if (img0.src !== (img0_src_value = /*product*/ ctx[11].imgs[/*product*/ ctx[11].color
    			? /*product*/ ctx[11].color
    			: /*product*/ ctx[11].featuredColor][/*product*/ ctx[11].featuredFace])) attr_dev(img0, "src", img0_src_value);

    			attr_dev(img0, "alt", "product");
    			add_location(img0, file$3, 409, 24, 11801);
    			attr_dev(a0, "href", a0_href_value = "/" + /*params*/ ctx[1].userid + "/merch/" + /*product*/ ctx[11].id);
    			add_location(a0, file$3, 408, 20, 11720);
    			if (img1.src !== (img1_src_value = "/img/misc/cart.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "cart");
    			attr_dev(img1, "class", "svelte-6d6bw4");
    			add_location(img1, file$3, 417, 28, 12170);
    			attr_dev(div0, "class", "icon1 svelte-6d6bw4");
    			add_location(div0, file$3, 416, 20, 12120);

    			if (img2.src !== (img2_src_value = /*$user*/ ctx[3] && /*$user*/ ctx[3].docData && /*$user*/ ctx[3].docData.wishlist && /*$user*/ ctx[3].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*product*/ ctx[11].id]
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/heart.png")) attr_dev(img2, "src", img2_src_value);

    			attr_dev(img2, "style", img2_style_value = /*$user*/ ctx[3] && /*$user*/ ctx[3].docData && /*$user*/ ctx[3].docData.wishlist && /*$user*/ ctx[3].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*product*/ ctx[11].id]
    			? "filter:none"
    			: "filter:invert(100%) sepia(0%) saturate(7428%) hue-rotate(68deg) brightness(101%) contrast(87%);");

    			attr_dev(img2, "alt", "heart");
    			attr_dev(img2, "class", "svelte-6d6bw4");
    			add_location(img2, file$3, 448, 28, 13849);
    			attr_dev(div1, "class", "icon2 svelte-6d6bw4");
    			add_location(div1, file$3, 443, 24, 13612);
    			attr_dev(div2, "class", "cartBtns svelte-6d6bw4");
    			add_location(div2, file$3, 415, 20, 12075);
    			attr_dev(span, "class", "product_title svelte-6d6bw4");
    			add_location(span, file$3, 455, 24, 14559);
    			attr_dev(div3, "class", "product_price svelte-6d6bw4");
    			add_location(div3, file$3, 456, 24, 14634);
    			attr_dev(a1, "href", a1_href_value = "/" + /*params*/ ctx[1].userid + "/merch/" + /*product*/ ctx[11].id);
    			attr_dev(a1, "class", "productInfo svelte-6d6bw4");
    			add_location(a1, file$3, 454, 20, 14458);
    			attr_dev(div4, "class", "colors svelte-6d6bw4");
    			add_location(div4, file$3, 472, 20, 15502);
    			attr_dev(div5, "class", "single_product svelte-6d6bw4");
    			add_location(div5, file$3, 407, 16, 11670);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, a0);
    			append_dev(a0, img0);
    			append_dev(div5, t0);
    			append_dev(div5, div2);
    			append_dev(div2, div0);
    			append_dev(div0, img1);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, img2);
    			append_dev(div5, t2);
    			append_dev(div5, a1);
    			append_dev(a1, span);
    			append_dev(span, t3);
    			append_dev(a1, t4);
    			append_dev(a1, div3);
    			if_block.m(div3, null);
    			append_dev(div5, t5);
    			append_dev(div5, div4);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div4, null);
    			}

    			append_dev(div5, t6);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					listen_dev(img1, "click", click_handler, false, false, false),
    					listen_dev(div1, "click", click_handler_1, false, false, false),
    					action_destroyer(link.call(null, a1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*displayProducts*/ 4 && img0.src !== (img0_src_value = /*product*/ ctx[11].imgs[/*product*/ ctx[11].color
    			? /*product*/ ctx[11].color
    			: /*product*/ ctx[11].featuredColor][/*product*/ ctx[11].featuredFace])) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty & /*params, displayProducts*/ 6 && a0_href_value !== (a0_href_value = "/" + /*params*/ ctx[1].userid + "/merch/" + /*product*/ ctx[11].id)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*$user, params, displayProducts*/ 14 && img2.src !== (img2_src_value = /*$user*/ ctx[3] && /*$user*/ ctx[3].docData && /*$user*/ ctx[3].docData.wishlist && /*$user*/ ctx[3].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*product*/ ctx[11].id]
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/heart.png")) {
    				attr_dev(img2, "src", img2_src_value);
    			}

    			if (dirty & /*$user, params, displayProducts*/ 14 && img2_style_value !== (img2_style_value = /*$user*/ ctx[3] && /*$user*/ ctx[3].docData && /*$user*/ ctx[3].docData.wishlist && /*$user*/ ctx[3].docData?.wishlist[/*params*/ ctx[1].userid + "-" + /*product*/ ctx[11].id]
    			? "filter:none"
    			: "filter:invert(100%) sepia(0%) saturate(7428%) hue-rotate(68deg) brightness(101%) contrast(87%);")) {
    				attr_dev(img2, "style", img2_style_value);
    			}

    			if (dirty & /*displayProducts*/ 4 && t3_value !== (t3_value = /*product*/ ctx[11].name + "")) set_data_dev(t3, t3_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			}

    			if (dirty & /*params, displayProducts*/ 6 && a1_href_value !== (a1_href_value = "/" + /*params*/ ctx[1].userid + "/merch/" + /*product*/ ctx[11].id)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*displayProducts, colors*/ 4) {
    				each_value_1 = /*product*/ ctx[11].colors;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div4, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if_block.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(407:12) {#each displayProducts as product}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div8;
    	let div3;
    	let div0;
    	let h20;
    	let t0_value = ({ en: "Info", fr: "Info" })[/*$lang*/ ctx[4]] + "";
    	let t0;
    	let t1;
    	let hr0;
    	let t2;
    	let p;

    	let t3_value = (/*creatorData*/ ctx[0].description
    	? /*creatorData*/ ctx[0].description
    	: ({
    			en: "This user did not write anything about themselves",
    			fr: "Cet utilisateur n'a rien écrit sur lui-même "
    		})[/*$lang*/ ctx[4]]) + "";

    	let t3;
    	let t4;
    	let div2;
    	let h21;

    	let t5_value = ({
    		en: "Social Media",
    		fr: "Réseau Socieaux"
    	})[/*$lang*/ ctx[4]] + "";

    	let t5;
    	let t6;
    	let hr1;
    	let t7;
    	let div1;
    	let t8;
    	let div7;
    	let div5;
    	let div4;

    	let t9_value = ({
    		en: "Available Now",
    		fr: "Disponible maintenant"
    	})[/*$lang*/ ctx[4]] + "";

    	let t9;
    	let div4_style_value;
    	let t10;
    	let hr2;
    	let t11;
    	let div6;
    	let each_value_2 = socialMedias;
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let each0_else = null;

    	if (!each_value_2.length) {
    		each0_else = create_else_block_1(ctx);
    	}

    	let each_value = /*displayProducts*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			hr0 = element("hr");
    			t2 = space();
    			p = element("p");
    			t3 = text(t3_value);
    			t4 = space();
    			div2 = element("div");
    			h21 = element("h2");
    			t5 = text(t5_value);
    			t6 = space();
    			hr1 = element("hr");
    			t7 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			if (each0_else) {
    				each0_else.c();
    			}

    			t8 = space();
    			div7 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			hr2 = element("hr");
    			t11 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h20, "class", "info_title");
    			add_location(h20, file$3, 367, 12, 9865);
    			add_location(hr0, file$3, 368, 12, 9942);
    			attr_dev(p, "class", "u_desc svelte-6d6bw4");
    			add_location(p, file$3, 369, 12, 9962);
    			attr_dev(div0, "class", "info");
    			add_location(div0, file$3, 366, 8, 9833);
    			attr_dev(h21, "class", "social_title");
    			add_location(h21, file$3, 375, 12, 10254);
    			add_location(hr1, file$3, 378, 12, 10384);
    			attr_dev(div1, "class", "social_icons svelte-6d6bw4");
    			add_location(div1, file$3, 380, 12, 10457);
    			attr_dev(div2, "class", "socialMedia");
    			add_location(div2, file$3, 374, 8, 10215);
    			attr_dev(div3, "class", "u_info svelte-6d6bw4");
    			add_location(div3, file$3, 365, 4, 9803);
    			attr_dev(div4, "class", "title svelte-6d6bw4");
    			attr_dev(div4, "style", div4_style_value = "background-color : " + /*creatorData*/ ctx[0].accentColor);
    			add_location(div4, file$3, 399, 8, 11292);
    			attr_dev(hr2, "class", "title_border svelte-6d6bw4");
    			set_style(hr2, "border-top", "1px solid " + /*creatorData*/ ctx[0].accentColor);
    			add_location(hr2, file$3, 402, 12, 11469);
    			attr_dev(div5, "class", "title_container svelte-6d6bw4");
    			add_location(div5, file$3, 398, 8, 11253);
    			attr_dev(div6, "class", "u_products svelte-6d6bw4");
    			add_location(div6, file$3, 405, 8, 11580);
    			attr_dev(div7, "class", "products_container");
    			add_location(div7, file$3, 397, 4, 11211);
    			attr_dev(div8, "class", "container svelte-6d6bw4");
    			add_location(div8, file$3, 364, 0, 9774);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div0, t1);
    			append_dev(div0, hr0);
    			append_dev(div0, t2);
    			append_dev(div0, p);
    			append_dev(p, t3);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t5);
    			append_dev(div2, t6);
    			append_dev(div2, hr1);
    			append_dev(div2, t7);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div1, null);
    			}

    			if (each0_else) {
    				each0_else.m(div1, null);
    			}

    			append_dev(div8, t8);
    			append_dev(div8, div7);
    			append_dev(div7, div5);
    			append_dev(div5, div4);
    			append_dev(div4, t9);
    			append_dev(div5, t10);
    			append_dev(div5, hr2);
    			append_dev(div7, t11);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$lang*/ 16 && t0_value !== (t0_value = ({ en: "Info", fr: "Info" })[/*$lang*/ ctx[4]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*creatorData, $lang*/ 17 && t3_value !== (t3_value = (/*creatorData*/ ctx[0].description
    			? /*creatorData*/ ctx[0].description
    			: ({
    					en: "This user did not write anything about themselves",
    					fr: "Cet utilisateur n'a rien écrit sur lui-même "
    				})[/*$lang*/ ctx[4]]) + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*$lang*/ 16 && t5_value !== (t5_value = ({
    				en: "Social Media",
    				fr: "Réseau Socieaux"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*creatorData, socialMedias*/ 1) {
    				each_value_2 = socialMedias;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$1(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;

    				if (each_value_2.length) {
    					if (each0_else) {
    						each0_else.d(1);
    						each0_else = null;
    					}
    				} else if (!each0_else) {
    					each0_else = create_else_block_1(ctx);
    					each0_else.c();
    					each0_else.m(div1, null);
    				}
    			}

    			if (dirty & /*$lang*/ 16 && t9_value !== (t9_value = ({
    				en: "Available Now",
    				fr: "Disponible maintenant"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*creatorData*/ 1 && div4_style_value !== (div4_style_value = "background-color : " + /*creatorData*/ ctx[0].accentColor)) {
    				attr_dev(div4, "style", div4_style_value);
    			}

    			if (dirty & /*creatorData*/ 1) {
    				set_style(hr2, "border-top", "1px solid " + /*creatorData*/ ctx[0].accentColor);
    			}

    			if (dirty & /*displayProducts, colors, params, addWishlist, $user, cart, notification, $lang, navigate*/ 62) {
    				each_value = /*displayProducts*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_each(each_blocks_1, detaching);
    			if (each0_else) each0_else.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $user;
    	let $lang;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(3, $user = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(4, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Merch", slots, []);
    	let { params = {} } = $$props;
    	let { creatorData = {} } = $$props;
    	let loaded = false;
    	let displayProducts = [];

    	if (creatorData.accentColor == undefined || creatorData.accentColor == null || creatorData.accentColor == "") {
    		creatorData.accentColor = "#45b877";
    	}

    	onMount(() => {
    		analytics.logEvent("store_view", { creator: params.userid });
    	});

    	//change the global(:root) var of css
    	let filter = convert(creatorData.accentColor).replace("filter:", "").replace(";", "");

    	document.documentElement.style.setProperty("--AccentColorFilter", filter);
    	console.log(filter);

    	dbWrapper.get("/creators/" + params.userid + "/merch/all").then(data => {
    		console.log("got " + "/creators/" + params.userid + "/merch/all");
    		console.log(data);

    		if (data == undefined) {
    			$$invalidate(2, displayProducts = []);
    			return;
    		}

    		$$invalidate(2, displayProducts = Object.entries(data).map(([key, value]) => {
    			value.id = key;

    			for (let [col, facades] of Object.entries(value.imgs)) {
    				for (let [facade, id] of Object.entries(facades)) {
    					let path = "creators/" + params.userid + "/merch/" + key + "/" + facade + "-" + col;
    					value.imgs[col][facade] = uuidToImageLink(id, path);
    				}
    			}

    			return value;
    		}));

    		console.log(displayProducts);
    		$$invalidate(2, displayProducts = displayProducts.filter(item => !item.deleted));
    	});

    	const addWishlist = nid => {
    		if ($user == 0 || $user == undefined) {
    			navigate("/signin?backurl=/" + params.userid + "/merch");
    			return;
    		}

    		if ($user.docData.wishlist && Object.keys($user.docData.wishlist).includes(nid)) {
    			// remove it
    			db.collection("users").doc($user.uid).update({
    				["wishlist." + nid]: firebase.firestore.FieldValue.delete()
    			});

    			delete $user.docData.wishlist[nid];
    			user.set($user);
    		} else {
    			notification.set({
    				accentColor: "success",
    				title: "success",
    				content: {
    					en: "Article Added to Wishlist",
    					fr: "Article ajouté à la Liste d'envies"
    				}
    			});

    			db.collection("users").doc($user.uid).set({ wishlist: { [nid]: true } }, { merge: true });

    			set_store_value(
    				user,
    				$user = {
    					...$user,
    					docData: {
    						...$user.docData,
    						wishlist: { ...$user.docData.wishlist, [nid]: true }
    					}
    				},
    				$user
    			);
    		}
    	};

    	const writable_props = ["params", "creatorData"];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<Merch> was created with unknown prop '${key}'`);
    	});

    	const click_handler = product => {
    		cart.add({
    			[params.userid + "-" + product.id]: { ...product, quantity: 1 }
    		});

    		notification.set({
    			accentColor: "success",
    			title: "Success",
    			content: ({
    				en: "Article Added to Cart",
    				fr: "Article ajouté au panier "
    			})[$lang],
    			uniqueActions: [
    				{
    					text: ({ en: "Checkout", fr: "Commander" })[$lang],
    					func: () => {
    						navigate("/cart");
    					}
    				}
    			]
    		});
    	};

    	const click_handler_1 = product => {
    		addWishlist(params.userid + "-" + product.id);
    	};

    	const click_handler_2 = (product, color, each_value, product_index) => {
    		$$invalidate(2, each_value[product_index].color = color, displayProducts);
    	};

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    	};

    	$$self.$capture_state = () => ({
    		hexToRgb,
    		convert,
    		writable,
    		lang,
    		cart,
    		onMount,
    		Single: SingleProduct,
    		db,
    		dbWrapper,
    		user,
    		analytics,
    		uuidToImageLink,
    		socialMedias,
    		notification,
    		colors,
    		link,
    		navigate,
    		params,
    		creatorData,
    		loaded,
    		displayProducts,
    		filter,
    		addWishlist,
    		$user,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(1, params = $$props.params);
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    		if ("loaded" in $$props) loaded = $$props.loaded;
    		if ("displayProducts" in $$props) $$invalidate(2, displayProducts = $$props.displayProducts);
    		if ("filter" in $$props) filter = $$props.filter;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		creatorData,
    		params,
    		displayProducts,
    		$user,
    		$lang,
    		addWishlist,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Merch extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, { params: 1, creatorData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Merch",
    			options,
    			id: create_fragment$7.name
    		});
    	}

    	get params() {
    		throw new Error("<Merch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Merch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get creatorData() {
    		throw new Error("<Merch>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set creatorData(value) {
    		throw new Error("<Merch>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\misc\MaterialSpinner.svelte generated by Svelte v3.32.3 */

    const file$4 = "src\\components\\misc\\MaterialSpinner.svelte";

    function create_fragment$8(ctx) {
    	let svg;
    	let circle;
    	let svg_style_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "path svelte-bzpqu");
    			attr_dev(circle, "fill", "none");
    			attr_dev(circle, "stroke-width", "6");
    			attr_dev(circle, "stroke-linecap", "round");
    			attr_dev(circle, "cx", "33");
    			attr_dev(circle, "cy", "33");
    			attr_dev(circle, "r", "30");
    			add_location(circle, file$4, 61, 4, 1259);
    			attr_dev(svg, "class", "spinner svelte-bzpqu");
    			attr_dev(svg, "style", svg_style_value = "height:" + /*height*/ ctx[0] + "; width:" + /*width*/ ctx[1] + ";");
    			attr_dev(svg, "viewBox", "0 0 66 66");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$4, 56, 2, 1103);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*height, width*/ 3 && svg_style_value !== (svg_style_value = "height:" + /*height*/ ctx[0] + "; width:" + /*width*/ ctx[1] + ";")) {
    				attr_dev(svg, "style", svg_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MaterialSpinner", slots, []);
    	let { height = "100%" } = $$props;
    	let { width = "100%" } = $$props;
    	const writable_props = ["height", "width"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MaterialSpinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("width" in $$props) $$invalidate(1, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({ height, width });

    	$$self.$inject_state = $$props => {
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("width" in $$props) $$invalidate(1, width = $$props.width);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [height, width];
    }

    class MaterialSpinner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, { height: 0, width: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MaterialSpinner",
    			options,
    			id: create_fragment$8.name
    		});
    	}

    	get height() {
    		throw new Error("<MaterialSpinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<MaterialSpinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get width() {
    		throw new Error("<MaterialSpinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<MaterialSpinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\misc\Cart.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$3 } = globals;
    const file$5 = "src\\components\\misc\\Cart.svelte";

    // (55:4) {#if $cart && $cart.items && Object.keys($cart.items).length > 0}
    function create_if_block$3(ctx) {
    	let div;
    	let t_value = Object.keys(/*$cart*/ ctx[1].items).length + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "number svelte-1m1jzog");
    			add_location(div, file$5, 55, 8, 4224);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$cart*/ 2 && t_value !== (t_value = Object.keys(/*$cart*/ ctx[1].items).length + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(55:4) {#if $cart && $cart.items && Object.keys($cart.items).length > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let a;
    	let div;
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let path3;
    	let path4;
    	let svg_style_value;
    	let t;
    	let show_if = /*$cart*/ ctx[1] && /*$cart*/ ctx[1].items && Object.keys(/*$cart*/ ctx[1].items).length > 0;
    	let mounted;
    	let dispose;
    	let if_block = show_if && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			a = element("a");
    			div = element("div");
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			path3 = svg_element("path");
    			path4 = svg_element("path");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(path0, "d", "m256 219.988281c5.519531 0 10-4.480469 10-10s-4.480469-10-10-10-10 4.480469-10 10 4.480469 10 10 10zm0 0");
    			add_location(path0, file$5, 48, 8, 1093);
    			attr_dev(path1, "d", "m472 139.988281h-59.136719l-90.96875-125.152343c-8.171875-14.003907-26.171875-18.988282-40.46875-11.070313-14.492187 8.050781-19.703125 26.304687-11.648437 40.800781.230468.410156.484375.804688.769531 1.179688l71.351563 94.242187h-171.796876l71.351563-94.242187c.28125-.375.539063-.769532.769531-1.179688 8.035156-14.460937 2.882813-32.730468-11.660156-40.808594-14.265625-7.902343-32.265625-2.921874-40.453125 11.070313l-90.972656 125.160156h-59.136719c-22.054688 0-40 17.945313-40 40 0 17.394531 11.289062 32.539063 27.191406 37.898438 1.695313 1.3125 3.8125 2.101562 6.117188 2.101562.460937 0 .894531.027344 1.347656.089844 4.304688.578125 7.714844 3.84375 8.496094 8.117187l34.019531 187.164063c2.597656 14.269531 15.011719 24.628906 29.519531 24.628906h298.617188c14.507812 0 26.921875-10.359375 29.519531-24.632812l34.019531-187.15625c.78125-4.277344 4.195313-7.542969 8.515625-8.121094.4375-.0625.871094-.089844 1.328125-.089844 2.320313 0 4.453125-.796875 6.148438-2.125 15.914062-5.394531 27.160156-20.511719 27.160156-37.875 0-22.054687-17.945312-40-40-40zm-185.011719-105.660156c-2.285156-4.730469-.511719-10.492187 4.136719-13.070313 4.839844-2.683593 10.941406-.953124 13.609375 3.855469.195313.359375.417969.703125.65625 1.03125l82.746094 113.84375h-21.15625zm-80.378906-8.179687c.238281-.328126.453125-.667969.652344-1.019532 2.675781-4.8125 8.78125-6.546875 13.601562-3.878906 4.65625 2.585938 6.4375 8.339844 4.148438 13.078125l-79.992188 105.660156h-21.15625zm265.390625 173.839843h-176c-5.523438 0-10 4.476563-10 10 0 5.523438 4.476562 9.898438 10 9.898438h154.398438c-.523438 1.492187-.9375 3.039062-1.226563 4.632812l-34.023437 187.257813c-.863282 4.757812-5.003907 8.210937-9.839844 8.210937h-298.617188c-4.839844 0-8.976562-3.453125-9.84375-8.207031l-34.019531-187.164062c-.289063-1.59375-.703125-3.140626-1.226563-4.628907h154.398438c5.523438 0 10-4.476562 10-10 0-5.523437-4.476562-10-10-10h-176c-11.121094 0-20-9.0625-20-20 0-11.027343 8.972656-20 20-20h432c11.027344 0 20 8.972657 20 20 0 11.105469-9.085938 20-20 20zm0 0");
    			add_location(path1, file$5, 49, 8, 1219);
    			attr_dev(path2, "d", "m256 249.988281c-16.542969 0-30 13.457031-30 30v80c0 16.542969 13.457031 30 30 30s30-13.457031 30-30v-80c0-16.574219-13.425781-30-30-30zm10 110c0 5.515625-4.484375 10-10 10s-10-4.484375-10-10v-80c0-5.515625 4.484375-10 10-10 5.519531 0 10 4.480469 10 10zm0 0");
    			add_location(path2, file$5, 50, 8, 3290);
    			attr_dev(path3, "d", "m356 389.988281c16.542969 0 30-13.457031 30-30v-80c0-16.574219-13.425781-30-30-30-16.542969 0-30 13.457031-30 30v80c0 16.542969 13.457031 30 30 30zm-10-110c0-5.515625 4.484375-10 10-10 5.519531 0 10 4.480469 10 10v80c0 5.515625-4.484375 10-10 10s-10-4.484375-10-10zm0 0");
    			add_location(path3, file$5, 51, 8, 3570);
    			attr_dev(path4, "d", "m156 249.988281c-16.542969 0-30 13.457031-30 30v80c0 16.542969 13.457031 30 30 30s30-13.457031 30-30v-80c0-16.574219-13.425781-30-30-30zm10 110c0 5.515625-4.484375 10-10 10s-10-4.484375-10-10v-80c0-5.515625 4.484375-10 10-10 5.519531 0 10 4.476563 10 10zm0 0");
    			add_location(path4, file$5, 52, 8, 3861);
    			attr_dev(svg, "class", "basket svelte-1m1jzog");
    			attr_dev(svg, "style", svg_style_value = "fill:" + /*color*/ ctx[0] + ";");
    			attr_dev(svg, "viewBox", "0 -36 512.001 512");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$5, 47, 8, 970);
    			attr_dev(div, "class", "basket-number svelte-1m1jzog");
    			add_location(div, file$5, 46, 4, 933);
    			attr_dev(a, "class", "basket-container svelte-1m1jzog");
    			attr_dev(a, "href", "/cart");
    			add_location(a, file$5, 45, 0, 877);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, div);
    			append_dev(div, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			append_dev(svg, path3);
    			append_dev(svg, path4);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*color*/ 1 && svg_style_value !== (svg_style_value = "fill:" + /*color*/ ctx[0] + ";")) {
    				attr_dev(svg, "style", svg_style_value);
    			}

    			if (dirty & /*$cart*/ 2) show_if = /*$cart*/ ctx[1] && /*$cart*/ ctx[1].items && Object.keys(/*$cart*/ ctx[1].items).length > 0;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $cart;
    	validate_store(cart, "cart");
    	component_subscribe($$self, cart, $$value => $$invalidate(1, $cart = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Cart", slots, []);
    	let { color = "#ffffff" } = $$props;
    	const writable_props = ["color"];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Cart> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("color" in $$props) $$invalidate(0, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({ cart, link, color, $cart });

    	$$self.$inject_state = $$props => {
    		if ("color" in $$props) $$invalidate(0, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [color, $cart];
    }

    class Cart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { color: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cart",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get color() {
    		throw new Error("<Cart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<Cart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\NavbarCC.svelte generated by Svelte v3.32.3 */
    const file$6 = "src\\components\\NavbarCC.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	return child_ctx;
    }

    // (667:8) {#if signedin}
    function create_if_block_4$1(ctx) {
    	let div11;
    	let div1;
    	let t0_value = ({ en: "My Account", fr: "Mon Compte" })[/*$lang*/ ctx[8]] + "";
    	let t0;
    	let t1;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t2;
    	let div10;
    	let div5;
    	let img1;
    	let img1_src_value;
    	let t3;
    	let div4;
    	let div2;

    	let t4_value = (/*$user*/ ctx[1] && /*$user*/ ctx[1].displayName
    	? /*$user*/ ctx[1].displayName
    	: "User") + "";

    	let t4;
    	let t5;
    	let div3;
    	let a0;

    	let t6_value = ({
    		en: "Edit Profile",
    		fr: "Modifier votre profil"
    	})[/*$lang*/ ctx[8]] + "";

    	let t6;
    	let t7;
    	let hr;
    	let t8;
    	let div9;
    	let div6;
    	let img2;
    	let img2_src_value;
    	let t9;
    	let a1;

    	let t10_value = ({
    		en: "Your Wishlist",
    		fr: "Votre Liste d'envie"
    	})[/*$lang*/ ctx[8]] + "";

    	let t10;
    	let t11;
    	let div7;
    	let img3;
    	let img3_src_value;
    	let t12;
    	let a2;
    	let t13_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[8]] + "";
    	let t13;
    	let t14;
    	let div8;
    	let t16;
    	let div15;
    	let div12;
    	let a3;

    	let t17_value = ({
    		en: "Your Wishlist",
    		fr: "Votre Liste d'envie"
    	})[/*$lang*/ ctx[8]] + "";

    	let t17;
    	let t18;
    	let div13;
    	let a4;
    	let t19_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[8]] + "";
    	let t19;
    	let t20;
    	let div14;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div1 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			img0 = element("img");
    			t2 = space();
    			div10 = element("div");
    			div5 = element("div");
    			img1 = element("img");
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div3 = element("div");
    			a0 = element("a");
    			t6 = text(t6_value);
    			t7 = space();
    			hr = element("hr");
    			t8 = space();
    			div9 = element("div");
    			div6 = element("div");
    			img2 = element("img");
    			t9 = space();
    			a1 = element("a");
    			t10 = text(t10_value);
    			t11 = space();
    			div7 = element("div");
    			img3 = element("img");
    			t12 = space();
    			a2 = element("a");
    			t13 = text(t13_value);
    			t14 = space();
    			div8 = element("div");
    			div8.textContent = "Logout";
    			t16 = space();
    			div15 = element("div");
    			div12 = element("div");
    			a3 = element("a");
    			t17 = text(t17_value);
    			t18 = space();
    			div13 = element("div");
    			a4 = element("a");
    			t19 = text(t19_value);
    			t20 = space();
    			div14 = element("div");
    			div14.textContent = "Logout";
    			if (img0.src !== (img0_src_value = "/img/misc/user-white.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "avatar");
    			attr_dev(img0, "class", "svelte-2s32aq");
    			add_location(img0, file$6, 675, 24, 16576);
    			attr_dev(div0, "class", "user_avatar svelte-2s32aq");
    			add_location(div0, file$6, 674, 20, 16525);
    			attr_dev(div1, "class", "menu_item svelte-2s32aq");
    			toggle_class(div1, "myAccount", /*myAccount*/ ctx[2]);
    			add_location(div1, file$6, 672, 16, 16395);
    			if (img1.src !== (img1_src_value = "/img/misc/user.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "avatar");
    			attr_dev(img1, "class", "svelte-2s32aq");
    			add_location(img1, file$6, 681, 24, 16859);
    			attr_dev(div2, "class", "u_name svelte-2s32aq");
    			add_location(div2, file$6, 683, 24, 16979);
    			attr_dev(a0, "class", "btn svelte-2s32aq");
    			attr_dev(a0, "href", "/myaccount/profile");
    			add_location(a0, file$6, 685, 28, 17145);
    			attr_dev(div3, "class", "edit_btn svelte-2s32aq");
    			add_location(div3, file$6, 684, 28, 17093);
    			attr_dev(div4, "class", "user_info svelte-2s32aq");
    			add_location(div4, file$6, 682, 24, 16930);
    			attr_dev(div5, "class", "first_part svelte-2s32aq");
    			add_location(div5, file$6, 680, 20, 16809);
    			attr_dev(hr, "class", "svelte-2s32aq");
    			add_location(hr, file$6, 691, 20, 17445);
    			if (img2.src !== (img2_src_value = "/img/misc/wishlist.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "");
    			attr_dev(img2, "class", "svelte-2s32aq");
    			add_location(img2, file$6, 695, 28, 17575);
    			attr_dev(a1, "href", "/myaccount/wishlist");
    			attr_dev(a1, "class", "svelte-2s32aq");
    			add_location(a1, file$6, 696, 28, 17646);
    			attr_dev(div6, "class", "help svelte-2s32aq");
    			add_location(div6, file$6, 694, 24, 17526);
    			if (img3.src !== (img3_src_value = "/img/misc/order.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "");
    			attr_dev(img3, "class", "svelte-2s32aq");
    			add_location(img3, file$6, 700, 28, 17857);
    			attr_dev(a2, "href", "/myaccount/orders");
    			attr_dev(a2, "class", "svelte-2s32aq");
    			add_location(a2, file$6, 701, 28, 17925);
    			attr_dev(div7, "class", "help svelte-2s32aq");
    			add_location(div7, file$6, 699, 24, 17808);
    			attr_dev(div8, "class", "logout svelte-2s32aq");
    			add_location(div8, file$6, 704, 24, 18076);
    			attr_dev(div9, "class", "second_part svelte-2s32aq");
    			add_location(div9, file$6, 692, 20, 17473);
    			attr_dev(div10, "class", "popup_myaccount svelte-2s32aq");
    			set_style(div10, "background-color", /*mobileMenuColor*/ ctx[9]);
    			toggle_class(div10, "myAccount", /*myAccount*/ ctx[2]);
    			add_location(div10, file$6, 679, 16, 16699);
    			attr_dev(div11, "class", "my_account svelte-2s32aq");
    			attr_dev(div11, "id", "myAccount");
    			add_location(div11, file$6, 667, 12, 16227);
    			attr_dev(a3, "href", "/myaccount/wishlist");
    			attr_dev(a3, "class", "svelte-2s32aq");
    			add_location(a3, file$6, 710, 20, 18324);
    			attr_dev(div12, "class", "help svelte-2s32aq");
    			add_location(div12, file$6, 709, 16, 18283);
    			attr_dev(a4, "href", "/myaccount/orders");
    			attr_dev(a4, "class", "svelte-2s32aq");
    			add_location(a4, file$6, 713, 20, 18499);
    			attr_dev(div13, "class", "help svelte-2s32aq");
    			add_location(div13, file$6, 712, 16, 18458);
    			attr_dev(div14, "class", "logout svelte-2s32aq");
    			add_location(div14, file$6, 715, 16, 18623);
    			attr_dev(div15, "class", "help_logout svelte-2s32aq");
    			add_location(div15, file$6, 708, 12, 18240);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div1);
    			append_dev(div1, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, img0);
    			append_dev(div11, t2);
    			append_dev(div11, div10);
    			append_dev(div10, div5);
    			append_dev(div5, img1);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, t4);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, a0);
    			append_dev(a0, t6);
    			append_dev(div10, t7);
    			append_dev(div10, hr);
    			append_dev(div10, t8);
    			append_dev(div10, div9);
    			append_dev(div9, div6);
    			append_dev(div6, img2);
    			append_dev(div6, t9);
    			append_dev(div6, a1);
    			append_dev(a1, t10);
    			append_dev(div9, t11);
    			append_dev(div9, div7);
    			append_dev(div7, img3);
    			append_dev(div7, t12);
    			append_dev(div7, a2);
    			append_dev(a2, t13);
    			append_dev(div9, t14);
    			append_dev(div9, div8);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div12);
    			append_dev(div12, a3);
    			append_dev(a3, t17);
    			append_dev(div15, t18);
    			append_dev(div15, div13);
    			append_dev(div13, a4);
    			append_dev(a4, t19);
    			append_dev(div15, t20);
    			append_dev(div15, div14);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					action_destroyer(link.call(null, a2)),
    					listen_dev(div8, "click", /*click_handler*/ ctx[10], false, false, false),
    					listen_dev(div11, "click", /*click_handler_1*/ ctx[11], false, false, false),
    					listen_dev(div14, "click", /*click_handler_2*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 256 && t0_value !== (t0_value = ({ en: "My Account", fr: "Mon Compte" })[/*$lang*/ ctx[8]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*myAccount*/ 4) {
    				toggle_class(div1, "myAccount", /*myAccount*/ ctx[2]);
    			}

    			if (dirty & /*$user*/ 2 && t4_value !== (t4_value = (/*$user*/ ctx[1] && /*$user*/ ctx[1].displayName
    			? /*$user*/ ctx[1].displayName
    			: "User") + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*$lang*/ 256 && t6_value !== (t6_value = ({
    				en: "Edit Profile",
    				fr: "Modifier votre profil"
    			})[/*$lang*/ ctx[8]] + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*$lang*/ 256 && t10_value !== (t10_value = ({
    				en: "Your Wishlist",
    				fr: "Votre Liste d'envie"
    			})[/*$lang*/ ctx[8]] + "")) set_data_dev(t10, t10_value);

    			if (dirty & /*$lang*/ 256 && t13_value !== (t13_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[8]] + "")) set_data_dev(t13, t13_value);

    			if (dirty & /*myAccount*/ 4) {
    				toggle_class(div10, "myAccount", /*myAccount*/ ctx[2]);
    			}

    			if (dirty & /*$lang*/ 256 && t17_value !== (t17_value = ({
    				en: "Your Wishlist",
    				fr: "Votre Liste d'envie"
    			})[/*$lang*/ ctx[8]] + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*$lang*/ 256 && t19_value !== (t19_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[8]] + "")) set_data_dev(t19, t19_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(div15);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(667:8) {#if signedin}",
    		ctx
    	});

    	return block;
    }

    // (720:8) {#if !signedin}
    function create_if_block_3$1(ctx) {
    	let a0;
    	let t0_value = ({ en: "Sign in", fr: "Se connecter" })[/*$lang*/ ctx[8]] + "";
    	let t0;
    	let t1;
    	let a1;
    	let t2_value = ({ en: "Register", fr: "S'inscrire" })[/*$lang*/ ctx[8]] + "";
    	let t2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			a1 = element("a");
    			t2 = text(t2_value);
    			attr_dev(a0, "href", "/signin");
    			attr_dev(a0, "class", "svelte-2s32aq");
    			add_location(a0, file$6, 720, 12, 18789);
    			attr_dev(a1, "href", "/signup");
    			attr_dev(a1, "class", "svelte-2s32aq");
    			add_location(a1, file$6, 724, 12, 19017);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			append_dev(a0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, t2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a0, "click", stop_propagation(prevent_default(/*click_handler_3*/ ctx[13])), false, true, true),
    					listen_dev(a1, "click", stop_propagation(prevent_default(/*click_handler_4*/ ctx[14])), false, true, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 256 && t0_value !== (t0_value = ({ en: "Sign in", fr: "Se connecter" })[/*$lang*/ ctx[8]] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$lang*/ 256 && t2_value !== (t2_value = ({ en: "Register", fr: "S'inscrire" })[/*$lang*/ ctx[8]] + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(720:8) {#if !signedin}",
    		ctx
    	});

    	return block;
    }

    // (739:36) 
    function create_if_block_2$1(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "/img/misc/uk-circle.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "en");
    			attr_dev(img, "class", "svelte-2s32aq");
    			add_location(img, file$6, 739, 16, 19604);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*click_handler_6*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(739:36) ",
    		ctx
    	});

    	return block;
    }

    // (732:12) {#if $lang == 'fr'}
    function create_if_block_1$3(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "/img/misc/france-circle.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "fr");
    			attr_dev(img, "class", "svelte-2s32aq");
    			add_location(img, file$6, 732, 16, 19354);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*click_handler_5*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(732:12) {#if $lang == 'fr'}",
    		ctx
    	});

    	return block;
    }

    // (809:16) {#if creatorData[media.type] && creatorData[media.type].length > 0}
    function create_if_block$4(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			t = space();
    			set_style(img, "width", /*media*/ ctx[20].type == "baaz" ? "50px" : " 30px");
    			if (img.src !== (img_src_value = "/img/socialMedia/" + /*media*/ ctx[20].type + ".svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-2s32aq");
    			add_location(img, file$6, 810, 24, 22463);
    			attr_dev(a, "target", "_blank");

    			attr_dev(a, "href", a_href_value = /*creatorData*/ ctx[0][/*media*/ ctx[20].type].includes("http")
    			? /*creatorData*/ ctx[0][/*media*/ ctx[20].type]
    			: "https://" + /*creatorData*/ ctx[0][/*media*/ ctx[20].type]);

    			attr_dev(a, "class", "svelte-2s32aq");
    			add_location(a, file$6, 809, 20, 22305);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*creatorData*/ 1 && a_href_value !== (a_href_value = /*creatorData*/ ctx[0][/*media*/ ctx[20].type].includes("http")
    			? /*creatorData*/ ctx[0][/*media*/ ctx[20].type]
    			: "https://" + /*creatorData*/ ctx[0][/*media*/ ctx[20].type])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(809:16) {#if creatorData[media.type] && creatorData[media.type].length > 0}",
    		ctx
    	});

    	return block;
    }

    // (808:12) {#each socialMedias as media}
    function create_each_block$2(ctx) {
    	let if_block_anchor;
    	let if_block = /*creatorData*/ ctx[0][/*media*/ ctx[20].type] && /*creatorData*/ ctx[0][/*media*/ ctx[20].type].length > 0 && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*creatorData*/ ctx[0][/*media*/ ctx[20].type] && /*creatorData*/ ctx[0][/*media*/ ctx[20].type].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(808:12) {#each socialMedias as media}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let nav;
    	let div0;
    	let a0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let div1;
    	let t2;
    	let div4;
    	let a1;
    	let t3_value = ({ en: "Home", fr: "Accueil" })[/*$lang*/ ctx[8]] + "";
    	let t3;
    	let t4;
    	let a2;
    	let t5_value = ({ en: "Merch", fr: "Merch" })[/*$lang*/ ctx[8]] + "";
    	let t5;
    	let a2_href_value;
    	let t6;
    	let t7;
    	let t8;
    	let div2;
    	let t9;
    	let cart;
    	let t10;
    	let div3;
    	let div4_class_value;
    	let t12;
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let nav_class_value;
    	let t13;
    	let div9;
    	let div5;
    	let div5_style_value;
    	let t14;
    	let div6;
    	let t15;
    	let div8;
    	let img1;
    	let img1_src_value;
    	let t16;
    	let span;

    	let t17_value = (/*creatorData*/ ctx[0].name
    	? /*creatorData*/ ctx[0].name
    	: /*creatorData*/ ctx[0].username + "' store") + "";

    	let t17;
    	let t18;
    	let div7;
    	let div9_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*signedin*/ ctx[7] && create_if_block_4$1(ctx);
    	let if_block1 = !/*signedin*/ ctx[7] && create_if_block_3$1(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*$lang*/ ctx[8] == "fr") return create_if_block_1$3;
    		if (/*$lang*/ ctx[8] == "en") return create_if_block_2$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type && current_block_type(ctx);
    	cart = new Cart({ $$inline: true });
    	let each_value = socialMedias;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			div0 = element("div");
    			a0 = element("a");
    			img0 = element("img");
    			t0 = space();
    			div1 = element("div");
    			div1.textContent = "+";
    			t2 = space();
    			div4 = element("div");
    			a1 = element("a");
    			t3 = text(t3_value);
    			t4 = space();
    			a2 = element("a");
    			t5 = text(t5_value);
    			t6 = space();
    			if (if_block0) if_block0.c();
    			t7 = space();
    			if (if_block1) if_block1.c();
    			t8 = space();
    			div2 = element("div");
    			if (if_block2) if_block2.c();
    			t9 = space();
    			create_component(cart.$$.fragment);
    			t10 = space();
    			div3 = element("div");
    			div3.textContent = "X";
    			t12 = space();
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			t13 = space();
    			div9 = element("div");
    			div5 = element("div");
    			t14 = space();
    			div6 = element("div");
    			t15 = space();
    			div8 = element("div");
    			img1 = element("img");
    			t16 = space();
    			span = element("span");
    			t17 = text(t17_value);
    			t18 = space();
    			div7 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (img0.src !== (img0_src_value = "/img/logo.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "logo");
    			attr_dev(img0, "class", "svelte-2s32aq");
    			add_location(img0, file$6, 653, 12, 15622);
    			attr_dev(a0, "href", "/");
    			attr_dev(a0, "class", "unify-logo svelte-2s32aq");
    			add_location(a0, file$6, 652, 8, 15568);
    			attr_dev(div0, "class", "u-logo-container svelte-2s32aq");
    			add_location(div0, file$6, 651, 4, 15528);
    			attr_dev(div1, "class", "unify-plus svelte-2s32aq");
    			add_location(div1, file$6, 657, 4, 15698);
    			attr_dev(a1, "href", "/");
    			attr_dev(a1, "class", "svelte-2s32aq");
    			add_location(a1, file$6, 662, 8, 15892);
    			attr_dev(a2, "href", a2_href_value = "/" + /*creatorData*/ ctx[0].username + "/merch");
    			attr_dev(a2, "class", "svelte-2s32aq");
    			add_location(a2, file$6, 664, 8, 16020);
    			attr_dev(div2, "class", "nav-lang svelte-2s32aq");
    			add_location(div2, file$6, 730, 8, 19281);
    			attr_dev(div3, "class", "closeMobileMenu svelte-2s32aq");
    			toggle_class(div3, "isActive", /*isActive*/ ctx[4]);
    			add_location(div3, file$6, 757, 8, 20160);

    			attr_dev(div4, "class", div4_class_value = "menu-items " + (window.innerWidth <= 1180
    			? /*isActive*/ ctx[4]
    				? "isActive"
    				: /*isActiveReverse*/ ctx[5] ? "isActiveReverse" : ""
    			: "") + " svelte-2s32aq");

    			add_location(div4, file$6, 659, 4, 15737);
    			attr_dev(path0, "d", "m368 154.667969h-352c-8.832031 0-16-7.167969-16-16s7.167969-16\r\n      16-16h352c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0");
    			add_location(path0, file$6, 779, 8, 20843);
    			attr_dev(path1, "d", "m368 32h-352c-8.832031 0-16-7.167969-16-16s7.167969-16\r\n      16-16h352c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0");
    			add_location(path1, file$6, 782, 8, 21011);
    			attr_dev(path2, "d", "m368 277.332031h-352c-8.832031 0-16-7.167969-16-16s7.167969-16\r\n      16-16h352c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0");
    			add_location(path2, file$6, 785, 8, 21171);
    			attr_dev(svg, "class", "menuBtn svelte-2s32aq");
    			attr_dev(svg, "height", "384pt");
    			attr_dev(svg, "viewBox", "0 -53 384 384");
    			attr_dev(svg, "width", "384pt");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			toggle_class(svg, "isActive", /*isActive*/ ctx[4]);
    			add_location(svg, file$6, 768, 4, 20489);
    			attr_dev(nav, "class", nav_class_value = "" + (null_to_empty(/*isScroll*/ ctx[6] ? "isScroll" : "isScrollReverse") + " svelte-2s32aq"));
    			add_location(nav, file$6, 650, 0, 15467);
    			attr_dev(div5, "class", "u-layer svelte-2s32aq");
    			attr_dev(div5, "style", div5_style_value = "background-image: url(" + /*creatorData*/ ctx[0].banner + ");");
    			add_location(div5, file$6, 792, 4, 21502);
    			attr_dev(div6, "class", "u-pattern svelte-2s32aq");
    			add_location(div6, file$6, 794, 4, 21653);
    			attr_dev(img1, "class", "logo_img svelte-2s32aq");
    			attr_dev(img1, "crossorigin", "anonymous");

    			if (img1.src !== (img1_src_value = /*creatorData*/ ctx[0].logo
    			? /*creatorData*/ ctx[0].logo
    			: "/img/Logo.svg")) attr_dev(img1, "src", img1_src_value);

    			attr_dev(img1, "alt", "u-logo");
    			add_location(img1, file$6, 797, 8, 21716);
    			attr_dev(span, "class", "svelte-2s32aq");
    			add_location(span, file$6, 798, 8, 21847);
    			attr_dev(div7, "class", "userSocial svelte-2s32aq");
    			add_location(div7, file$6, 800, 8, 21946);
    			attr_dev(div8, "class", "u-logo svelte-2s32aq");
    			add_location(div8, file$6, 796, 4, 21686);
    			attr_dev(div9, "class", div9_class_value = "header " + (/*isScroll*/ ctx[6] ? "isScroll" : "isScrollReverse") + " svelte-2s32aq");
    			add_location(div9, file$6, 790, 0, 21351);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img0);
    			append_dev(nav, t0);
    			append_dev(nav, div1);
    			append_dev(nav, t2);
    			append_dev(nav, div4);
    			append_dev(div4, a1);
    			append_dev(a1, t3);
    			append_dev(div4, t4);
    			append_dev(div4, a2);
    			append_dev(a2, t5);
    			append_dev(div4, t6);
    			if (if_block0) if_block0.m(div4, null);
    			append_dev(div4, t7);
    			if (if_block1) if_block1.m(div4, null);
    			append_dev(div4, t8);
    			append_dev(div4, div2);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div4, t9);
    			mount_component(cart, div4, null);
    			append_dev(div4, t10);
    			append_dev(div4, div3);
    			append_dev(nav, t12);
    			append_dev(nav, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			insert_dev(target, t13, anchor);
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div5);
    			append_dev(div9, t14);
    			append_dev(div9, div6);
    			append_dev(div9, t15);
    			append_dev(div9, div8);
    			append_dev(div8, img1);
    			append_dev(div8, t16);
    			append_dev(div8, span);
    			append_dev(span, t17);
    			append_dev(div8, t18);
    			append_dev(div8, div7);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div7, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					action_destroyer(link.call(null, a2)),
    					listen_dev(div3, "click", /*click_handler_7*/ ctx[17], false, false, false),
    					listen_dev(svg, "click", /*click_handler_8*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$lang*/ 256) && t3_value !== (t3_value = ({ en: "Home", fr: "Accueil" })[/*$lang*/ ctx[8]] + "")) set_data_dev(t3, t3_value);
    			if ((!current || dirty & /*$lang*/ 256) && t5_value !== (t5_value = ({ en: "Merch", fr: "Merch" })[/*$lang*/ ctx[8]] + "")) set_data_dev(t5, t5_value);

    			if (!current || dirty & /*creatorData*/ 1 && a2_href_value !== (a2_href_value = "/" + /*creatorData*/ ctx[0].username + "/merch")) {
    				attr_dev(a2, "href", a2_href_value);
    			}

    			if (/*signedin*/ ctx[7]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$1(ctx);
    					if_block0.c();
    					if_block0.m(div4, t7);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*signedin*/ ctx[7]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$1(ctx);
    					if_block1.c();
    					if_block1.m(div4, t8);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if (if_block2) if_block2.d(1);
    				if_block2 = current_block_type && current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div2, null);
    				}
    			}

    			if (dirty & /*isActive*/ 16) {
    				toggle_class(div3, "isActive", /*isActive*/ ctx[4]);
    			}

    			if (!current || dirty & /*isActive, isActiveReverse*/ 48 && div4_class_value !== (div4_class_value = "menu-items " + (window.innerWidth <= 1180
    			? /*isActive*/ ctx[4]
    				? "isActive"
    				: /*isActiveReverse*/ ctx[5] ? "isActiveReverse" : ""
    			: "") + " svelte-2s32aq")) {
    				attr_dev(div4, "class", div4_class_value);
    			}

    			if (dirty & /*isActive*/ 16) {
    				toggle_class(svg, "isActive", /*isActive*/ ctx[4]);
    			}

    			if (!current || dirty & /*isScroll*/ 64 && nav_class_value !== (nav_class_value = "" + (null_to_empty(/*isScroll*/ ctx[6] ? "isScroll" : "isScrollReverse") + " svelte-2s32aq"))) {
    				attr_dev(nav, "class", nav_class_value);
    			}

    			if (!current || dirty & /*creatorData*/ 1 && div5_style_value !== (div5_style_value = "background-image: url(" + /*creatorData*/ ctx[0].banner + ");")) {
    				attr_dev(div5, "style", div5_style_value);
    			}

    			if (!current || dirty & /*creatorData*/ 1 && img1.src !== (img1_src_value = /*creatorData*/ ctx[0].logo
    			? /*creatorData*/ ctx[0].logo
    			: "/img/Logo.svg")) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if ((!current || dirty & /*creatorData*/ 1) && t17_value !== (t17_value = (/*creatorData*/ ctx[0].name
    			? /*creatorData*/ ctx[0].name
    			: /*creatorData*/ ctx[0].username + "' store") + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*creatorData, socialMedias*/ 1) {
    				each_value = socialMedias;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div7, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*isScroll*/ 64 && div9_class_value !== (div9_class_value = "header " + (/*isScroll*/ ctx[6] ? "isScroll" : "isScrollReverse") + " svelte-2s32aq")) {
    				attr_dev(div9, "class", div9_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			if (if_block2) {
    				if_block2.d();
    			}

    			destroy_component(cart);
    			if (detaching) detach_dev(t13);
    			if (detaching) detach_dev(div9);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let signedin;
    	let $user;
    	let $lang;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(1, $user = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(8, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavbarCC", slots, []);
    	let { creatorData = {} } = $$props;
    	let myAccount = false;
    	let accentColor = "#45b877";

    	if (creatorData.accentColor) {
    		accentColor = hexToRgb(creatorData.accentColor);
    	}

    	onMount(async () => {
    		document.querySelector(".u-pattern").style.background = "rgba(" + accentColor + ",0.8)";
    	});

    	window.addEventListener("resize", () => {
    		let mobileItem = document.querySelector(".menu-items.isActive");

    		if (!mobileItem) {
    			return;
    		}

    		if (window.innerWidth > 1180) {
    			mobileItem.style.background = "transparent";
    		} else {
    			mobileItem.style.background = "rgb(" + accentColor + ")";
    		}
    	});

    	let mobileMenuColor = "#FFFFFF";
    	let isActive = false; // for mobile menu
    	let isActiveReverse = false;

    	window.addEventListener("resize", () => {
    		if (window.innerWidth > 1180) {
    			$$invalidate(5, isActiveReverse = false);
    		}
    	});

    	/**************OnScroll***********/
    	let isScroll = false;

    	let oldscroll = 0;

    	window.onscroll = () => {
    		let currentScroll = window.scrollY;

    		if (Math.abs(currentScroll) > 165) {
    			if (currentScroll > oldscroll) {
    				if (isScroll != true) {
    					$$invalidate(6, isScroll = true);
    				}
    			}

    			oldscroll = currentScroll;
    		} else if (Math.abs(currentScroll) < 100) {
    			if (isScroll != false) {
    				$$invalidate(6, isScroll = false);
    			}

    			oldscroll = currentScroll;
    		}
    	};

    	const writable_props = ["creatorData"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavbarCC> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		firebase.auth().signOut();
    	};

    	const click_handler_1 = () => $$invalidate(2, myAccount = !myAccount);

    	const click_handler_2 = () => {
    		firebase.auth().signOut();
    	};

    	const click_handler_3 = () => {
    		navigate("/signin?backurl=" + window.location.pathname);
    	};

    	const click_handler_4 = () => {
    		navigate("/signup?backurl=" + window.location.pathname);
    	};

    	const click_handler_5 = () => {
    		set_store_value(lang, $lang = "en", $lang);
    	};

    	const click_handler_6 = () => {
    		set_store_value(lang, $lang = "fr", $lang);
    	};

    	const click_handler_7 = () => {
    		$$invalidate(4, isActive = false);
    		$$invalidate(5, isActiveReverse = true);
    		document.querySelector(".menu-items").style.background = "transparent";
    	};

    	const click_handler_8 = () => {
    		$$invalidate(4, isActive = !isActive);
    		document.querySelector(".menu-items").style.background = "rgb(" + accentColor + ")";
    	};

    	$$self.$$set = $$props => {
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    	};

    	$$self.$capture_state = () => ({
    		lang,
    		socialMedias,
    		getBackurl,
    		link,
    		navigate,
    		Cart,
    		user,
    		onMount,
    		hexToRgb,
    		creatorData,
    		myAccount,
    		accentColor,
    		mobileMenuColor,
    		isActive,
    		isActiveReverse,
    		isScroll,
    		oldscroll,
    		signedin,
    		$user,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    		if ("myAccount" in $$props) $$invalidate(2, myAccount = $$props.myAccount);
    		if ("accentColor" in $$props) $$invalidate(3, accentColor = $$props.accentColor);
    		if ("mobileMenuColor" in $$props) $$invalidate(9, mobileMenuColor = $$props.mobileMenuColor);
    		if ("isActive" in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ("isActiveReverse" in $$props) $$invalidate(5, isActiveReverse = $$props.isActiveReverse);
    		if ("isScroll" in $$props) $$invalidate(6, isScroll = $$props.isScroll);
    		if ("oldscroll" in $$props) oldscroll = $$props.oldscroll;
    		if ("signedin" in $$props) $$invalidate(7, signedin = $$props.signedin);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$user*/ 2) {
    			$$invalidate(7, signedin = $user);
    		}
    	};

    	return [
    		creatorData,
    		$user,
    		myAccount,
    		accentColor,
    		isActive,
    		isActiveReverse,
    		isScroll,
    		signedin,
    		$lang,
    		mobileMenuColor,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8
    	];
    }

    class NavbarCC extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { creatorData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarCC",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get creatorData() {
    		throw new Error("<NavbarCC>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set creatorData(value) {
    		throw new Error("<NavbarCC>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\FreeDeliveryBar.svelte generated by Svelte v3.32.3 */
    const file$7 = "src\\components\\FreeDeliveryBar.svelte";

    function create_fragment$b(ctx) {
    	let div;

    	let t_value = ({
    		en: "Free Delivery for All Products.",
    		fr: "Livraison Gratuite sur tous les produits."
    	})[/*$lang*/ ctx[1]] + "";

    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "container svelte-1evca1g");
    			set_style(div, "background-color", /*creatorData*/ ctx[0].accentColor);
    			add_location(div, file$7, 40, 0, 681);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$lang*/ 2 && t_value !== (t_value = ({
    				en: "Free Delivery for All Products.",
    				fr: "Livraison Gratuite sur tous les produits."
    			})[/*$lang*/ ctx[1]] + "")) set_data_dev(t, t_value);

    			if (dirty & /*creatorData*/ 1) {
    				set_style(div, "background-color", /*creatorData*/ ctx[0].accentColor);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(1, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FreeDeliveryBar", slots, []);
    	let { creatorData = {} } = $$props;

    	if (creatorData.accentColor == undefined || creatorData.accentColor == null || creatorData.accentColor == "") {
    		creatorData.accentColor = "#45b877";
    	}

    	const writable_props = ["creatorData"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FreeDeliveryBar> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		hexToRgb,
    		convert,
    		lang,
    		creatorData,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [creatorData, $lang];
    }

    class FreeDeliveryBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { creatorData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FreeDeliveryBar",
    			options,
    			id: create_fragment$b.name
    		});
    	}

    	get creatorData() {
    		throw new Error("<FreeDeliveryBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set creatorData(value) {
    		throw new Error("<FreeDeliveryBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\routes\Creator\MerchPage.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$4, console: console_1$3 } = globals;
    const file$8 = "src\\routes\\Creator\\MerchPage.svelte";

    // (58:0) {:else}
    function create_else_block$3(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "100px", height: "100px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-view svelte-f8qh6r");
    			add_location(div, file$8, 58, 4, 1613);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(58:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:0) {#if validated}
    function create_if_block$5(ctx) {
    	let navbar;
    	let updating_creatorData;
    	let t0;
    	let freedeliverybar;
    	let t1;
    	let merch;
    	let current;

    	function navbar_creatorData_binding(value) {
    		/*navbar_creatorData_binding*/ ctx[3](value);
    	}

    	let navbar_props = {};

    	if (/*data*/ ctx[2] !== void 0) {
    		navbar_props.creatorData = /*data*/ ctx[2];
    	}

    	navbar = new NavbarCC({ props: navbar_props, $$inline: true });
    	binding_callbacks.push(() => bind(navbar, "creatorData", navbar_creatorData_binding));

    	freedeliverybar = new FreeDeliveryBar({
    			props: { creatorData: /*data*/ ctx[2] },
    			$$inline: true
    		});

    	merch = new Merch({
    			props: {
    				creatorData: /*data*/ ctx[2],
    				params: /*params*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t0 = space();
    			create_component(freedeliverybar.$$.fragment);
    			t1 = space();
    			create_component(merch.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(freedeliverybar, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(merch, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbar_changes = {};

    			if (!updating_creatorData && dirty & /*data*/ 4) {
    				updating_creatorData = true;
    				navbar_changes.creatorData = /*data*/ ctx[2];
    				add_flush_callback(() => updating_creatorData = false);
    			}

    			navbar.$set(navbar_changes);
    			const freedeliverybar_changes = {};
    			if (dirty & /*data*/ 4) freedeliverybar_changes.creatorData = /*data*/ ctx[2];
    			freedeliverybar.$set(freedeliverybar_changes);
    			const merch_changes = {};
    			if (dirty & /*data*/ 4) merch_changes.creatorData = /*data*/ ctx[2];
    			if (dirty & /*params*/ 1) merch_changes.params = /*params*/ ctx[0];
    			merch.$set(merch_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(freedeliverybar.$$.fragment, local);
    			transition_in(merch.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(freedeliverybar.$$.fragment, local);
    			transition_out(merch.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(freedeliverybar, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(merch, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(53:0) {#if validated}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$5, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*validated*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MerchPage", slots, []);
    	let { params = {} } = $$props;
    	let validated = false;
    	let data = {};

    	onMount(async () => {
    		console.log("merch page mounted");
    		$$invalidate(2, data = await dbWrapper.get("/creators/" + params.userid));

    		if (Object.keys(data).length == 0) {
    			navigate("/");
    			return;
    		}

    		for (let x of ["logo", "banner"]) {
    			if (data[x]) {
    				$$invalidate(2, data[x] = uuidToImageLink(data[x], "creators/" + params.userid + "/" + x), data);
    			}
    		}

    		if (data.accentColor == undefined) {
    			$$invalidate(2, data.accentColor = "#46b978", data);
    		}

    		$$invalidate(2, data);
    		console.log("creator data xd");
    		console.log(data);
    		$$invalidate(1, validated = true);
    	});

    	const writable_props = ["params"];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<MerchPage> was created with unknown prop '${key}'`);
    	});

    	function navbar_creatorData_binding(value) {
    		data = value;
    		$$invalidate(2, data);
    	}

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		Merch,
    		params,
    		onMount,
    		dbWrapper,
    		navigate,
    		MaterialSpinner,
    		uuidToImageLink,
    		Navbar: NavbarCC,
    		FreeDeliveryBar,
    		validated,
    		data
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("validated" in $$props) $$invalidate(1, validated = $$props.validated);
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params, validated, data, navbar_creatorData_binding];
    }

    class MerchPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MerchPage",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get params() {
    		throw new Error("<MerchPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<MerchPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\routes\Creator\SingleProductPage.svelte generated by Svelte v3.32.3 */
    const file$9 = "src\\routes\\Creator\\SingleProductPage.svelte";

    // (54:0) {:else}
    function create_else_block$4(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "100px", height: "100" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-view svelte-1u9gu0l");
    			add_location(div, file$9, 54, 4, 1742);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(54:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (50:0) {#if validated}
    function create_if_block$6(ctx) {
    	let navbarcc;
    	let t0;
    	let freedeliverybar;
    	let t1;
    	let single;
    	let current;

    	navbarcc = new NavbarCC({
    			props: { creatorData: /*creatorData*/ ctx[2] },
    			$$inline: true
    		});

    	freedeliverybar = new FreeDeliveryBar({
    			props: { creatorData: /*creatorData*/ ctx[2] },
    			$$inline: true
    		});

    	single = new SingleProduct({
    			props: {
    				params: /*params*/ ctx[0],
    				creatorData: /*creatorData*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbarcc.$$.fragment);
    			t0 = space();
    			create_component(freedeliverybar.$$.fragment);
    			t1 = space();
    			create_component(single.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarcc, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(freedeliverybar, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(single, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbarcc_changes = {};
    			if (dirty & /*creatorData*/ 4) navbarcc_changes.creatorData = /*creatorData*/ ctx[2];
    			navbarcc.$set(navbarcc_changes);
    			const freedeliverybar_changes = {};
    			if (dirty & /*creatorData*/ 4) freedeliverybar_changes.creatorData = /*creatorData*/ ctx[2];
    			freedeliverybar.$set(freedeliverybar_changes);
    			const single_changes = {};
    			if (dirty & /*params*/ 1) single_changes.params = /*params*/ ctx[0];
    			if (dirty & /*creatorData*/ 4) single_changes.creatorData = /*creatorData*/ ctx[2];
    			single.$set(single_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarcc.$$.fragment, local);
    			transition_in(freedeliverybar.$$.fragment, local);
    			transition_in(single.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarcc.$$.fragment, local);
    			transition_out(freedeliverybar.$$.fragment, local);
    			transition_out(single.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarcc, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(freedeliverybar, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(single, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(50:0) {#if validated}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$6, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*validated*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SingleProductPage", slots, []);
    	let { params = {} } = $$props;
    	let validated = false;
    	let data = {};
    	let creatorData = {};

    	onMount(async () => {
    		$$invalidate(2, creatorData = await dbWrapper.get("/creators/" + params.userid));

    		if (creatorData.accentColor == undefined) {
    			$$invalidate(2, creatorData.accentColor = "#46b978", creatorData);
    		}

    		for (let x of ["logo", "banner"]) {
    			if (creatorData[x]) {
    				$$invalidate(2, creatorData[x] = uuidToImageLink(creatorData[x], "creators/" + params.userid + "/" + x), creatorData);
    			}
    		}

    		data = await dbWrapper.get("/creators/" + params.userid + "/merch/all");

    		if (data[params.itemid] == undefined) {
    			navigate("/" + params.userid);
    		} else {
    			$$invalidate(1, validated = true);

    			document.title = "Unify - " + (creatorData.name
    			? creatorData.name
    			: creatorData.username) + " - Store";
    		}
    	});

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SingleProductPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		params,
    		NavbarCC,
    		Single: SingleProduct,
    		onMount,
    		dbWrapper,
    		navigate,
    		MaterialSpinner,
    		FreeDeliveryBar,
    		uuidToImageLink,
    		validated,
    		data,
    		creatorData
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("validated" in $$props) $$invalidate(1, validated = $$props.validated);
    		if ("data" in $$props) data = $$props.data;
    		if ("creatorData" in $$props) $$invalidate(2, creatorData = $$props.creatorData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params, validated, creatorData];
    }

    class SingleProductPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SingleProductPage",
    			options,
    			id: create_fragment$d.name
    		});
    	}

    	get params() {
    		throw new Error("<SingleProductPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<SingleProductPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\misc\Redirector.svelte generated by Svelte v3.32.3 */

    function create_fragment$e(ctx) {
    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Redirector", slots, []);
    	let { path = "" } = $$props;

    	onMount(() => {
    		navigate(path);
    	});

    	const writable_props = ["path"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Redirector> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("path" in $$props) $$invalidate(0, path = $$props.path);
    	};

    	$$self.$capture_state = () => ({ navigate, onMount, path });

    	$$self.$inject_state = $$props => {
    		if ("path" in $$props) $$invalidate(0, path = $$props.path);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [path];
    }

    class Redirector extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { path: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Redirector",
    			options,
    			id: create_fragment$e.name
    		});
    	}

    	get path() {
    		throw new Error("<Redirector>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set path(value) {
    		throw new Error("<Redirector>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\DonationPage\Tabs.svelte generated by Svelte v3.32.3 */

    const file$a = "src\\components\\DonationPage\\Tabs.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (9:0) {#each items as item}
    function create_each_block_1$2(ctx) {
    	let li;
    	let span;
    	let t0_value = /*item*/ ctx[3].label + "";
    	let t0;
    	let t1;
    	let li_class_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			li = element("li");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(span, "class", "svelte-tdqp2m");
    			add_location(span, file$a, 10, 2, 247);

    			attr_dev(li, "class", li_class_value = "" + (null_to_empty(/*activeTabValue*/ ctx[0] === /*item*/ ctx[3].value
    			? "active"
    			: "") + " svelte-tdqp2m"));

    			add_location(li, file$a, 9, 1, 185);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span);
    			append_dev(span, t0);
    			append_dev(li, t1);

    			if (!mounted) {
    				dispose = listen_dev(
    					span,
    					"click",
    					function () {
    						if (is_function(/*handleClick*/ ctx[2](/*item*/ ctx[3].value))) /*handleClick*/ ctx[2](/*item*/ ctx[3].value).apply(this, arguments);
    					},
    					false,
    					false,
    					false
    				);

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*items*/ 2 && t0_value !== (t0_value = /*item*/ ctx[3].label + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*activeTabValue, items*/ 3 && li_class_value !== (li_class_value = "" + (null_to_empty(/*activeTabValue*/ ctx[0] === /*item*/ ctx[3].value
    			? "active"
    			: "") + " svelte-tdqp2m"))) {
    				attr_dev(li, "class", li_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(9:0) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    // (16:1) {#if activeTabValue == item.value}
    function create_if_block$7(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	var switch_value = /*item*/ ctx[3].component;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "box svelte-tdqp2m");
    			add_location(div, file$a, 16, 1, 394);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*item*/ ctx[3].component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(16:1) {#if activeTabValue == item.value}",
    		ctx
    	});

    	return block;
    }

    // (15:0) {#each items as item}
    function create_each_block$3(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*activeTabValue*/ ctx[0] == /*item*/ ctx[3].value && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*activeTabValue*/ ctx[0] == /*item*/ ctx[3].value) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*activeTabValue, items*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(15:0) {#each items as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let ul;
    	let t;
    	let each1_anchor;
    	let current;
    	let each_value_1 = /*items*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	let each_value = /*items*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each1_anchor = empty();
    			attr_dev(ul, "class", "svelte-tdqp2m");
    			add_location(ul, file$a, 7, 0, 155);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul, null);
    			}

    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeTabValue, items, handleClick*/ 7) {
    				each_value_1 = /*items*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*items, activeTabValue*/ 3) {
    				each_value = /*items*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tabs", slots, []);
    	let { items = [] } = $$props;
    	let { activeTabValue = 1 } = $$props;
    	const handleClick = tabValue => () => $$invalidate(0, activeTabValue = tabValue);
    	const writable_props = ["items", "activeTabValue"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tabs> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("activeTabValue" in $$props) $$invalidate(0, activeTabValue = $$props.activeTabValue);
    	};

    	$$self.$capture_state = () => ({ items, activeTabValue, handleClick });

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(1, items = $$props.items);
    		if ("activeTabValue" in $$props) $$invalidate(0, activeTabValue = $$props.activeTabValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [activeTabValue, items, handleClick];
    }

    class Tabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { items: 1, activeTabValue: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tabs",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get items() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeTabValue() {
    		throw new Error("<Tabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeTabValue(value) {
    		throw new Error("<Tabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\DonationPage\Week.svelte generated by Svelte v3.32.3 */

    const file$b = "src\\components\\DonationPage\\Week.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (41:0) {#each donators as donator}
    function create_each_block$4(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*donator*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*donator*/ ctx[1].amount + "";
    	let t2;
    	let t3;
    	let t4_value = /*donator*/ ctx[1].currency + "";
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(div0, "class", "donatorName svelte-1kqgllj");
    			add_location(div0, file$b, 42, 4, 764);
    			attr_dev(div1, "class", "donatorAmount svelte-1kqgllj");
    			add_location(div1, file$b, 43, 4, 815);
    			attr_dev(div2, "class", "donation svelte-1kqgllj");
    			add_location(div2, file$b, 41, 0, 736);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(41:0) {#each donators as donator}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let each_1_anchor;
    	let each_value = /*donators*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*donators*/ 1) {
    				each_value = /*donators*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Week", slots, []);

    	let donators = [
    		{
    			name: "Hamadi",
    			amount: "100",
    			currency: "TND"
    		},
    		{
    			name: "Samer",
    			amount: "5",
    			currency: "USD"
    		},
    		{
    			name: "mouha",
    			amount: "18",
    			currency: "EUR"
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Week> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ donators });

    	$$self.$inject_state = $$props => {
    		if ("donators" in $$props) $$invalidate(0, donators = $$props.donators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [donators];
    }

    class Week extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Week",
    			options,
    			id: create_fragment$g.name
    		});
    	}
    }

    /* src\components\DonationPage\Month.svelte generated by Svelte v3.32.3 */

    const file$c = "src\\components\\DonationPage\\Month.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (59:0) {#each donators as donator}
    function create_each_block$5(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*donator*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*donator*/ ctx[1].amount + "";
    	let t2;
    	let t3;
    	let t4_value = /*donator*/ ctx[1].currency + "";
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(div0, "class", "donatorName svelte-1kqgllj");
    			add_location(div0, file$c, 60, 4, 1078);
    			attr_dev(div1, "class", "donatorAmount svelte-1kqgllj");
    			add_location(div1, file$c, 61, 4, 1129);
    			attr_dev(div2, "class", "donation svelte-1kqgllj");
    			add_location(div2, file$c, 59, 0, 1050);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(59:0) {#each donators as donator}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let each_1_anchor;
    	let each_value = /*donators*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*donators*/ 1) {
    				each_value = /*donators*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Month", slots, []);

    	let donators = [
    		{
    			name: "somsom",
    			amount: "30",
    			currency: "TND"
    		},
    		{
    			name: "mouha",
    			amount: "18",
    			currency: "EUR"
    		},
    		{
    			name: "somsom",
    			amount: "30",
    			currency: "TND"
    		},
    		{
    			name: "mouha",
    			amount: "18",
    			currency: "EUR"
    		},
    		{
    			name: "somsom",
    			amount: "30",
    			currency: "TND"
    		},
    		{
    			name: "mouha",
    			amount: "18",
    			currency: "EUR"
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Month> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ donators });

    	$$self.$inject_state = $$props => {
    		if ("donators" in $$props) $$invalidate(0, donators = $$props.donators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [donators];
    }

    class Month extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Month",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\components\DonationPage\Year.svelte generated by Svelte v3.32.3 */

    const file$d = "src\\components\\DonationPage\\Year.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (37:0) {#each donators as donator}
    function create_each_block$6(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*donator*/ ctx[1].name + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*donator*/ ctx[1].amount + "";
    	let t2;
    	let t3;
    	let t4_value = /*donator*/ ctx[1].currency + "";
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(div0, "class", "donatorName svelte-1kqgllj");
    			add_location(div0, file$d, 38, 4, 672);
    			attr_dev(div1, "class", "donatorAmount svelte-1kqgllj");
    			add_location(div1, file$d, 39, 4, 723);
    			attr_dev(div2, "class", "donation svelte-1kqgllj");
    			add_location(div2, file$d, 37, 0, 644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(37:0) {#each donators as donator}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let each_1_anchor;
    	let each_value = /*donators*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*donators*/ 1) {
    				each_value = /*donators*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Year", slots, []);

    	let donators = [
    		{
    			name: "somsom",
    			amount: "30",
    			currency: "TND"
    		},
    		{
    			name: "mouha",
    			amount: "18",
    			currency: "EUR"
    		}
    	];

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Year> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ donators });

    	$$self.$inject_state = $$props => {
    		if ("donators" in $$props) $$invalidate(0, donators = $$props.donators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [donators];
    }

    class Year extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Year",
    			options,
    			id: create_fragment$i.name
    		});
    	}
    }

    /* src\components\DonationPage\Donation.svelte generated by Svelte v3.32.3 */
    const file$e = "src\\components\\DonationPage\\Donation.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	return child_ctx;
    }

    // (415:20) {:else}
    function create_else_block$5(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "none";
    			add_location(div, file$e, 415, 28, 9846);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(415:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (407:24) {#if creatorData[media.type] && creatorData[media.type].length > 0}
    function create_if_block$8(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			t = space();
    			set_style(img, "width", /*media*/ ctx[18].type == "baaz" ? "50px" : " 30px");
    			if (img.src !== (img_src_value = "/img/socialMedia/" + /*media*/ ctx[18].type + ".svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-1o73zsj");
    			add_location(img, file$e, 408, 32, 9510);
    			attr_dev(a, "target", "_blank");

    			attr_dev(a, "href", a_href_value = /*creatorData*/ ctx[0][/*media*/ ctx[18].type].includes("http")
    			? /*creatorData*/ ctx[0][/*media*/ ctx[18].type]
    			: "https://" + /*creatorData*/ ctx[0][/*media*/ ctx[18].type]);

    			attr_dev(a, "class", "svelte-1o73zsj");
    			add_location(a, file$e, 407, 28, 9344);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*creatorData*/ 1 && a_href_value !== (a_href_value = /*creatorData*/ ctx[0][/*media*/ ctx[18].type].includes("http")
    			? /*creatorData*/ ctx[0][/*media*/ ctx[18].type]
    			: "https://" + /*creatorData*/ ctx[0][/*media*/ ctx[18].type])) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(407:24) {#if creatorData[media.type] && creatorData[media.type].length > 0}",
    		ctx
    	});

    	return block;
    }

    // (406:20) {#each socialMedias as media}
    function create_each_block_1$3(ctx) {
    	let if_block_anchor;
    	let if_block = /*creatorData*/ ctx[0][/*media*/ ctx[18].type] && /*creatorData*/ ctx[0][/*media*/ ctx[18].type].length > 0 && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*creatorData*/ ctx[0][/*media*/ ctx[18].type] && /*creatorData*/ ctx[0][/*media*/ ctx[18].type].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(406:20) {#each socialMedias as media}",
    		ctx
    	});

    	return block;
    }

    // (451:21) {#each amounts as amount,index}
    function create_each_block$7(ctx) {
    	let div;
    	let t0_value = /*amount*/ ctx[15] + "";
    	let t0;
    	let t1;
    	let t2_value = /*donator*/ ctx[1].currency + "";
    	let t2;
    	let t3;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[11](/*amount*/ ctx[15], /*index*/ ctx[17]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(div, "class", "amountBtn svelte-1o73zsj");
    			add_location(div, file$e, 451, 24, 10992);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*donator*/ 2 && t2_value !== (t2_value = /*donator*/ ctx[1].currency + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(451:21) {#each amounts as amount,index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let div19;
    	let div3;
    	let div0;
    	let h20;
    	let t0_value = ({ en: "Info", fr: "Info" })[/*$lang*/ ctx[2]] + "";
    	let t0;
    	let t1;
    	let hr0;
    	let t2;
    	let p;

    	let t3_value = (/*creatorData*/ ctx[0].description
    	? /*creatorData*/ ctx[0].description
    	: ({
    			en: "This user did not write anything about themselves",
    			fr: "Cet utilisateur n'a rien écrit sur lui-même "
    		})[/*$lang*/ ctx[2]]) + "";

    	let t3;
    	let t4;
    	let div2;
    	let h21;

    	let t5_value = ({
    		en: "Social Media",
    		fr: "Réseau Socieaux"
    	})[/*$lang*/ ctx[2]] + "";

    	let t5;
    	let t6;
    	let hr1;
    	let t7;
    	let div1;
    	let t8;
    	let div18;
    	let div12;
    	let div5;
    	let div4;
    	let input0;
    	let t9;
    	let label0;
    	let t11;
    	let select;
    	let option0;
    	let option1;
    	let option2;
    	let t15;
    	let div9;
    	let div6;
    	let t16;
    	let div8;
    	let input1;
    	let input1_value_bind_value;
    	let input1_value_value;
    	let t17;
    	let div7;
    	let t18;
    	let t19_value = /*donator*/ ctx[1].currency + "";
    	let t19;
    	let t20;
    	let textarea;
    	let t21;
    	let div10;
    	let input2;
    	let t22;
    	let label1;
    	let img0;
    	let img0_src_value;
    	let t23;
    	let t24;
    	let input3;
    	let t25;
    	let label2;
    	let img1;
    	let img1_src_value;
    	let t26;
    	let t27;
    	let input4;
    	let t28;
    	let label3;
    	let img2;
    	let img2_src_value;
    	let t29;
    	let t30;
    	let div11;
    	let t31;
    	let t32_value = /*creatorData*/ ctx[0].name + "";
    	let t32;
    	let t33;
    	let div17;
    	let div15;
    	let div13;
    	let span0;

    	let t34_value = (/*donator*/ ctx[1].name == ""
    	? "{Name}"
    	: /*donator*/ ctx[1].name) + "";

    	let t34;
    	let t35;
    	let span1;

    	let t36_value = (/*donator*/ ctx[1].amount == ""
    	? "{0.000}"
    	: /*donator*/ ctx[1].amount) + "";

    	let t36;
    	let t37;
    	let t38_value = /*donator*/ ctx[1].currency + "";
    	let t38;
    	let t39;
    	let div14;

    	let t40_value = (/*donator*/ ctx[1].message == ""
    	? "{Message}"
    	: /*donator*/ ctx[1].message) + "";

    	let t40;
    	let t41;
    	let div16;
    	let tabs;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = socialMedias;
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	let each0_else = null;

    	if (!each_value_1.length) {
    		each0_else = create_else_block$5(ctx);
    	}

    	let each_value = /*amounts*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	tabs = new Tabs({
    			props: { items: /*items*/ ctx[7] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div19 = element("div");
    			div3 = element("div");
    			div0 = element("div");
    			h20 = element("h2");
    			t0 = text(t0_value);
    			t1 = space();
    			hr0 = element("hr");
    			t2 = space();
    			p = element("p");
    			t3 = text(t3_value);
    			t4 = space();
    			div2 = element("div");
    			h21 = element("h2");
    			t5 = text(t5_value);
    			t6 = space();
    			hr1 = element("hr");
    			t7 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			if (each0_else) {
    				each0_else.c();
    			}

    			t8 = space();
    			div18 = element("div");
    			div12 = element("div");
    			div5 = element("div");
    			div4 = element("div");
    			input0 = element("input");
    			t9 = space();
    			label0 = element("label");
    			label0.textContent = "Your Name";
    			t11 = space();
    			select = element("select");
    			option0 = element("option");
    			option0.textContent = "TND";
    			option1 = element("option");
    			option1.textContent = "EUR";
    			option2 = element("option");
    			option2.textContent = "USD";
    			t15 = space();
    			div9 = element("div");
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t16 = space();
    			div8 = element("div");
    			input1 = element("input");
    			t17 = space();
    			div7 = element("div");
    			t18 = text("Minimum 1.000 ");
    			t19 = text(t19_value);
    			t20 = space();
    			textarea = element("textarea");
    			t21 = space();
    			div10 = element("div");
    			input2 = element("input");
    			t22 = space();
    			label1 = element("label");
    			img0 = element("img");
    			t23 = text("\r\n                    PayPal");
    			t24 = space();
    			input3 = element("input");
    			t25 = space();
    			label2 = element("label");
    			img1 = element("img");
    			t26 = text("\r\n                    Paymee");
    			t27 = space();
    			input4 = element("input");
    			t28 = space();
    			label3 = element("label");
    			img2 = element("img");
    			t29 = text("\r\n                    Flouci");
    			t30 = space();
    			div11 = element("div");
    			t31 = text("Donate To ");
    			t32 = text(t32_value);
    			t33 = space();
    			div17 = element("div");
    			div15 = element("div");
    			div13 = element("div");
    			span0 = element("span");
    			t34 = text(t34_value);
    			t35 = text(" \r\n                    Donated \r\n                ");
    			span1 = element("span");
    			t36 = text(t36_value);
    			t37 = space();
    			t38 = text(t38_value);
    			t39 = space();
    			div14 = element("div");
    			t40 = text(t40_value);
    			t41 = space();
    			div16 = element("div");
    			create_component(tabs.$$.fragment);
    			attr_dev(h20, "class", "info_title");
    			add_location(h20, file$e, 391, 16, 8505);
    			add_location(hr0, file$e, 392, 16, 8586);
    			attr_dev(p, "class", "u_desc svelte-1o73zsj");
    			add_location(p, file$e, 393, 16, 8610);
    			attr_dev(div0, "class", "info");
    			add_location(div0, file$e, 390, 12, 8469);
    			attr_dev(h21, "class", "social_title");
    			add_location(h21, file$e, 399, 16, 8921);
    			add_location(hr1, file$e, 402, 16, 9063);
    			attr_dev(div1, "class", "social_icons svelte-1o73zsj");
    			add_location(div1, file$e, 404, 16, 9144);
    			attr_dev(div2, "class", "socialMedia");
    			add_location(div2, file$e, 398, 12, 8878);
    			attr_dev(div3, "class", "u_info svelte-1o73zsj");
    			add_location(div3, file$e, 389, 4, 8435);
    			attr_dev(input0, "maxlength", "15");
    			attr_dev(input0, "type", "input");
    			attr_dev(input0, "class", "input_field svelte-1o73zsj");
    			attr_dev(input0, "placeholder", "Name");
    			attr_dev(input0, "name", "name");
    			attr_dev(input0, "id", "name");
    			input0.required = true;
    			add_location(input0, file$e, 428, 16, 10134);
    			attr_dev(label0, "for", "name");
    			attr_dev(label0, "class", "input_label svelte-1o73zsj");
    			add_location(label0, file$e, 437, 16, 10456);
    			attr_dev(div4, "class", "form__group field svelte-1o73zsj");
    			add_location(div4, file$e, 427, 16, 10085);
    			option0.__value = "TND";
    			option0.value = option0.__value;
    			add_location(option0, file$e, 440, 16, 10640);
    			option1.__value = "EUR";
    			option1.value = option1.__value;
    			add_location(option1, file$e, 441, 16, 10690);
    			option2.__value = "USD";
    			option2.value = option2.__value;
    			add_location(option2, file$e, 442, 16, 10740);
    			attr_dev(select, "name", "currency");
    			attr_dev(select, "id", "currency");
    			select.required = true;
    			attr_dev(select, "class", "svelte-1o73zsj");
    			if (/*donator*/ ctx[1].currency === void 0) add_render_callback(() => /*select_change_handler*/ ctx[10].call(select));
    			add_location(select, file$e, 439, 12, 10545);
    			attr_dev(div5, "class", "currencyName svelte-1o73zsj");
    			add_location(div5, file$e, 425, 12, 10039);
    			attr_dev(div6, "class", "selectAmounts svelte-1o73zsj");
    			add_location(div6, file$e, 449, 16, 10885);
    			attr_dev(input1, "value:bind", input1_value_bind_value = /*donator*/ ctx[1].amount);
    			input1.value = input1_value_value = /*donator*/ ctx[1].amount;
    			attr_dev(input1, "type", "input");
    			attr_dev(input1, "class", "input_field svelte-1o73zsj");
    			attr_dev(input1, "placeholder", "amount");
    			attr_dev(input1, "name", "amount");
    			attr_dev(input1, "id", "amount");
    			input1.required = true;
    			add_location(input1, file$e, 461, 16, 11339);
    			attr_dev(div7, "class", "minimumAmount svelte-1o73zsj");
    			add_location(div7, file$e, 473, 20, 11841);
    			attr_dev(div8, "class", "form__group field svelte-1o73zsj");
    			add_location(div8, file$e, 460, 16, 11290);
    			attr_dev(div9, "class", "amount svelte-1o73zsj");
    			add_location(div9, file$e, 447, 12, 10845);
    			attr_dev(textarea, "name", "tipMessage");
    			attr_dev(textarea, "id", "tipMessageID");
    			attr_dev(textarea, "maxlength", "250");
    			attr_dev(textarea, "class", "topMessage svelte-1o73zsj");
    			add_location(textarea, file$e, 478, 8, 11976);
    			attr_dev(input2, "type", "radio");
    			attr_dev(input2, "name", "amounts");
    			attr_dev(input2, "id", "method1");
    			attr_dev(input2, "class", "svelte-1o73zsj");
    			add_location(input2, file$e, 484, 16, 12181);
    			if (img0.src !== (img0_src_value = "/img/misc/paypal.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "paypal");
    			attr_dev(img0, "class", "svelte-1o73zsj");
    			add_location(img0, file$e, 486, 20, 12307);
    			attr_dev(label1, "for", "method1");
    			attr_dev(label1, "class", "method svelte-1o73zsj");
    			add_location(label1, file$e, 485, 16, 12248);
    			attr_dev(input3, "type", "radio");
    			attr_dev(input3, "name", "amounts");
    			attr_dev(input3, "id", "method2");
    			attr_dev(input3, "class", "svelte-1o73zsj");
    			add_location(input3, file$e, 490, 16, 12442);
    			if (img1.src !== (img1_src_value = "/img/misc/Paymee.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "paymee");
    			attr_dev(img1, "class", "svelte-1o73zsj");
    			add_location(img1, file$e, 492, 20, 12567);
    			attr_dev(label2, "for", "method2");
    			attr_dev(label2, "class", "method svelte-1o73zsj");
    			add_location(label2, file$e, 491, 16, 12508);
    			attr_dev(input4, "type", "radio");
    			attr_dev(input4, "name", "amounts");
    			attr_dev(input4, "id", "method3");
    			attr_dev(input4, "class", "svelte-1o73zsj");
    			add_location(input4, file$e, 495, 16, 12684);
    			if (img2.src !== (img2_src_value = "/img/misc/Flouci.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "flouci");
    			attr_dev(img2, "class", "svelte-1o73zsj");
    			add_location(img2, file$e, 497, 20, 12809);
    			attr_dev(label3, "for", "method3");
    			attr_dev(label3, "class", "method svelte-1o73zsj");
    			add_location(label3, file$e, 496, 16, 12750);
    			attr_dev(div10, "class", "paymentMethods svelte-1o73zsj");
    			add_location(div10, file$e, 480, 12, 12113);
    			attr_dev(div11, "class", "submit_button svelte-1o73zsj");
    			add_location(div11, file$e, 502, 12, 12944);
    			attr_dev(div12, "class", "donationForm svelte-1o73zsj");
    			add_location(div12, file$e, 424, 8, 9999);
    			attr_dev(span0, "class", "name svelte-1o73zsj");
    			add_location(span0, file$e, 512, 20, 13187);
    			attr_dev(span1, "class", "tipAmount svelte-1o73zsj");
    			add_location(span1, file$e, 514, 16, 13308);
    			attr_dev(div13, "class", "top");
    			add_location(div13, file$e, 511, 16, 13148);
    			attr_dev(div14, "class", "message svelte-1o73zsj");
    			add_location(div14, file$e, 516, 16, 13452);
    			attr_dev(div15, "class", "preview svelte-1o73zsj");
    			add_location(div15, file$e, 510, 12, 13109);
    			attr_dev(div16, "class", "donatorsInfo");
    			add_location(div16, file$e, 521, 12, 13610);
    			attr_dev(div17, "class", "donationInfo svelte-1o73zsj");
    			add_location(div17, file$e, 508, 8, 13067);
    			attr_dev(div18, "class", "donationContainer svelte-1o73zsj");
    			add_location(div18, file$e, 422, 4, 9956);
    			attr_dev(div19, "class", "container svelte-1o73zsj");
    			add_location(div19, file$e, 386, 0, 8402);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div19, anchor);
    			append_dev(div19, div3);
    			append_dev(div3, div0);
    			append_dev(div0, h20);
    			append_dev(h20, t0);
    			append_dev(div0, t1);
    			append_dev(div0, hr0);
    			append_dev(div0, t2);
    			append_dev(div0, p);
    			append_dev(p, t3);
    			append_dev(div3, t4);
    			append_dev(div3, div2);
    			append_dev(div2, h21);
    			append_dev(h21, t5);
    			append_dev(div2, t6);
    			append_dev(div2, hr1);
    			append_dev(div2, t7);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div1, null);
    			}

    			if (each0_else) {
    				each0_else.m(div1, null);
    			}

    			append_dev(div19, t8);
    			append_dev(div19, div18);
    			append_dev(div18, div12);
    			append_dev(div12, div5);
    			append_dev(div5, div4);
    			append_dev(div4, input0);
    			set_input_value(input0, /*donator*/ ctx[1].name);
    			append_dev(div4, t9);
    			append_dev(div4, label0);
    			append_dev(div5, t11);
    			append_dev(div5, select);
    			append_dev(select, option0);
    			append_dev(select, option1);
    			append_dev(select, option2);
    			select_option(select, /*donator*/ ctx[1].currency);
    			append_dev(div12, t15);
    			append_dev(div12, div9);
    			append_dev(div9, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div6, null);
    			}

    			append_dev(div9, t16);
    			append_dev(div9, div8);
    			append_dev(div8, input1);
    			append_dev(div8, t17);
    			append_dev(div8, div7);
    			append_dev(div7, t18);
    			append_dev(div7, t19);
    			append_dev(div12, t20);
    			append_dev(div12, textarea);
    			set_input_value(textarea, /*donator*/ ctx[1].message);
    			append_dev(div12, t21);
    			append_dev(div12, div10);
    			append_dev(div10, input2);
    			append_dev(div10, t22);
    			append_dev(div10, label1);
    			append_dev(label1, img0);
    			append_dev(label1, t23);
    			append_dev(div10, t24);
    			append_dev(div10, input3);
    			append_dev(div10, t25);
    			append_dev(div10, label2);
    			append_dev(label2, img1);
    			append_dev(label2, t26);
    			append_dev(div10, t27);
    			append_dev(div10, input4);
    			append_dev(div10, t28);
    			append_dev(div10, label3);
    			append_dev(label3, img2);
    			append_dev(label3, t29);
    			append_dev(div12, t30);
    			append_dev(div12, div11);
    			append_dev(div11, t31);
    			append_dev(div11, t32);
    			append_dev(div18, t33);
    			append_dev(div18, div17);
    			append_dev(div17, div15);
    			append_dev(div15, div13);
    			append_dev(div13, span0);
    			append_dev(span0, t34);
    			append_dev(div13, t35);
    			append_dev(div13, span1);
    			append_dev(span1, t36);
    			append_dev(span1, t37);
    			append_dev(span1, t38);
    			append_dev(div15, t39);
    			append_dev(div15, div14);
    			append_dev(div14, t40);
    			append_dev(div17, t41);
    			append_dev(div17, div16);
    			mount_component(tabs, div16, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[10]),
    					listen_dev(input1, "change", /*change_handler*/ ctx[12], false, false, false),
    					listen_dev(input1, "input", /*onInput*/ ctx[5], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[13])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$lang*/ 4) && t0_value !== (t0_value = ({ en: "Info", fr: "Info" })[/*$lang*/ ctx[2]] + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*creatorData, $lang*/ 5) && t3_value !== (t3_value = (/*creatorData*/ ctx[0].description
    			? /*creatorData*/ ctx[0].description
    			: ({
    					en: "This user did not write anything about themselves",
    					fr: "Cet utilisateur n'a rien écrit sur lui-même "
    				})[/*$lang*/ ctx[2]]) + "")) set_data_dev(t3, t3_value);

    			if ((!current || dirty & /*$lang*/ 4) && t5_value !== (t5_value = ({
    				en: "Social Media",
    				fr: "Réseau Socieaux"
    			})[/*$lang*/ ctx[2]] + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*creatorData, socialMedias*/ 1) {
    				each_value_1 = socialMedias;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$3(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;

    				if (each_value_1.length) {
    					if (each0_else) {
    						each0_else.d(1);
    						each0_else = null;
    					}
    				} else if (!each0_else) {
    					each0_else = create_else_block$5(ctx);
    					each0_else.c();
    					each0_else.m(div1, null);
    				}
    			}

    			if (dirty & /*donator*/ 2) {
    				set_input_value(input0, /*donator*/ ctx[1].name);
    			}

    			if (dirty & /*donator*/ 2) {
    				select_option(select, /*donator*/ ctx[1].currency);
    			}

    			if (dirty & /*onClick, amounts, donator*/ 82) {
    				each_value = /*amounts*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div6, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (!current || dirty & /*donator*/ 2 && input1_value_bind_value !== (input1_value_bind_value = /*donator*/ ctx[1].amount)) {
    				attr_dev(input1, "value:bind", input1_value_bind_value);
    			}

    			if (!current || dirty & /*donator*/ 2 && input1_value_value !== (input1_value_value = /*donator*/ ctx[1].amount)) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if ((!current || dirty & /*donator*/ 2) && t19_value !== (t19_value = /*donator*/ ctx[1].currency + "")) set_data_dev(t19, t19_value);

    			if (dirty & /*donator*/ 2) {
    				set_input_value(textarea, /*donator*/ ctx[1].message);
    			}

    			if ((!current || dirty & /*creatorData*/ 1) && t32_value !== (t32_value = /*creatorData*/ ctx[0].name + "")) set_data_dev(t32, t32_value);

    			if ((!current || dirty & /*donator*/ 2) && t34_value !== (t34_value = (/*donator*/ ctx[1].name == ""
    			? "{Name}"
    			: /*donator*/ ctx[1].name) + "")) set_data_dev(t34, t34_value);

    			if ((!current || dirty & /*donator*/ 2) && t36_value !== (t36_value = (/*donator*/ ctx[1].amount == ""
    			? "{0.000}"
    			: /*donator*/ ctx[1].amount) + "")) set_data_dev(t36, t36_value);

    			if ((!current || dirty & /*donator*/ 2) && t38_value !== (t38_value = /*donator*/ ctx[1].currency + "")) set_data_dev(t38, t38_value);

    			if ((!current || dirty & /*donator*/ 2) && t40_value !== (t40_value = (/*donator*/ ctx[1].message == ""
    			? "{Message}"
    			: /*donator*/ ctx[1].message) + "")) set_data_dev(t40, t40_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div19);
    			destroy_each(each_blocks_1, detaching);
    			if (each0_else) each0_else.d();
    			destroy_each(each_blocks, detaching);
    			destroy_component(tabs);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(2, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Donation", slots, []);
    	let { params = {} } = $$props;
    	let { creatorData = {} } = $$props;
    	document.documentElement.style.setProperty("--AccentColor", hexToRgb(creatorData.accentColor));
    	let filter = convert(creatorData.accentColor).replace("filter:", "").replace(";", "");
    	document.documentElement.style.setProperty("--AccentColorFilter", filter);

    	//add 3 zeros after ,
    	let addZeroes = num => {
    		let value = Number(num);

    		// Split the input string into two arrays containing integers/decimals
    		let res = num.split(".");

    		// If there is no decimal point or only one decimal place found.
    		if (res.length == 1 || res[1].length < 4) {
    			// Set the number to two decimal places
    			value = value.toFixed(3);
    		}

    		// Return updated or original number.
    		return value;
    	};

    	let donator = {
    		name: "",
    		currency: "",
    		amount: addZeroes("1"),
    		message: "",
    		method: ""
    	};

    	onMount(async () => {
    		$$invalidate(1, donator.currency = document.getElementById("currency").value, donator);
    	});

    	//default amounts are selected by user in creator app
    	let amounts = ["5", "10", "15", "20", "50"];

    	let onInput = e => {
    		let selectedIndex = amounts.indexOf(Number(e.currentTarget.value).toFixed(0));

    		if (selectedIndex == -1) {
    			let els = document.querySelectorAll(".amountBtn");

    			els.forEach(e => {
    				e.style.background = "transparent";
    				e.style.color = "black";
    			});
    		} else {
    			let els = document.querySelectorAll(".amountBtn");

    			els.forEach(e => {
    				e.style.background = "transparent";
    				e.style.color = "black";
    			});

    			document.querySelectorAll(".amountBtn")[selectedIndex].style.background = creatorData.accentColor;
    			document.querySelectorAll(".amountBtn")[selectedIndex].style.color = "white";
    		}
    	};

    	let onClick = (amount, index) => {
    		$$invalidate(1, donator.amount = addZeroes(amount), donator);

    		document.querySelectorAll(".amountBtn").forEach(e => {
    			e.style.background = "transparent";
    			e.style.color = "black";
    		});

    		document.querySelectorAll(".amountBtn")[index].style.background = creatorData.accentColor;
    		document.querySelectorAll(".amountBtn")[index].style.color = "white";
    	};

    	let items = [
    		{
    			label: "1 Week",
    			value: 1,
    			component: Week
    		},
    		{
    			label: "1 Month",
    			value: 2,
    			component: Month
    		},
    		{
    			label: "1 Year",
    			value: 3,
    			component: Year
    		}
    	];

    	const writable_props = ["params", "creatorData"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Donation> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		donator.name = this.value;
    		$$invalidate(1, donator);
    	}

    	function select_change_handler() {
    		donator.currency = select_value(this);
    		$$invalidate(1, donator);
    	}

    	const click_handler = (amount, index) => onClick(amount, index);
    	const change_handler = e => $$invalidate(1, donator.amount = addZeroes(e.currentTarget.value), donator);

    	function textarea_input_handler() {
    		donator.message = this.value;
    		$$invalidate(1, donator);
    	}

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(8, params = $$props.params);
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    	};

    	$$self.$capture_state = () => ({
    		hexToRgb,
    		convert,
    		lang,
    		cart,
    		uuidToImageLink,
    		socialMedias,
    		notification,
    		colors,
    		link,
    		navigate,
    		onMount,
    		Tabs,
    		Week,
    		Month,
    		Year,
    		params,
    		creatorData,
    		filter,
    		addZeroes,
    		donator,
    		amounts,
    		onInput,
    		onClick,
    		items,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(8, params = $$props.params);
    		if ("creatorData" in $$props) $$invalidate(0, creatorData = $$props.creatorData);
    		if ("filter" in $$props) filter = $$props.filter;
    		if ("addZeroes" in $$props) $$invalidate(3, addZeroes = $$props.addZeroes);
    		if ("donator" in $$props) $$invalidate(1, donator = $$props.donator);
    		if ("amounts" in $$props) $$invalidate(4, amounts = $$props.amounts);
    		if ("onInput" in $$props) $$invalidate(5, onInput = $$props.onInput);
    		if ("onClick" in $$props) $$invalidate(6, onClick = $$props.onClick);
    		if ("items" in $$props) $$invalidate(7, items = $$props.items);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		creatorData,
    		donator,
    		$lang,
    		addZeroes,
    		amounts,
    		onInput,
    		onClick,
    		items,
    		params,
    		input0_input_handler,
    		select_change_handler,
    		click_handler,
    		change_handler,
    		textarea_input_handler
    	];
    }

    class Donation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { params: 8, creatorData: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Donation",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get params() {
    		throw new Error("<Donation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Donation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get creatorData() {
    		throw new Error("<Donation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set creatorData(value) {
    		throw new Error("<Donation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\routes\Creator\DonationPage.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$5, console: console_1$4 } = globals;
    const file$f = "src\\routes\\Creator\\DonationPage.svelte";

    // (55:0) {:else}
    function create_else_block$6(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "100px", height: "100px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-view svelte-f8qh6r");
    			add_location(div, file$f, 55, 4, 1505);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(55:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (51:0) {#if validated}
    function create_if_block$9(ctx) {
    	let navbar;
    	let updating_creatorData;
    	let t;
    	let donation;
    	let current;

    	function navbar_creatorData_binding(value) {
    		/*navbar_creatorData_binding*/ ctx[3](value);
    	}

    	let navbar_props = {};

    	if (/*data*/ ctx[2] !== void 0) {
    		navbar_props.creatorData = /*data*/ ctx[2];
    	}

    	navbar = new NavbarCC({ props: navbar_props, $$inline: true });
    	binding_callbacks.push(() => bind(navbar, "creatorData", navbar_creatorData_binding));

    	donation = new Donation({
    			props: {
    				creatorData: /*data*/ ctx[2],
    				params: /*params*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navbar.$$.fragment);
    			t = space();
    			create_component(donation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbar, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(donation, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navbar_changes = {};

    			if (!updating_creatorData && dirty & /*data*/ 4) {
    				updating_creatorData = true;
    				navbar_changes.creatorData = /*data*/ ctx[2];
    				add_flush_callback(() => updating_creatorData = false);
    			}

    			navbar.$set(navbar_changes);
    			const donation_changes = {};
    			if (dirty & /*data*/ 4) donation_changes.creatorData = /*data*/ ctx[2];
    			if (dirty & /*params*/ 1) donation_changes.params = /*params*/ ctx[0];
    			donation.$set(donation_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbar.$$.fragment, local);
    			transition_in(donation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbar.$$.fragment, local);
    			transition_out(donation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbar, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(donation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(51:0) {#if validated}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$9, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*validated*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DonationPage", slots, []);
    	let { params = {} } = $$props;
    	let validated = false;
    	let data = {};

    	onMount(async () => {
    		console.log("merch page mounted");
    		$$invalidate(2, data = await dbWrapper.get("/creators/" + params.userid));

    		if (Object.keys(data).length == 0) {
    			navigate("/");
    			return;
    		}

    		for (let x of ["logo", "banner"]) {
    			if (data[x]) {
    				$$invalidate(2, data[x] = uuidToImageLink(data[x], "creators/" + params.userid + "/" + x), data);
    			}
    		}

    		if (data.accentColor == undefined) {
    			$$invalidate(2, data.accentColor = "#46b978", data);
    		}

    		$$invalidate(2, data);
    		console.log("creator data xd");
    		console.log(data);
    		$$invalidate(1, validated = true);
    	});

    	const writable_props = ["params"];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<DonationPage> was created with unknown prop '${key}'`);
    	});

    	function navbar_creatorData_binding(value) {
    		data = value;
    		$$invalidate(2, data);
    	}

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		Donation,
    		params,
    		onMount,
    		dbWrapper,
    		navigate,
    		MaterialSpinner,
    		uuidToImageLink,
    		Navbar: NavbarCC,
    		validated,
    		data
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("validated" in $$props) $$invalidate(1, validated = $$props.validated);
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [params, validated, data, navbar_creatorData_binding];
    }

    class DonationPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DonationPage",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get params() {
    		throw new Error("<DonationPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<DonationPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\FooterCC.svelte generated by Svelte v3.32.3 */
    const file$g = "src\\components\\FooterCC.svelte";

    function create_fragment$l(ctx) {
    	let div3;
    	let a;
    	let div1;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let t1;
    	let span;
    	let t3;
    	let div2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			a = element("a");
    			div1 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			t1 = text("Powered By ");
    			span = element("span");
    			span.textContent = "Unify";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "@2021 All Right Reserved";
    			if (img.src !== (img_src_value = "/img/logo_transaprent.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "svelte-1gk5mjv");
    			add_location(img, file$g, 9, 12, 169);
    			attr_dev(span, "class", "unify svelte-1gk5mjv");
    			add_location(span, file$g, 11, 27, 283);
    			attr_dev(div0, "class", "powered svelte-1gk5mjv");
    			add_location(div0, file$g, 10, 12, 233);
    			attr_dev(div1, "class", "poweredContainer svelte-1gk5mjv");
    			add_location(div1, file$g, 8, 8, 125);
    			attr_dev(a, "href", "/");
    			add_location(a, file$g, 7, 4, 94);
    			attr_dev(div2, "class", "copyright svelte-1gk5mjv");
    			add_location(div2, file$g, 15, 4, 367);
    			attr_dev(div3, "class", "footer svelte-1gk5mjv");
    			add_location(div3, file$g, 6, 0, 68);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, a);
    			append_dev(a, div1);
    			append_dev(div1, img);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div0, t1);
    			append_dev(div0, span);
    			append_dev(div3, t3);
    			append_dev(div3, div2);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FooterCC", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FooterCC> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link });
    	return [];
    }

    class FooterCC extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FooterCC",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* src\routes\Creator\EntryCreator.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$6, console: console_1$5 } = globals;
    const file$h = "src\\routes\\Creator\\EntryCreator.svelte";

    // (73:8) {:else}
    function create_else_block_3(ctx) {
    	let redirector;
    	let current;

    	redirector = new Redirector({
    			props: {
    				path: "/" + /*params*/ ctx[0].userid + "/merch"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(redirector.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(redirector, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const redirector_changes = {};
    			if (dirty & /*params*/ 1) redirector_changes.path = "/" + /*params*/ ctx[0].userid + "/merch";
    			redirector.$set(redirector_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(redirector.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(redirector.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(redirector, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3.name,
    		type: "else",
    		source: "(73:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (67:8) {#if validated == false}
    function create_if_block_3$2(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "75px", height: "75px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-center-area svelte-bkylbt");
    			add_location(div, file$h, 67, 12, 2074);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(67:8) {#if validated == false}",
    		ctx
    	});

    	return block;
    }

    // (66:4) <Route path="/">
    function create_default_slot_4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_3$2, create_else_block_3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*validated*/ ctx[2] == false) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(66:4) <Route path=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (85:8) {:else}
    function create_else_block_2(ctx) {
    	let donationpage;
    	let t;
    	let footercc;
    	let current;

    	donationpage = new DonationPage({
    			props: { params: /*localParams*/ ctx[3] },
    			$$inline: true
    		});

    	footercc = new FooterCC({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(donationpage.$$.fragment);
    			t = space();
    			create_component(footercc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(donationpage, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(footercc, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const donationpage_changes = {};
    			if (dirty & /*localParams*/ 8) donationpage_changes.params = /*localParams*/ ctx[3];
    			donationpage.$set(donationpage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(donationpage.$$.fragment, local);
    			transition_in(footercc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(donationpage.$$.fragment, local);
    			transition_out(footercc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(donationpage, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(footercc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(85:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (79:8) {#if validated == false}
    function create_if_block_2$2(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "75px", height: "75px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-center-area svelte-bkylbt");
    			add_location(div, file$h, 79, 12, 2388);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(79:8) {#if validated == false}",
    		ctx
    	});

    	return block;
    }

    // (78:4) <Route path="/tip">
    function create_default_slot_3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_2$2, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*validated*/ ctx[2] == false) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(78:4) <Route path=\\\"/tip\\\">",
    		ctx
    	});

    	return block;
    }

    // (99:8) {:else}
    function create_else_block_1$1(ctx) {
    	let merchpage;
    	let t;
    	let footercc;
    	let current;

    	merchpage = new MerchPage({
    			props: { params: /*localParams*/ ctx[3] },
    			$$inline: true
    		});

    	footercc = new FooterCC({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(merchpage.$$.fragment);
    			t = space();
    			create_component(footercc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(merchpage, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(footercc, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const merchpage_changes = {};
    			if (dirty & /*localParams*/ 8) merchpage_changes.params = /*localParams*/ ctx[3];
    			merchpage.$set(merchpage_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(merchpage.$$.fragment, local);
    			transition_in(footercc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(merchpage.$$.fragment, local);
    			transition_out(footercc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(merchpage, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(footercc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(99:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (93:8) {#if validated == false}
    function create_if_block_1$4(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "75px", height: "75px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-center-area svelte-bkylbt");
    			add_location(div, file$h, 93, 12, 2721);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(93:8) {#if validated == false}",
    		ctx
    	});

    	return block;
    }

    // (92:4) <Route path="/merch">
    function create_default_slot_2(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$4, create_else_block_1$1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*validated*/ ctx[2] == false) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(92:4) <Route path=\\\"/merch\\\">",
    		ctx
    	});

    	return block;
    }

    // (112:8) {:else}
    function create_else_block$7(ctx) {
    	let singleproduct;
    	let t;
    	let footercc;
    	let current;

    	singleproduct = new SingleProductPage({
    			props: {
    				params: {
    					.../*localParams*/ ctx[3],
    					.../*params*/ ctx[0]
    				}
    			},
    			$$inline: true
    		});

    	footercc = new FooterCC({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(singleproduct.$$.fragment);
    			t = space();
    			create_component(footercc.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(singleproduct, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(footercc, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const singleproduct_changes = {};

    			if (dirty & /*localParams, params*/ 9) singleproduct_changes.params = {
    				.../*localParams*/ ctx[3],
    				.../*params*/ ctx[0]
    			};

    			singleproduct.$set(singleproduct_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(singleproduct.$$.fragment, local);
    			transition_in(footercc.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(singleproduct.$$.fragment, local);
    			transition_out(footercc.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(singleproduct, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(footercc, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(112:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (106:8) {#if validated == false}
    function create_if_block$a(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "75px", height: "75px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-center-area svelte-bkylbt");
    			add_location(div, file$h, 106, 12, 3064);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(106:8) {#if validated == false}",
    		ctx
    	});

    	return block;
    }

    // (105:4) <Route let:params path="/merch/:itemid">
    function create_default_slot_1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$a, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*validated*/ ctx[2] == false) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(105:4) <Route let:params path=\\\"/merch/:itemid\\\">",
    		ctx
    	});

    	return block;
    }

    // (63:0) <Router url={url}>
    function create_default_slot(ctx) {
    	let route0;
    	let t0;
    	let route1;
    	let t1;
    	let route2;
    	let t2;
    	let route3;
    	let current;

    	route0 = new Route({
    			props: {
    				path: "/",
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route1 = new Route({
    			props: {
    				path: "/tip",
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route2 = new Route({
    			props: {
    				path: "/merch",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route3 = new Route({
    			props: {
    				path: "/merch/:itemid",
    				$$slots: {
    					default: [
    						create_default_slot_1,
    						({ params }) => ({ 0: params }),
    						({ params }) => params ? 1 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route0.$$.fragment);
    			t0 = space();
    			create_component(route1.$$.fragment);
    			t1 = space();
    			create_component(route2.$$.fragment);
    			t2 = space();
    			create_component(route3.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(route1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(route2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(route3, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route0_changes = {};

    			if (dirty & /*$$scope, validated, params*/ 21) {
    				route0_changes.$$scope = { dirty, ctx };
    			}

    			route0.$set(route0_changes);
    			const route1_changes = {};

    			if (dirty & /*$$scope, validated, localParams*/ 28) {
    				route1_changes.$$scope = { dirty, ctx };
    			}

    			route1.$set(route1_changes);
    			const route2_changes = {};

    			if (dirty & /*$$scope, validated, localParams*/ 28) {
    				route2_changes.$$scope = { dirty, ctx };
    			}

    			route2.$set(route2_changes);
    			const route3_changes = {};

    			if (dirty & /*$$scope, validated, localParams, params*/ 29) {
    				route3_changes.$$scope = { dirty, ctx };
    			}

    			route3.$set(route3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(route1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(route2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(route3, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(63:0) <Router url={url}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				url: /*url*/ ctx[1],
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};
    			if (dirty & /*url*/ 2) router_changes.url = /*url*/ ctx[1];

    			if (dirty & /*$$scope, validated, localParams, params*/ 29) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let localParams;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EntryCreator", slots, []);
    	let { url = "" } = $$props;
    	let { params } = $$props;
    	console.log("entry work");
    	let validated = false;

    	onMount(async () => {
    		$$invalidate(0, params.userid = params.userid.toLowerCase(), params);
    		let data = await dbWrapper.get("/creators/" + params.userid, false, true);

    		if (Object.keys(data).length == 0) {
    			console.log("no store");
    			navigate("/");
    		} else if (data.storeEnabled == false) {
    			if (data.fromCache) {
    				data = await dbWrapper.get("/creators/" + params.userid, true);

    				if (data.storeEnabled == false) {
    					//store is disabled from cache then read and is disbaled from DB tooo
    					navigate("/", { replace: true });
    				} else {
    					// store was disabled from cache but enabled from DB
    					navigate("/" + params.userid + "/merch", { replace: true });

    					$$invalidate(2, validated = true);
    				}
    			} else {
    				// store is disabled from DB
    				navigate("/", { replace: true });
    			}
    		} else {
    			$$invalidate(2, validated = true);
    		}
    	});

    	const writable_props = ["url", "params"];

    	Object_1$6.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<EntryCreator> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("url" in $$props) $$invalidate(1, url = $$props.url);
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		Router,
    		Link,
    		Route,
    		navigate,
    		url,
    		params,
    		onMount,
    		dbWrapper,
    		Redirector,
    		MerchPage,
    		DonationPage,
    		SingleProduct: SingleProductPage,
    		FooterCC,
    		MaterialSpinner,
    		validated,
    		localParams
    	});

    	$$self.$inject_state = $$props => {
    		if ("url" in $$props) $$invalidate(1, url = $$props.url);
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("validated" in $$props) $$invalidate(2, validated = $$props.validated);
    		if ("localParams" in $$props) $$invalidate(3, localParams = $$props.localParams);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*params*/ 1) {
    			$$invalidate(3, localParams = params);
    		}
    	};

    	return [params, url, validated, localParams];
    }

    class EntryCreator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { url: 1, params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EntryCreator",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*params*/ ctx[0] === undefined && !("params" in props)) {
    			console_1$5.warn("<EntryCreator> was created without expected prop 'params'");
    		}
    	}

    	get url() {
    		throw new Error("<EntryCreator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<EntryCreator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get params() {
    		throw new Error("<EntryCreator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<EntryCreator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\misc\UnifyLogo.svelte generated by Svelte v3.32.3 */
    const file$i = "src\\components\\misc\\UnifyLogo.svelte";

    function create_fragment$n(ctx) {
    	let svg;
    	let g1;
    	let g0;
    	let path0;
    	let g3;
    	let g2;
    	let path1;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			g1 = svg_element("g");
    			g0 = svg_element("g");
    			path0 = svg_element("path");
    			g3 = svg_element("g");
    			g2 = svg_element("g");
    			path1 = svg_element("path");
    			attr_dev(path0, "class", "st0");
    			set_style(path0, "fill", /*$downColor*/ ctx[1]);
    			attr_dev(path0, "d", "M459.3,235.9L325.9,466.6c-47.1,81.5-151.7,109.5-233.2,62.3c-39.4-22.8-67.6-59.6-79.4-103.7\r\n\t\t\tc-11.8-44.1-5.8-90.1,17-129.5L163.7,65.1c7.6-13.2,21.5-20.5,35.7-20.5c7,0,14,1.8,20.5,5.5c19.6,11.4,26.3,36.6,15,56.2\r\n\t\t\tL101.5,336.9c-24.4,42.3-9.9,96.5,32.3,120.9c20.4,11.8,44.3,15,67.1,8.8c22.9-6.1,41.9-20.7,53.8-41.1l133.4-230.7\r\n\t\t\tc11.3-19.6,36.5-26.4,56.2-15.1C463.9,191.1,470.6,216.3,459.3,235.9z");
    			add_location(path0, file$i, 16, 4, 374);
    			add_location(g0, file$i, 15, 1, 365);
    			add_location(g1, file$i, 14, 0, 359);
    			attr_dev(path1, "class", "st1");
    			set_style(path1, "fill", /*$upColor*/ ctx[2]);
    			attr_dev(path1, "d", "M571.1,300.3L437.9,531c-11.3,19.6-36.5,26.4-56.2,15.1c-19.6-11.3-26.4-36.5-15.1-56.2l133.2-230.7\r\n\t\t\tc24.4-42.3,9.9-96.5-32.4-120.9c-13.6-7.9-28.7-11.9-44-11.9c-7.7,0-15.4,1-23.1,3.1c-22.8,6.1-41.9,20.7-53.7,41.1L213.5,401.5\r\n\t\t\tc-11.4,19.6-36.6,26.4-56.2,15.1c-9.5-5.5-16.3-14.4-19.1-25c-2.8-10.6-1.4-21.7,4.1-31.2l133.2-230.8\r\n\t\t\tc22.7-39.4,59.6-67.6,103.7-79.5c44.1-11.8,90.1-5.8,129.5,17c39.4,22.7,67.6,59.6,79.5,103.7\r\n\t\t\tC599.9,214.9,593.9,260.9,571.1,300.3z");
    			add_location(path1, file$i, 24, 2, 851);
    			add_location(g2, file$i, 23, 1, 844);
    			add_location(g3, file$i, 22, 0, 838);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "Layer_1");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "viewBox", "0 0 600 600");
    			set_style(svg, "enable-background", "new 0 0 600 600");
    			set_style(svg, "width", /*width*/ ctx[0]);
    			attr_dev(svg, "xml:space", "preserve");
    			add_location(svg, file$i, 12, 0, 128);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, g1);
    			append_dev(g1, g0);
    			append_dev(g0, path0);
    			append_dev(svg, g3);
    			append_dev(g3, g2);
    			append_dev(g2, path1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$downColor*/ 2) {
    				set_style(path0, "fill", /*$downColor*/ ctx[1]);
    			}

    			if (dirty & /*$upColor*/ 4) {
    				set_style(path1, "fill", /*$upColor*/ ctx[2]);
    			}

    			if (dirty & /*width*/ 1) {
    				set_style(svg, "width", /*width*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $downColor;
    	let $upColor;
    	validate_store(downColor, "downColor");
    	component_subscribe($$self, downColor, $$value => $$invalidate(1, $downColor = $$value));
    	validate_store(upColor, "upColor");
    	component_subscribe($$self, upColor, $$value => $$invalidate(2, $upColor = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UnifyLogo", slots, []);
    	let { width = "35px" } = $$props;
    	const writable_props = ["width"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<UnifyLogo> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    	};

    	$$self.$capture_state = () => ({
    		upColor,
    		downColor,
    		width,
    		$downColor,
    		$upColor
    	});

    	$$self.$inject_state = $$props => {
    		if ("width" in $$props) $$invalidate(0, width = $$props.width);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [width, $downColor, $upColor];
    }

    class UnifyLogo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { width: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UnifyLogo",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get width() {
    		throw new Error("<UnifyLogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set width(value) {
    		throw new Error("<UnifyLogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\NavbarUnify.svelte generated by Svelte v3.32.3 */
    const file$j = "src\\components\\NavbarUnify.svelte";

    // (541:8) {#if signedin}
    function create_if_block_5$1(ctx) {
    	let div11;
    	let div1;
    	let t0_value = ({ en: "My Account", fr: "Mon Compte" })[/*$lang*/ ctx[10]] + "";
    	let t0;
    	let t1;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t2;
    	let div10;
    	let div5;
    	let img1;
    	let img1_src_value;
    	let img1_style_value;
    	let t3;
    	let div4;
    	let div2;

    	let t4_value = (/*$user*/ ctx[0] && /*$user*/ ctx[0].displayName
    	? /*$user*/ ctx[0].displayName
    	: "User") + "";

    	let t4;
    	let t5;
    	let div3;
    	let a0;

    	let t6_value = ({
    		en: "Edit Profile",
    		fr: "Modifier votre profil"
    	})[/*$lang*/ ctx[10]] + "";

    	let t6;
    	let t7;
    	let hr;
    	let t8;
    	let div9;
    	let div6;
    	let img2;
    	let img2_src_value;
    	let img2_style_value;
    	let t9;
    	let a1;

    	let t10_value = ({
    		en: "Your Wishlist",
    		fr: "Votre Liste d'envie"
    	})[/*$lang*/ ctx[10]] + "";

    	let t10;
    	let t11;
    	let div7;
    	let img3;
    	let img3_src_value;
    	let img3_style_value;
    	let t12;
    	let a2;
    	let t13_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[10]] + "";
    	let t13;
    	let t14;
    	let div8;
    	let t16;
    	let div15;
    	let div12;
    	let a3;

    	let t17_value = ({
    		en: "Your Wishlist",
    		fr: "Votre Liste d'envie"
    	})[/*$lang*/ ctx[10]] + "";

    	let t17;
    	let t18;
    	let div13;
    	let a4;
    	let t19_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[10]] + "";
    	let t19;
    	let t20;
    	let div14;
    	let t21;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div1 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			img0 = element("img");
    			t2 = space();
    			div10 = element("div");
    			div5 = element("div");
    			img1 = element("img");
    			t3 = space();
    			div4 = element("div");
    			div2 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div3 = element("div");
    			a0 = element("a");
    			t6 = text(t6_value);
    			t7 = space();
    			hr = element("hr");
    			t8 = space();
    			div9 = element("div");
    			div6 = element("div");
    			img2 = element("img");
    			t9 = space();
    			a1 = element("a");
    			t10 = text(t10_value);
    			t11 = space();
    			div7 = element("div");
    			img3 = element("img");
    			t12 = space();
    			a2 = element("a");
    			t13 = text(t13_value);
    			t14 = space();
    			div8 = element("div");
    			div8.textContent = "Logout";
    			t16 = space();
    			div15 = element("div");
    			div12 = element("div");
    			a3 = element("a");
    			t17 = text(t17_value);
    			t18 = space();
    			div13 = element("div");
    			a4 = element("a");
    			t19 = text(t19_value);
    			t20 = space();
    			div14 = element("div");
    			t21 = text("Logout");

    			if (img0.src !== (img0_src_value = /*isScroll*/ ctx[6]
    			? "/img/misc/user-white.png"
    			: "/img/misc/user.png")) attr_dev(img0, "src", img0_src_value);

    			attr_dev(img0, "alt", "avatar");
    			attr_dev(img0, "class", "svelte-1c68a2m");
    			add_location(img0, file$j, 549, 24, 14169);
    			attr_dev(div0, "class", "user_avatar svelte-1c68a2m");
    			add_location(div0, file$j, 548, 20, 14118);
    			attr_dev(div1, "class", "menu_item svelte-1c68a2m");
    			toggle_class(div1, "myAccount", /*myAccount*/ ctx[3]);
    			add_location(div1, file$j, 546, 16, 13988);
    			if (img1.src !== (img1_src_value = "/img/misc/user.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "avatar");
    			attr_dev(img1, "style", img1_style_value = convert(/*$downColor*/ ctx[9]));
    			attr_dev(img1, "class", "svelte-1c68a2m");
    			add_location(img1, file$j, 555, 24, 14488);
    			attr_dev(div2, "class", "u_name svelte-1c68a2m");
    			add_location(div2, file$j, 557, 24, 14635);
    			attr_dev(a0, "href", "/myaccount/profile");
    			attr_dev(a0, "class", "btn svelte-1c68a2m");
    			add_location(a0, file$j, 559, 28, 14801);
    			attr_dev(div3, "class", "edit_btn svelte-1c68a2m");
    			add_location(div3, file$j, 558, 28, 14749);
    			attr_dev(div4, "class", "user_info svelte-1c68a2m");
    			add_location(div4, file$j, 556, 24, 14586);
    			attr_dev(div5, "class", "first_part svelte-1c68a2m");
    			add_location(div5, file$j, 554, 20, 14438);
    			attr_dev(hr, "class", "svelte-1c68a2m");
    			add_location(hr, file$j, 565, 20, 15102);
    			if (img2.src !== (img2_src_value = "/img/misc/wishlist.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "wishlist");
    			attr_dev(img2, "style", img2_style_value = convert(/*$downColor*/ ctx[9]));
    			attr_dev(img2, "class", "svelte-1c68a2m");
    			add_location(img2, file$j, 568, 28, 15254);
    			attr_dev(a1, "href", "/myaccount/wishlist");
    			attr_dev(a1, "class", "svelte-1c68a2m");
    			add_location(a1, file$j, 569, 28, 15361);
    			attr_dev(div6, "class", "help svelte-1c68a2m");
    			set_style(div6, "color", /*$downColor*/ ctx[9]);
    			add_location(div6, file$j, 567, 20, 15178);
    			if (img3.src !== (img3_src_value = "/img/misc/order.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "order");
    			attr_dev(img3, "style", img3_style_value = convert(/*$downColor*/ ctx[9]));
    			attr_dev(img3, "class", "svelte-1c68a2m");
    			add_location(img3, file$j, 572, 28, 15598);
    			attr_dev(a2, "href", "/myaccount/orders");
    			attr_dev(a2, "class", "svelte-1c68a2m");
    			add_location(a2, file$j, 573, 28, 15699);
    			attr_dev(div7, "class", "help svelte-1c68a2m");
    			set_style(div7, "color", /*$downColor*/ ctx[9]);
    			add_location(div7, file$j, 571, 24, 15522);
    			attr_dev(div8, "class", "logout svelte-1c68a2m");
    			add_location(div8, file$j, 575, 24, 15849);
    			attr_dev(div9, "class", "second_part svelte-1c68a2m");
    			add_location(div9, file$j, 566, 20, 15130);
    			attr_dev(div10, "class", "popup_myaccount svelte-1c68a2m");
    			set_style(div10, "background-color", /*popup_myaccount*/ ctx[5]);
    			toggle_class(div10, "myAccount", /*myAccount*/ ctx[3]);
    			add_location(div10, file$j, 553, 16, 14328);
    			attr_dev(div11, "class", "my_account svelte-1c68a2m");
    			attr_dev(div11, "id", "myAccount");
    			add_location(div11, file$j, 541, 12, 13820);
    			attr_dev(a3, "href", "/myaccount/wishlist");
    			attr_dev(a3, "class", "svelte-1c68a2m");
    			add_location(a3, file$j, 580, 61, 16089);
    			attr_dev(div12, "class", "help svelte-1c68a2m");
    			set_style(div12, "color", /*$downColor*/ ctx[9]);
    			add_location(div12, file$j, 580, 16, 16044);
    			attr_dev(a4, "href", "/myaccount/orders");
    			attr_dev(a4, "class", "svelte-1c68a2m");
    			add_location(a4, file$j, 581, 61, 16260);
    			attr_dev(div13, "class", "help svelte-1c68a2m");
    			set_style(div13, "color", /*$downColor*/ ctx[9]);
    			add_location(div13, file$j, 581, 16, 16215);
    			attr_dev(div14, "class", "logout svelte-1c68a2m");
    			set_style(div14, "color", /*$downColor*/ ctx[9]);
    			add_location(div14, file$j, 582, 16, 16376);
    			attr_dev(div15, "class", "help_logout svelte-1c68a2m");
    			add_location(div15, file$j, 579, 12, 16001);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div1);
    			append_dev(div1, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			append_dev(div0, img0);
    			append_dev(div11, t2);
    			append_dev(div11, div10);
    			append_dev(div10, div5);
    			append_dev(div5, img1);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div2);
    			append_dev(div2, t4);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			append_dev(div3, a0);
    			append_dev(a0, t6);
    			append_dev(div10, t7);
    			append_dev(div10, hr);
    			append_dev(div10, t8);
    			append_dev(div10, div9);
    			append_dev(div9, div6);
    			append_dev(div6, img2);
    			append_dev(div6, t9);
    			append_dev(div6, a1);
    			append_dev(a1, t10);
    			append_dev(div9, t11);
    			append_dev(div9, div7);
    			append_dev(div7, img3);
    			append_dev(div7, t12);
    			append_dev(div7, a2);
    			append_dev(a2, t13);
    			append_dev(div9, t14);
    			append_dev(div9, div8);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, div15, anchor);
    			append_dev(div15, div12);
    			append_dev(div12, a3);
    			append_dev(a3, t17);
    			append_dev(div15, t18);
    			append_dev(div15, div13);
    			append_dev(div13, a4);
    			append_dev(a4, t19);
    			append_dev(div15, t20);
    			append_dev(div15, div14);
    			append_dev(div14, t21);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					action_destroyer(link.call(null, a2)),
    					listen_dev(div8, "click", /*click_handler*/ ctx[12], false, false, false),
    					listen_dev(div11, "click", /*click_handler_1*/ ctx[13], false, false, false),
    					action_destroyer(link.call(null, a3)),
    					action_destroyer(link.call(null, a4)),
    					listen_dev(div14, "click", /*click_handler_2*/ ctx[14], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 1024 && t0_value !== (t0_value = ({ en: "My Account", fr: "Mon Compte" })[/*$lang*/ ctx[10]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*isScroll*/ 64 && img0.src !== (img0_src_value = /*isScroll*/ ctx[6]
    			? "/img/misc/user-white.png"
    			: "/img/misc/user.png")) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty & /*myAccount*/ 8) {
    				toggle_class(div1, "myAccount", /*myAccount*/ ctx[3]);
    			}

    			if (dirty & /*$downColor*/ 512 && img1_style_value !== (img1_style_value = convert(/*$downColor*/ ctx[9]))) {
    				attr_dev(img1, "style", img1_style_value);
    			}

    			if (dirty & /*$user*/ 1 && t4_value !== (t4_value = (/*$user*/ ctx[0] && /*$user*/ ctx[0].displayName
    			? /*$user*/ ctx[0].displayName
    			: "User") + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*$lang*/ 1024 && t6_value !== (t6_value = ({
    				en: "Edit Profile",
    				fr: "Modifier votre profil"
    			})[/*$lang*/ ctx[10]] + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*$downColor*/ 512 && img2_style_value !== (img2_style_value = convert(/*$downColor*/ ctx[9]))) {
    				attr_dev(img2, "style", img2_style_value);
    			}

    			if (dirty & /*$lang*/ 1024 && t10_value !== (t10_value = ({
    				en: "Your Wishlist",
    				fr: "Votre Liste d'envie"
    			})[/*$lang*/ ctx[10]] + "")) set_data_dev(t10, t10_value);

    			if (dirty & /*$downColor*/ 512) {
    				set_style(div6, "color", /*$downColor*/ ctx[9]);
    			}

    			if (dirty & /*$downColor*/ 512 && img3_style_value !== (img3_style_value = convert(/*$downColor*/ ctx[9]))) {
    				attr_dev(img3, "style", img3_style_value);
    			}

    			if (dirty & /*$lang*/ 1024 && t13_value !== (t13_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[10]] + "")) set_data_dev(t13, t13_value);

    			if (dirty & /*$downColor*/ 512) {
    				set_style(div7, "color", /*$downColor*/ ctx[9]);
    			}

    			if (dirty & /*popup_myaccount*/ 32) {
    				set_style(div10, "background-color", /*popup_myaccount*/ ctx[5]);
    			}

    			if (dirty & /*myAccount*/ 8) {
    				toggle_class(div10, "myAccount", /*myAccount*/ ctx[3]);
    			}

    			if (dirty & /*$lang*/ 1024 && t17_value !== (t17_value = ({
    				en: "Your Wishlist",
    				fr: "Votre Liste d'envie"
    			})[/*$lang*/ ctx[10]] + "")) set_data_dev(t17, t17_value);

    			if (dirty & /*$downColor*/ 512) {
    				set_style(div12, "color", /*$downColor*/ ctx[9]);
    			}

    			if (dirty & /*$lang*/ 1024 && t19_value !== (t19_value = ({ en: "Your Orders", fr: "Vos commandes" })[/*$lang*/ ctx[10]] + "")) set_data_dev(t19, t19_value);

    			if (dirty & /*$downColor*/ 512) {
    				set_style(div13, "color", /*$downColor*/ ctx[9]);
    			}

    			if (dirty & /*$downColor*/ 512) {
    				set_style(div14, "color", /*$downColor*/ ctx[9]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(div15);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(541:8) {#if signedin}",
    		ctx
    	});

    	return block;
    }

    // (587:8) {#if !signedin}
    function create_if_block_4$2(ctx) {
    	let a0;
    	let t0_value = ({ en: "Login", fr: "Se Connecter" })[/*$lang*/ ctx[10]] + "";
    	let t0;
    	let t1;
    	let a1;
    	let t2_value = ({ en: "Register", fr: "S'inscrire" })[/*$lang*/ ctx[10]] + "";
    	let t2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			t0 = text(t0_value);
    			t1 = space();
    			a1 = element("a");
    			t2 = text(t2_value);
    			attr_dev(a0, "href", "/signin");
    			attr_dev(a0, "class", "svelte-1c68a2m");
    			add_location(a0, file$j, 587, 12, 16555);
    			attr_dev(a1, "href", "/signup");
    			attr_dev(a1, "class", "svelte-1c68a2m");
    			add_location(a1, file$j, 592, 12, 16694);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			append_dev(a0, t0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, t2);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 1024 && t0_value !== (t0_value = ({ en: "Login", fr: "Se Connecter" })[/*$lang*/ ctx[10]] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$lang*/ 1024 && t2_value !== (t2_value = ({ en: "Register", fr: "S'inscrire" })[/*$lang*/ ctx[10]] + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(587:8) {#if !signedin}",
    		ctx
    	});

    	return block;
    }

    // (606:36) 
    function create_if_block_3$3(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "/img/misc/uk-circle.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "en");
    			attr_dev(img, "class", "svelte-1c68a2m");
    			add_location(img, file$j, 606, 16, 17166);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*click_handler_4*/ ctx[16], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(606:36) ",
    		ctx
    	});

    	return block;
    }

    // (599:12) {#if $lang == 'fr'}
    function create_if_block_2$3(ctx) {
    	let img;
    	let img_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (img.src !== (img_src_value = "/img/misc/france-circle.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "fr");
    			attr_dev(img, "class", "svelte-1c68a2m");
    			add_location(img, file$j, 599, 16, 16916);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*click_handler_3*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(599:12) {#if $lang == 'fr'}",
    		ctx
    	});

    	return block;
    }

    // (615:8) {#if signedin}
    function create_if_block_1$5(ctx) {
    	let cart;
    	let current;

    	cart = new Cart({
    			props: {
    				color: /*isScroll*/ ctx[6] ? "#ffffff" : "#181d22"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cart.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cart, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cart_changes = {};
    			if (dirty & /*isScroll*/ 64) cart_changes.color = /*isScroll*/ ctx[6] ? "#ffffff" : "#181d22";
    			cart.$set(cart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(615:8) {#if signedin}",
    		ctx
    	});

    	return block;
    }

    // (618:8) {#if !signedin}
    function create_if_block$b(ctx) {
    	let cart;
    	let t0;
    	let div;
    	let a;
    	let t1_value = ({ en: "Creator?", fr: "Createur?" })[/*$lang*/ ctx[10]] + "";
    	let t1;
    	let current;

    	cart = new Cart({
    			props: {
    				color: /*isScroll*/ ctx[6] ? "#ffffff" : "#181d22"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(cart.$$.fragment);
    			t0 = space();
    			div = element("div");
    			a = element("a");
    			t1 = text(t1_value);
    			attr_dev(a, "href", "https://creator.unify.tn");
    			attr_dev(a, "class", "svelte-1c68a2m");
    			add_location(a, file$j, 620, 16, 17647);
    			attr_dev(div, "class", "join_btn svelte-1c68a2m");
    			attr_dev(div, "target", "_blank");
    			add_location(div, file$j, 619, 12, 17591);
    		},
    		m: function mount(target, anchor) {
    			mount_component(cart, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, a);
    			append_dev(a, t1);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const cart_changes = {};
    			if (dirty & /*isScroll*/ 64) cart_changes.color = /*isScroll*/ ctx[6] ? "#ffffff" : "#181d22";
    			cart.$set(cart_changes);
    			if ((!current || dirty & /*$lang*/ 1024) && t1_value !== (t1_value = ({ en: "Creator?", fr: "Createur?" })[/*$lang*/ ctx[10]] + "")) set_data_dev(t1, t1_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cart, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(618:8) {#if !signedin}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div0;
    	let t0;
    	let nav;
    	let a0;
    	let div1;
    	let logo;
    	let t1;
    	let t2;
    	let div3;
    	let a1;
    	let t3_value = ({ en: "Home", fr: "Accueil" })[/*$lang*/ ctx[10]] + "";
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let div2;
    	let t7;
    	let t8;
    	let div3_class_value;
    	let t9;
    	let div4;
    	let t10;
    	let t11;
    	let svg;
    	let path0;
    	let path1;
    	let path2;
    	let nav_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	logo = new UnifyLogo({ $$inline: true });
    	let if_block0 = /*signedin*/ ctx[8] && create_if_block_5$1(ctx);
    	let if_block1 = !/*signedin*/ ctx[8] && create_if_block_4$2(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*$lang*/ ctx[10] == "fr") return create_if_block_2$3;
    		if (/*$lang*/ ctx[10] == "en") return create_if_block_3$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type && current_block_type(ctx);
    	let if_block3 = /*signedin*/ ctx[8] && create_if_block_1$5(ctx);
    	let if_block4 = !/*signedin*/ ctx[8] && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			nav = element("nav");
    			a0 = element("a");
    			div1 = element("div");
    			create_component(logo.$$.fragment);
    			t1 = text("\r\n        Unify");
    			t2 = space();
    			div3 = element("div");
    			a1 = element("a");
    			t3 = text(t3_value);
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			div2 = element("div");
    			if (if_block2) if_block2.c();
    			t7 = space();
    			if (if_block3) if_block3.c();
    			t8 = space();
    			if (if_block4) if_block4.c();
    			t9 = space();
    			div4 = element("div");
    			t10 = text("X");
    			t11 = space();
    			svg = svg_element("svg");
    			path0 = svg_element("path");
    			path1 = svg_element("path");
    			path2 = svg_element("path");
    			attr_dev(div0, "id", "transparent");
    			attr_dev(div0, "class", "svelte-1c68a2m");
    			toggle_class(div0, "myAccount", /*myAccount*/ ctx[3]);
    			add_location(div0, file$j, 521, 0, 13009);
    			attr_dev(div1, "class", "logo_img svelte-1c68a2m");
    			add_location(div1, file$j, 526, 8, 13236);
    			attr_dev(a0, "href", "/");
    			attr_dev(a0, "class", "u_logo svelte-1c68a2m");
    			set_style(a0, "color", /*$downColor*/ ctx[9]);
    			add_location(a0, file$j, 525, 0, 13163);
    			attr_dev(a1, "href", "/");
    			attr_dev(a1, "class", "svelte-1c68a2m");
    			add_location(a1, file$j, 535, 8, 13537);
    			attr_dev(div2, "class", "nav-lang svelte-1c68a2m");
    			add_location(div2, file$j, 597, 8, 16843);

    			attr_dev(div3, "class", div3_class_value = "menuItems " + (window.innerWidth <= 1180
    			? /*isActive*/ ctx[1]
    				? "isActive"
    				: /*isActiveReverse*/ ctx[2] ? "isActiveReverse" : ""
    			: "") + " svelte-1c68a2m");

    			set_style(div3, "background-color", /*mobileMenuColor*/ ctx[4], 1);
    			add_location(div3, file$j, 532, 4, 13330);
    			attr_dev(div4, "class", "closeMobileMenu svelte-1c68a2m");
    			set_style(div4, "color", /*$downColor*/ ctx[9]);
    			toggle_class(div4, "isActive", /*isActive*/ ctx[1]);
    			add_location(div4, file$j, 628, 4, 17851);
    			attr_dev(path0, "d", "m368 154.667969h-352c-8.832031 0-16-7.167969-16-16s7.167969-16\r\n      16-16h352c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0");
    			add_location(path0, file$j, 652, 8, 18389);
    			attr_dev(path1, "d", "m368 32h-352c-8.832031 0-16-7.167969-16-16s7.167969-16\r\n      16-16h352c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0");
    			add_location(path1, file$j, 655, 8, 18557);
    			attr_dev(path2, "d", "m368 277.332031h-352c-8.832031 0-16-7.167969-16-16s7.167969-16\r\n      16-16h352c8.832031 0 16 7.167969 16 16s-7.167969 16-16 16zm0 0");
    			add_location(path2, file$j, 658, 8, 18717);
    			attr_dev(svg, "class", "menuBtn svelte-1c68a2m");
    			set_style(svg, "fill", /*$downColor*/ ctx[9]);
    			attr_dev(svg, "height", "384pt");
    			attr_dev(svg, "viewBox", "0 -53 384 384");
    			attr_dev(svg, "width", "384pt");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			toggle_class(svg, "isActive", /*isActive*/ ctx[1]);
    			add_location(svg, file$j, 640, 4, 18089);
    			attr_dev(nav, "class", nav_class_value = "" + ((/*isScroll*/ ctx[6] ? "isScroll" : "") + " " + (/*isScrollReverse*/ ctx[7] ? "isScrollReverse" : "") + " svelte-1c68a2m"));
    			toggle_class(nav, "isScroll", /*isScroll*/ ctx[6]);
    			add_location(nav, file$j, 522, 0, 13051);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, nav, anchor);
    			append_dev(nav, a0);
    			append_dev(a0, div1);
    			mount_component(logo, div1, null);
    			append_dev(a0, t1);
    			append_dev(nav, t2);
    			append_dev(nav, div3);
    			append_dev(div3, a1);
    			append_dev(a1, t3);
    			append_dev(div3, t4);
    			if (if_block0) if_block0.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t6);
    			append_dev(div3, div2);
    			if (if_block2) if_block2.m(div2, null);
    			append_dev(div3, t7);
    			if (if_block3) if_block3.m(div3, null);
    			append_dev(div3, t8);
    			if (if_block4) if_block4.m(div3, null);
    			append_dev(nav, t9);
    			append_dev(nav, div4);
    			append_dev(div4, t10);
    			append_dev(nav, t11);
    			append_dev(nav, svg);
    			append_dev(svg, path0);
    			append_dev(svg, path1);
    			append_dev(svg, path2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					listen_dev(div4, "click", /*click_handler_5*/ ctx[17], false, false, false),
    					listen_dev(svg, "click", /*click_handler_6*/ ctx[18], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*myAccount*/ 8) {
    				toggle_class(div0, "myAccount", /*myAccount*/ ctx[3]);
    			}

    			if (!current || dirty & /*$downColor*/ 512) {
    				set_style(a0, "color", /*$downColor*/ ctx[9]);
    			}

    			if ((!current || dirty & /*$lang*/ 1024) && t3_value !== (t3_value = ({ en: "Home", fr: "Accueil" })[/*$lang*/ ctx[10]] + "")) set_data_dev(t3, t3_value);

    			if (/*signedin*/ ctx[8]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_5$1(ctx);
    					if_block0.c();
    					if_block0.m(div3, t5);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*signedin*/ ctx[8]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					if_block1.m(div3, t6);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if (if_block2) if_block2.d(1);
    				if_block2 = current_block_type && current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div2, null);
    				}
    			}

    			if (/*signedin*/ ctx[8]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*signedin*/ 256) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$5(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div3, t8);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!/*signedin*/ ctx[8]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*signedin*/ 256) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block$b(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div3, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*isActive, isActiveReverse*/ 6 && div3_class_value !== (div3_class_value = "menuItems " + (window.innerWidth <= 1180
    			? /*isActive*/ ctx[1]
    				? "isActive"
    				: /*isActiveReverse*/ ctx[2] ? "isActiveReverse" : ""
    			: "") + " svelte-1c68a2m")) {
    				attr_dev(div3, "class", div3_class_value);
    			}

    			if (!current || dirty & /*mobileMenuColor*/ 16) {
    				set_style(div3, "background-color", /*mobileMenuColor*/ ctx[4], 1);
    			}

    			if (!current || dirty & /*$downColor*/ 512) {
    				set_style(div4, "color", /*$downColor*/ ctx[9]);
    			}

    			if (dirty & /*isActive*/ 2) {
    				toggle_class(div4, "isActive", /*isActive*/ ctx[1]);
    			}

    			if (!current || dirty & /*$downColor*/ 512) {
    				set_style(svg, "fill", /*$downColor*/ ctx[9]);
    			}

    			if (dirty & /*isActive*/ 2) {
    				toggle_class(svg, "isActive", /*isActive*/ ctx[1]);
    			}

    			if (!current || dirty & /*isScroll, isScrollReverse*/ 192 && nav_class_value !== (nav_class_value = "" + ((/*isScroll*/ ctx[6] ? "isScroll" : "") + " " + (/*isScrollReverse*/ ctx[7] ? "isScrollReverse" : "") + " svelte-1c68a2m"))) {
    				attr_dev(nav, "class", nav_class_value);
    			}

    			if (dirty & /*isScroll, isScrollReverse, isScroll*/ 192) {
    				toggle_class(nav, "isScroll", /*isScroll*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(nav);
    			destroy_component(logo);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();

    			if (if_block2) {
    				if_block2.d();
    			}

    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let signedin;
    	let $user;
    	let $upColor;
    	let $downColor;
    	let $lang;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(0, $user = $$value));
    	validate_store(upColor, "upColor");
    	component_subscribe($$self, upColor, $$value => $$invalidate(19, $upColor = $$value));
    	validate_store(downColor, "downColor");
    	component_subscribe($$self, downColor, $$value => $$invalidate(9, $downColor = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(10, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavbarUnify", slots, []);
    	let isActive = false; // for mobile menu
    	let isActiveReverse = false;
    	let myAccount = false;
    	set_store_value(upColor, $upColor = "#45B877", $upColor);
    	set_store_value(downColor, $downColor = "#181D22", $downColor);
    	let headerVisible = false;
    	let oldscroll = 0;
    	let mobileMenuColor = "#FFFFFF";
    	let popup_myaccount = "#FFFFFF";

    	onMount(async () => {
    		document.getElementById("transparent").addEventListener("click", () => {
    			$$invalidate(3, myAccount = false);
    		});

    		let w = window.innerWidth;

    		if (w > 1180) {
    			$$invalidate(4, mobileMenuColor = "transparent");
    		} else {
    			$$invalidate(4, mobileMenuColor = "#FFFFFF");
    		}
    	});

    	window.addEventListener("resize", () => {
    		if (window.innerWidth > 1180) {
    			$$invalidate(2, isActiveReverse = false);
    			$$invalidate(4, mobileMenuColor = "transparent");
    		} else {
    			let currentScrollPos = window.pageYOffset;

    			if (currentScrollPos <= 150) {
    				$$invalidate(4, mobileMenuColor = "#FFFFFF");
    			}

    			if (currentScrollPos > 180) {
    				$$invalidate(4, mobileMenuColor = "#181D22");
    			}
    		}
    	});

    	/* When the user scrolls down, navbar -> background white */
    	let isScroll = false;

    	let isScrollReverse = false;

    	window.onscroll = () => {
    		let currentScrollPos = window.pageYOffset;
    		let w = window.innerWidth;

    		if (currentScrollPos <= 150) {
    			$$invalidate(6, isScroll = false);
    			$$invalidate(7, isScrollReverse = true);
    			set_store_value(downColor, $downColor = "#181D22", $downColor);
    			$$invalidate(5, popup_myaccount = "#FFFFFF");

    			if (w > 1180) {
    				$$invalidate(4, mobileMenuColor = "transparent");
    			} else {
    				$$invalidate(4, mobileMenuColor = "#FFFFFF");
    			}
    		}

    		if (currentScrollPos > 180) {
    			$$invalidate(6, isScroll = true);
    			$$invalidate(7, isScrollReverse = false);
    			set_store_value(downColor, $downColor = "#FFFFFF", $downColor);
    			$$invalidate(5, popup_myaccount = "#181D22");

    			if (w > 1180) {
    				$$invalidate(4, mobileMenuColor = "transparent");
    			} else {
    				$$invalidate(4, mobileMenuColor = "#181D22");
    			}
    		}
    	};

    	let signoutFunc = () => {
    		firebase.auth().signOut();
    		navigate("/");
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavbarUnify> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		signoutFunc();
    	};

    	const click_handler_1 = () => $$invalidate(3, myAccount = !myAccount);

    	const click_handler_2 = () => {
    		signoutFunc();
    	};

    	const click_handler_3 = () => {
    		set_store_value(lang, $lang = "en", $lang);
    	};

    	const click_handler_4 = () => {
    		set_store_value(lang, $lang = "fr", $lang);
    	};

    	const click_handler_5 = () => {
    		$$invalidate(1, isActive = false);
    		$$invalidate(2, isActiveReverse = true);
    	};

    	const click_handler_6 = () => {
    		$$invalidate(1, isActive = !isActive);
    	};

    	$$self.$capture_state = () => ({
    		lang,
    		Logo: UnifyLogo,
    		upColor,
    		downColor,
    		link,
    		navigate,
    		onMount,
    		user,
    		Cart,
    		convert,
    		isActive,
    		isActiveReverse,
    		myAccount,
    		headerVisible,
    		oldscroll,
    		mobileMenuColor,
    		popup_myaccount,
    		isScroll,
    		isScrollReverse,
    		signoutFunc,
    		signedin,
    		$user,
    		$upColor,
    		$downColor,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
    		if ("isActiveReverse" in $$props) $$invalidate(2, isActiveReverse = $$props.isActiveReverse);
    		if ("myAccount" in $$props) $$invalidate(3, myAccount = $$props.myAccount);
    		if ("headerVisible" in $$props) headerVisible = $$props.headerVisible;
    		if ("oldscroll" in $$props) oldscroll = $$props.oldscroll;
    		if ("mobileMenuColor" in $$props) $$invalidate(4, mobileMenuColor = $$props.mobileMenuColor);
    		if ("popup_myaccount" in $$props) $$invalidate(5, popup_myaccount = $$props.popup_myaccount);
    		if ("isScroll" in $$props) $$invalidate(6, isScroll = $$props.isScroll);
    		if ("isScrollReverse" in $$props) $$invalidate(7, isScrollReverse = $$props.isScrollReverse);
    		if ("signoutFunc" in $$props) $$invalidate(11, signoutFunc = $$props.signoutFunc);
    		if ("signedin" in $$props) $$invalidate(8, signedin = $$props.signedin);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$user*/ 1) {
    			$$invalidate(8, signedin = $user);
    		}
    	};

    	return [
    		$user,
    		isActive,
    		isActiveReverse,
    		myAccount,
    		mobileMenuColor,
    		popup_myaccount,
    		isScroll,
    		isScrollReverse,
    		signedin,
    		$downColor,
    		$lang,
    		signoutFunc,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6
    	];
    }

    class NavbarUnify extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarUnify",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* src\components\NavbarCheckout.svelte generated by Svelte v3.32.3 */
    const file$k = "src\\components\\NavbarCheckout.svelte";

    function create_fragment$p(ctx) {
    	let nav;
    	let a;
    	let div0;
    	let logo;
    	let t0;
    	let t1;
    	let div2;
    	let img0;
    	let img0_src_value;
    	let t2;
    	let div1;
    	let t4;
    	let div4;
    	let img1;
    	let img1_src_value;
    	let t5;
    	let div3;
    	let current;
    	let mounted;
    	let dispose;

    	logo = new UnifyLogo({
    			props: { upColor, downColor },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			a = element("a");
    			div0 = element("div");
    			create_component(logo.$$.fragment);
    			t0 = text("\r\n        Unify");
    			t1 = space();
    			div2 = element("div");
    			img0 = element("img");
    			t2 = space();
    			div1 = element("div");
    			div1.textContent = "Besoin d'aide pour passer une commande? Appelez nous au: 31 320 903";
    			t4 = space();
    			div4 = element("div");
    			img1 = element("img");
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "Paiement Sécurisé";
    			attr_dev(div0, "class", "logo_img svelte-1r9b2ul");
    			add_location(div0, file$k, 76, 8, 1684);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "u_logo svelte-1r9b2ul");
    			add_location(a, file$k, 75, 4, 1638);
    			if (img0.src !== (img0_src_value = "./img/misc/call.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "call");
    			attr_dev(img0, "class", "svelte-1r9b2ul");
    			add_location(img0, file$k, 83, 8, 1827);
    			attr_dev(div1, "class", "help_text");
    			add_location(div1, file$k, 84, 8, 1881);
    			attr_dev(div2, "class", "help svelte-1r9b2ul");
    			add_location(div2, file$k, 82, 4, 1799);
    			if (img1.src !== (img1_src_value = "./img/misc/secure.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "call");
    			attr_dev(img1, "class", "svelte-1r9b2ul");
    			add_location(img1, file$k, 90, 8, 2052);
    			attr_dev(div3, "class", "payment_text svelte-1r9b2ul");
    			add_location(div3, file$k, 91, 8, 2108);
    			attr_dev(div4, "class", "payment svelte-1r9b2ul");
    			add_location(div4, file$k, 89, 4, 2021);
    			attr_dev(nav, "class", "svelte-1r9b2ul");
    			add_location(nav, file$k, 74, 0, 1627);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, a);
    			append_dev(a, div0);
    			mount_component(logo, div0, null);
    			append_dev(a, t0);
    			append_dev(nav, t1);
    			append_dev(nav, div2);
    			append_dev(div2, img0);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(nav, t4);
    			append_dev(nav, div4);
    			append_dev(div4, img1);
    			append_dev(div4, t5);
    			append_dev(div4, div3);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(logo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(logo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(logo);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let $upColor;
    	let $downColor;
    	validate_store(upColor, "upColor");
    	component_subscribe($$self, upColor, $$value => $$invalidate(0, $upColor = $$value));
    	validate_store(downColor, "downColor");
    	component_subscribe($$self, downColor, $$value => $$invalidate(1, $downColor = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavbarCheckout", slots, []);
    	set_store_value(upColor, $upColor = "#45B877", $upColor);
    	set_store_value(downColor, $downColor = "#181D22", $downColor);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavbarCheckout> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Logo: UnifyLogo,
    		link,
    		onMount,
    		upColor,
    		downColor,
    		$upColor,
    		$downColor
    	});

    	return [];
    }

    class NavbarCheckout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavbarCheckout",
    			options,
    			id: create_fragment$p.name
    		});
    	}
    }

    /* src\components\CartPage\Cart.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$7, console: console_1$6 } = globals;
    const file$l = "src\\components\\CartPage\\Cart.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[26] = list[i][0];
    	child_ctx[27] = list[i][1];
    	child_ctx[28] = list;
    	child_ctx[29] = i;
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[33] = list[i];
    	return child_ctx;
    }

    // (144:0) {#if loaded}
    function create_if_block$c(ctx) {
    	let div;
    	let span0;
    	let t0;
    	let t1_value = Object.keys(/*$cart*/ ctx[4].items).length + "";
    	let t1;
    	let t2;
    	let t3;
    	let span1;
    	let t5;
    	let t6;
    	let if_block0 = /*noSize*/ ctx[3] && create_if_block_7(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*cartItems*/ ctx[1] != 0) return create_if_block_1$6;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block1 = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span0 = element("span");
    			t0 = text("Shopping cart (");
    			t1 = text(t1_value);
    			t2 = text(" Articles)");
    			t3 = space();
    			span1 = element("span");
    			span1.textContent = "Free Delivery";
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			if_block1.c();
    			attr_dev(span0, "class", "title svelte-1d6tj6m");
    			add_location(span0, file$l, 145, 8, 4165);
    			attr_dev(span1, "class", "sub_title svelte-1d6tj6m");
    			add_location(span1, file$l, 148, 8, 4284);
    			attr_dev(div, "class", "container svelte-1d6tj6m");
    			add_location(div, file$l, 144, 4, 4132);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			append_dev(span0, t2);
    			append_dev(div, t3);
    			append_dev(div, span1);
    			append_dev(div, t5);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t6);
    			if_block1.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*$cart*/ 16 && t1_value !== (t1_value = Object.keys(/*$cart*/ ctx[4].items).length + "")) set_data_dev(t1, t1_value);

    			if (/*noSize*/ ctx[3]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					if_block0.m(div, t6);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
    				if_block1.p(ctx, dirty);
    			} else {
    				if_block1.d(1);
    				if_block1 = current_block_type(ctx);

    				if (if_block1) {
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(144:0) {#if loaded}",
    		ctx
    	});

    	return block;
    }

    // (150:8) {#if noSize}
    function create_if_block_7(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Please select size(s) for your article(s)";
    			attr_dev(div, "class", "size-error svelte-1d6tj6m");
    			add_location(div, file$l, 150, 12, 4364);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(150:8) {#if noSize}",
    		ctx
    	});

    	return block;
    }

    // (365:8) {:else}
    function create_else_block$8(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Your cart is empty!";
    			attr_dev(div, "class", "emptyCart svelte-1d6tj6m");
    			add_location(div, file$l, 365, 8, 15080);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(365:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (153:8) {#if cartItems !=0}
    function create_if_block_1$6(ctx) {
    	let div0;
    	let span0;
    	let t1;
    	let span1;
    	let t3;
    	let span2;
    	let t5;
    	let span3;
    	let t7;
    	let hr0;
    	let t8;
    	let t9;
    	let t10;
    	let div3;
    	let div1;
    	let span4;
    	let t12;
    	let span5;
    	let t14;
    	let t15;
    	let div2;
    	let span6;
    	let t16;
    	let t17;
    	let t18;
    	let span7;
    	let t20;
    	let t21;
    	let hr1;
    	let t22;
    	let span8;
    	let t23;
    	let t24;
    	let t25;
    	let t26;
    	let div4;
    	let t27;
    	let a;
    	let mounted;
    	let dispose;
    	let each_value = Object.entries(/*$cart*/ ctx[4].items);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			span0 = element("span");
    			span0.textContent = "Article";
    			t1 = space();
    			span1 = element("span");
    			span1.textContent = "Quantity";
    			t3 = space();
    			span2 = element("span");
    			span2.textContent = "Unit Price";
    			t5 = space();
    			span3 = element("span");
    			span3.textContent = "Total price";
    			t7 = space();
    			hr0 = element("hr");
    			t8 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			t10 = space();
    			div3 = element("div");
    			div1 = element("div");
    			span4 = element("span");
    			span4.textContent = "Subtotal";
    			t12 = space();
    			span5 = element("span");
    			span5.textContent = "Shipping";
    			t14 = space();
    			t15 = space();
    			div2 = element("div");
    			span6 = element("span");
    			t16 = text(/*normalTotal*/ ctx[2]);
    			t17 = text(" DT");
    			t18 = space();
    			span7 = element("span");
    			span7.textContent = "Free";
    			t20 = space();
    			t21 = space();
    			hr1 = element("hr");
    			t22 = space();
    			span8 = element("span");
    			t23 = text("Total: ");
    			t24 = text(/*normalTotal*/ ctx[2]);
    			t25 = text(" DT");
    			t26 = space();
    			div4 = element("div");
    			t27 = space();
    			a = element("a");
    			a.textContent = "Finalize Your Order";
    			attr_dev(span0, "class", "article_title desktop_items svelte-1d6tj6m");
    			add_location(span0, file$l, 154, 12, 4533);
    			attr_dev(span1, "class", "quantity_title desktop_items svelte-1d6tj6m");
    			add_location(span1, file$l, 155, 12, 4603);
    			attr_dev(span2, "class", "unit_price_title desktop_items svelte-1d6tj6m");
    			add_location(span2, file$l, 156, 12, 4675);
    			attr_dev(span3, "class", "total_price_title desktop_items svelte-1d6tj6m");
    			add_location(span3, file$l, 157, 12, 4751);
    			attr_dev(hr0, "class", "svelte-1d6tj6m");
    			add_location(hr0, file$l, 159, 12, 4831);
    			attr_dev(div0, "class", "orders_container svelte-1d6tj6m");
    			add_location(div0, file$l, 153, 8, 4489);
    			attr_dev(span4, "class", "subtotal svelte-1d6tj6m");
    			add_location(span4, file$l, 343, 16, 14116);
    			attr_dev(span5, "class", "shipping svelte-1d6tj6m");
    			add_location(span5, file$l, 344, 16, 14172);
    			attr_dev(div1, "class", "titles svelte-1d6tj6m");
    			add_location(div1, file$l, 342, 12, 14078);
    			attr_dev(span6, "class", "subtotal svelte-1d6tj6m");
    			add_location(span6, file$l, 352, 16, 14500);
    			attr_dev(span7, "class", "shipping svelte-1d6tj6m");
    			add_location(span7, file$l, 353, 16, 14564);
    			attr_dev(div2, "class", "prices svelte-1d6tj6m");
    			add_location(div2, file$l, 351, 12, 14462);
    			attr_dev(div3, "class", "final_total svelte-1d6tj6m");
    			add_location(div3, file$l, 341, 8, 14039);
    			attr_dev(hr1, "class", "svelte-1d6tj6m");
    			add_location(hr1, file$l, 357, 8, 14726);
    			attr_dev(span8, "class", "total svelte-1d6tj6m");
    			add_location(span8, file$l, 358, 8, 14742);
    			attr_dev(a, "href", "/checkout");
    			attr_dev(a, "class", "finilize svelte-1d6tj6m");
    			add_location(a, file$l, 362, 12, 14930);
    			attr_dev(div4, "class", "continue_finilize svelte-1d6tj6m");
    			add_location(div4, file$l, 360, 8, 14804);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(div0, t3);
    			append_dev(div0, span2);
    			append_dev(div0, t5);
    			append_dev(div0, span3);
    			append_dev(div0, t7);
    			append_dev(div0, hr0);
    			append_dev(div0, t8);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			insert_dev(target, t9, anchor);
    			insert_dev(target, t10, anchor);
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div1);
    			append_dev(div1, span4);
    			append_dev(div1, t12);
    			append_dev(div1, span5);
    			append_dev(div1, t14);
    			append_dev(div3, t15);
    			append_dev(div3, div2);
    			append_dev(div2, span6);
    			append_dev(span6, t16);
    			append_dev(span6, t17);
    			append_dev(div2, t18);
    			append_dev(div2, span7);
    			append_dev(div2, t20);
    			insert_dev(target, t21, anchor);
    			insert_dev(target, hr1, anchor);
    			insert_dev(target, t22, anchor);
    			insert_dev(target, span8, anchor);
    			append_dev(span8, t23);
    			append_dev(span8, t24);
    			append_dev(span8, t25);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, div4, anchor);
    			append_dev(div4, t27);
    			append_dev(div4, a);

    			if (!mounted) {
    				dispose = listen_dev(a, "click", prevent_default(/*verifyBeforeFinalize*/ ctx[10]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*removeItem, $cart, $user, addWishlist, updateQuantity, handleChangeSize, updateColor*/ 3056) {
    				each_value = Object.entries(/*$cart*/ ctx[4].items);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*normalTotal*/ 4) set_data_dev(t16, /*normalTotal*/ ctx[2]);
    			if (dirty[0] & /*normalTotal*/ 4) set_data_dev(t24, /*normalTotal*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t9);
    			if (detaching) detach_dev(t10);
    			if (detaching) detach_dev(div3);
    			if (detaching) detach_dev(t21);
    			if (detaching) detach_dev(hr1);
    			if (detaching) detach_dev(t22);
    			if (detaching) detach_dev(span8);
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(153:8) {#if cartItems !=0}",
    		ctx
    	});

    	return block;
    }

    // (181:32) {#each value.colors as col}
    function create_each_block_2$2(ctx) {
    	let div;
    	let div_style_value;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[12](/*key*/ ctx[26], /*col*/ ctx[33]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "style", div_style_value = "background-color:" + textToHex(/*col*/ ctx[33]) + ";");
    			attr_dev(div, "class", "shape svelte-1d6tj6m");
    			toggle_class(div, "active", /*col*/ ctx[33] == /*value*/ ctx[27].color);
    			add_location(div, file$l, 181, 36, 6001);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$cart*/ 16 && div_style_value !== (div_style_value = "background-color:" + textToHex(/*col*/ ctx[33]) + ";")) {
    				attr_dev(div, "style", div_style_value);
    			}

    			if (dirty[0] & /*$cart*/ 16) {
    				toggle_class(div, "active", /*col*/ ctx[33] == /*value*/ ctx[27].color);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(181:32) {#each value.colors as col}",
    		ctx
    	});

    	return block;
    }

    // (196:36) {#each ["S", "M", "L", "XL"] as size}
    function create_each_block_1$4(ctx) {
    	let label;
    	let div;
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[13](/*key*/ ctx[26], /*size*/ ctx[30], ...args);
    	}

    	const block = {
    		c: function create() {
    			label = element("label");
    			div = element("div");
    			t0 = text(/*size*/ ctx[30]);
    			t1 = space();
    			attr_dev(div, "class", "svelte-1d6tj6m");
    			toggle_class(div, "checked", /*value*/ ctx[27].size == /*size*/ ctx[30]);
    			add_location(div, file$l, 198, 44, 6945);
    			attr_dev(label, "class", "size_label svelte-1d6tj6m");
    			attr_dev(label, "for", /*size*/ ctx[30]);
    			add_location(label, file$l, 196, 40, 6816);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, label, anchor);
    			append_dev(label, div);
    			append_dev(div, t0);
    			append_dev(label, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$cart*/ 16) {
    				toggle_class(div, "checked", /*value*/ ctx[27].size == /*size*/ ctx[30]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(label);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(196:36) {#each [\\\"S\\\", \\\"M\\\", \\\"L\\\", \\\"XL\\\"] as size}",
    		ctx
    	});

    	return block;
    }

    // (161:12) {#each Object.entries($cart.items) as [key, value]}
    function create_each_block$8(ctx) {
    	let div26;
    	let div16;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let div15;
    	let div1;
    	let a0;
    	let t1_value = /*value*/ ctx[27].name + "";
    	let t1;
    	let a0_href_value;
    	let t2;
    	let span;
    	let t3;
    	let a1;
    	let t4_value = /*value*/ ctx[27].creator + "";
    	let t4;
    	let a1_href_value;
    	let t5;
    	let div2;
    	let t6;
    	let t7;
    	let div4;
    	let t8;
    	let div3;
    	let t9;
    	let div14;
    	let div8;
    	let t10;
    	let div7;
    	let div5;
    	let t12;
    	let input0;
    	let input0_value_value;
    	let t13;
    	let div6;
    	let t15;
    	let div10;
    	let t16;
    	let div9;
    	let t17_value = /*value*/ ctx[27].price + "";
    	let t17;
    	let t18;
    	let t19;
    	let div12;
    	let t20;
    	let div11;

    	let t21_value = /*value*/ ctx[27].price * (/*value*/ ctx[27].quantity
    	? /*value*/ ctx[27].quantity
    	: 1) + "";

    	let t21;
    	let t22;
    	let t23;
    	let div13;
    	let img1;
    	let img1_src_value;
    	let t24;
    	let img2;
    	let img2_src_value;
    	let t25;
    	let div20;
    	let div19;
    	let div17;
    	let t27;
    	let input1;
    	let input1_value_value;
    	let t28;
    	let div18;
    	let t30;
    	let div22;
    	let div21;
    	let t31_value = /*value*/ ctx[27].price + "";
    	let t31;
    	let t32;
    	let t33;
    	let t34;
    	let div25;
    	let div23;

    	let t35_value = /*value*/ ctx[27].price * (/*value*/ ctx[27].quantity
    	? /*value*/ ctx[27].quantity
    	: 1) + "";

    	let t35;
    	let t36;
    	let t37;
    	let div24;
    	let img3;
    	let img3_src_value;
    	let t38;
    	let i;
    	let t39;
    	let hr;
    	let mounted;
    	let dispose;
    	let each_value_2 = /*value*/ ctx[27].colors;
    	validate_each_argument(each_value_2);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_1[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
    	}

    	let each_value_1 = ["S", "M", "L", "XL"];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < 4; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[14](/*value*/ ctx[27], /*each_value*/ ctx[28], /*each_index*/ ctx[29]);
    	}

    	function change_handler(...args) {
    		return /*change_handler*/ ctx[15](/*key*/ ctx[26], ...args);
    	}

    	function click_handler_3() {
    		return /*click_handler_3*/ ctx[16](/*value*/ ctx[27], /*each_value*/ ctx[28], /*each_index*/ ctx[29]);
    	}

    	function click_handler_4() {
    		return /*click_handler_4*/ ctx[17](/*key*/ ctx[26]);
    	}

    	function click_handler_5() {
    		return /*click_handler_5*/ ctx[18](/*value*/ ctx[27], /*each_value*/ ctx[28], /*each_index*/ ctx[29]);
    	}

    	function change_handler_1(...args) {
    		return /*change_handler_1*/ ctx[19](/*key*/ ctx[26], ...args);
    	}

    	function click_handler_6() {
    		return /*click_handler_6*/ ctx[20](/*value*/ ctx[27], /*each_value*/ ctx[28], /*each_index*/ ctx[29]);
    	}

    	function click_handler_7() {
    		return /*click_handler_7*/ ctx[21](/*key*/ ctx[26]);
    	}

    	const block = {
    		c: function create() {
    			div26 = element("div");
    			div16 = element("div");
    			div0 = element("div");
    			img0 = element("img");
    			t0 = space();
    			div15 = element("div");
    			div1 = element("div");
    			a0 = element("a");
    			t1 = text(t1_value);
    			t2 = space();
    			span = element("span");
    			t3 = text("from ");
    			a1 = element("a");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			t6 = text("Color:\r\n                                ");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t7 = space();
    			div4 = element("div");
    			t8 = text("Size:\r\n                                ");
    			div3 = element("div");

    			for (let i = 0; i < 4; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			div14 = element("div");
    			div8 = element("div");
    			t10 = text("Quantity:\r\n                                    ");
    			div7 = element("div");
    			div5 = element("div");
    			div5.textContent = "-";
    			t12 = space();
    			input0 = element("input");
    			t13 = space();
    			div6 = element("div");
    			div6.textContent = "+";
    			t15 = space();
    			div10 = element("div");
    			t16 = text("Unit Price:\r\n                                    ");
    			div9 = element("div");
    			t17 = text(t17_value);
    			t18 = text("TND");
    			t19 = space();
    			div12 = element("div");
    			t20 = text("Total Price:\r\n                                    ");
    			div11 = element("div");
    			t21 = text(t21_value);
    			t22 = text(" TND");
    			t23 = space();
    			div13 = element("div");
    			img1 = element("img");
    			t24 = space();
    			img2 = element("img");
    			t25 = space();
    			div20 = element("div");
    			div19 = element("div");
    			div17 = element("div");
    			div17.textContent = "-";
    			t27 = space();
    			input1 = element("input");
    			t28 = space();
    			div18 = element("div");
    			div18.textContent = "+";
    			t30 = space();
    			div22 = element("div");
    			div21 = element("div");
    			t31 = text(t31_value);
    			t32 = text(" TND");
    			t33 = space();
    			t34 = space();
    			div25 = element("div");
    			div23 = element("div");
    			t35 = text(t35_value);
    			t36 = text(" TND");
    			t37 = space();
    			div24 = element("div");
    			img3 = element("img");
    			t38 = space();
    			i = element("i");
    			t39 = space();
    			hr = element("hr");
    			attr_dev(img0, "crossorigin", "anonymous");
    			if (img0.src !== (img0_src_value = /*value*/ ctx[27].imgs[/*value*/ ctx[27].color][/*value*/ ctx[27].featuredFace])) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "order");
    			attr_dev(img0, "class", "svelte-1d6tj6m");
    			add_location(img0, file$l, 165, 28, 5101);
    			attr_dev(div0, "class", "p_img svelte-1d6tj6m");
    			add_location(div0, file$l, 164, 24, 5052);
    			attr_dev(a0, "href", a0_href_value = "/" + /*value*/ ctx[27].creator + "/merch/" + /*value*/ ctx[27].id);
    			attr_dev(a0, "class", "title svelte-1d6tj6m");
    			add_location(a0, file$l, 173, 32, 5483);
    			attr_dev(a1, "href", a1_href_value = "/" + /*value*/ ctx[27].creator);
    			add_location(a1, file$l, 175, 42, 5676);
    			attr_dev(span, "class", "sub_title svelte-1d6tj6m");
    			add_location(span, file$l, 174, 32, 5609);
    			attr_dev(div1, "class", "p_title svelte-1d6tj6m");
    			add_location(div1, file$l, 172, 28, 5428);
    			attr_dev(div2, "class", "color svelte-1d6tj6m");
    			add_location(div2, file$l, 178, 28, 5843);
    			attr_dev(div3, "class", "radio_btns svelte-1d6tj6m");
    			add_location(div3, file$l, 194, 32, 6675);
    			attr_dev(div4, "class", "size svelte-1d6tj6m");
    			add_location(div4, file$l, 192, 28, 6584);
    			attr_dev(div5, "class", "minus svelte-1d6tj6m");
    			add_location(div5, file$l, 212, 40, 7732);
    			input0.disabled = true;
    			attr_dev(input0, "class", "qty svelte-1d6tj6m");

    			input0.value = input0_value_value = /*value*/ ctx[27].quantity
    			? /*value*/ ctx[27].quantity
    			: 1;

    			add_location(input0, file$l, 222, 40, 8374);
    			attr_dev(div6, "class", "plus svelte-1d6tj6m");
    			add_location(div6, file$l, 232, 40, 8950);
    			attr_dev(div7, "class", "qty_btn svelte-1d6tj6m");
    			add_location(div7, file$l, 211, 36, 7669);
    			attr_dev(div8, "class", "quantity_mobile svelte-1d6tj6m");
    			add_location(div8, file$l, 209, 32, 7555);
    			attr_dev(div9, "class", "price_mobile svelte-1d6tj6m");
    			add_location(div9, file$l, 243, 36, 9532);
    			attr_dev(div10, "class", "unit_price_mobile svelte-1d6tj6m");
    			add_location(div10, file$l, 241, 32, 9414);
    			attr_dev(div11, "class", "price_mobile svelte-1d6tj6m");
    			add_location(div11, file$l, 250, 36, 9856);
    			attr_dev(div12, "class", "total_price_mobile svelte-1d6tj6m");
    			add_location(div12, file$l, 248, 32, 9736);
    			if (img1.src !== (img1_src_value = "img/misc/heart.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "heart");
    			attr_dev(img1, "class", "svelte-1d6tj6m");
    			add_location(img1, file$l, 259, 36, 10307);
    			if (img2.src !== (img2_src_value = "img/misc/delete.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "delete");
    			attr_dev(img2, "class", "svelte-1d6tj6m");
    			add_location(img2, file$l, 262, 36, 10519);
    			attr_dev(div13, "class", "btns_mobile svelte-1d6tj6m");
    			add_location(div13, file$l, 258, 32, 10244);
    			attr_dev(div14, "class", "mobile_items svelte-1d6tj6m");
    			add_location(div14, file$l, 208, 28, 7495);
    			attr_dev(div15, "class", "info svelte-1d6tj6m");
    			add_location(div15, file$l, 171, 24, 5380);
    			attr_dev(div16, "class", "article svelte-1d6tj6m");
    			add_location(div16, file$l, 163, 20, 5005);
    			attr_dev(div17, "class", "minus svelte-1d6tj6m");
    			add_location(div17, file$l, 275, 28, 11070);
    			input1.disabled = true;
    			attr_dev(input1, "class", "qty svelte-1d6tj6m");

    			input1.value = input1_value_value = /*value*/ ctx[27].quantity
    			? /*value*/ ctx[27].quantity
    			: 1;

    			add_location(input1, file$l, 285, 28, 11533);
    			attr_dev(div18, "class", "plus svelte-1d6tj6m");
    			add_location(div18, file$l, 293, 28, 11915);
    			attr_dev(div19, "class", "qty_btn svelte-1d6tj6m");
    			add_location(div19, file$l, 274, 24, 11019);
    			attr_dev(div20, "class", "quantity desktop_items svelte-1d6tj6m");
    			add_location(div20, file$l, 273, 20, 10957);
    			attr_dev(div21, "class", "price");
    			add_location(div21, file$l, 303, 24, 12382);
    			attr_dev(div22, "class", "unit_price desktop_items svelte-1d6tj6m");
    			add_location(div22, file$l, 302, 20, 12318);
    			attr_dev(div23, "class", "price");
    			add_location(div23, file$l, 311, 24, 12780);
    			attr_dev(img3, "class", "heart-img svelte-1d6tj6m");

    			if (img3.src !== (img3_src_value = /*$user*/ ctx[5] && /*$user*/ ctx[5].docData && /*$user*/ ctx[5].docData.wishlist && /*$user*/ ctx[5].docData?.wishlist[/*value*/ ctx[27].creator + "-" + /*value*/ ctx[27].id]
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/heart.png")) attr_dev(img3, "src", img3_src_value);

    			attr_dev(img3, "alt", "eart");
    			add_location(img3, file$l, 316, 28, 13025);
    			attr_dev(i, "class", "fas fa-minus svelte-1d6tj6m");
    			add_location(i, file$l, 319, 28, 13373);
    			attr_dev(div24, "class", "btns svelte-1d6tj6m");
    			add_location(div24, file$l, 315, 24, 12977);
    			attr_dev(div25, "class", "total_price desktop_items svelte-1d6tj6m");
    			add_location(div25, file$l, 310, 20, 12715);
    			attr_dev(div26, "class", "single_order svelte-1d6tj6m");
    			add_location(div26, file$l, 161, 16, 4920);
    			attr_dev(hr, "class", "svelte-1d6tj6m");
    			add_location(hr, file$l, 325, 16, 13575);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div26, anchor);
    			append_dev(div26, div16);
    			append_dev(div16, div0);
    			append_dev(div0, img0);
    			append_dev(div16, t0);
    			append_dev(div16, div15);
    			append_dev(div15, div1);
    			append_dev(div1, a0);
    			append_dev(a0, t1);
    			append_dev(div1, t2);
    			append_dev(div1, span);
    			append_dev(span, t3);
    			append_dev(span, a1);
    			append_dev(a1, t4);
    			append_dev(div15, t5);
    			append_dev(div15, div2);
    			append_dev(div2, t6);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(div2, null);
    			}

    			append_dev(div15, t7);
    			append_dev(div15, div4);
    			append_dev(div4, t8);
    			append_dev(div4, div3);

    			for (let i = 0; i < 4; i += 1) {
    				each_blocks[i].m(div3, null);
    			}

    			append_dev(div15, t9);
    			append_dev(div15, div14);
    			append_dev(div14, div8);
    			append_dev(div8, t10);
    			append_dev(div8, div7);
    			append_dev(div7, div5);
    			append_dev(div7, t12);
    			append_dev(div7, input0);
    			append_dev(div7, t13);
    			append_dev(div7, div6);
    			append_dev(div14, t15);
    			append_dev(div14, div10);
    			append_dev(div10, t16);
    			append_dev(div10, div9);
    			append_dev(div9, t17);
    			append_dev(div9, t18);
    			append_dev(div14, t19);
    			append_dev(div14, div12);
    			append_dev(div12, t20);
    			append_dev(div12, div11);
    			append_dev(div11, t21);
    			append_dev(div11, t22);
    			append_dev(div14, t23);
    			append_dev(div14, div13);
    			append_dev(div13, img1);
    			append_dev(div13, t24);
    			append_dev(div13, img2);
    			append_dev(div26, t25);
    			append_dev(div26, div20);
    			append_dev(div20, div19);
    			append_dev(div19, div17);
    			append_dev(div19, t27);
    			append_dev(div19, input1);
    			append_dev(div19, t28);
    			append_dev(div19, div18);
    			append_dev(div26, t30);
    			append_dev(div26, div22);
    			append_dev(div22, div21);
    			append_dev(div21, t31);
    			append_dev(div21, t32);
    			append_dev(div22, t33);
    			append_dev(div26, t34);
    			append_dev(div26, div25);
    			append_dev(div25, div23);
    			append_dev(div23, t35);
    			append_dev(div23, t36);
    			append_dev(div25, t37);
    			append_dev(div25, div24);
    			append_dev(div24, img3);
    			append_dev(div24, t38);
    			append_dev(div24, i);
    			insert_dev(target, t39, anchor);
    			insert_dev(target, hr, anchor);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					listen_dev(div5, "click", click_handler_2, false, false, false),
    					listen_dev(input0, "change", change_handler, false, false, false),
    					listen_dev(div6, "click", click_handler_3, false, false, false),
    					listen_dev(
    						img1,
    						"click",
    						function () {
    							if (is_function(/*addWishlist*/ ctx[11](/*value*/ ctx[27].creator + "-" + /*value*/ ctx[27].id))) /*addWishlist*/ ctx[11](/*value*/ ctx[27].creator + "-" + /*value*/ ctx[27].id).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(img2, "click", click_handler_4, false, false, false),
    					listen_dev(div17, "click", click_handler_5, false, false, false),
    					listen_dev(input1, "change", change_handler_1, false, false, false),
    					listen_dev(div18, "click", click_handler_6, false, false, false),
    					listen_dev(
    						img3,
    						"click",
    						function () {
    							if (is_function(/*addWishlist*/ ctx[11](/*value*/ ctx[27].creator + "-" + /*value*/ ctx[27].id))) /*addWishlist*/ ctx[11](/*value*/ ctx[27].creator + "-" + /*value*/ ctx[27].id).apply(this, arguments);
    						},
    						false,
    						false,
    						false
    					),
    					listen_dev(i, "click", click_handler_7, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty[0] & /*$cart*/ 16 && img0.src !== (img0_src_value = /*value*/ ctx[27].imgs[/*value*/ ctx[27].color][/*value*/ ctx[27].featuredFace])) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty[0] & /*$cart*/ 16 && t1_value !== (t1_value = /*value*/ ctx[27].name + "")) set_data_dev(t1, t1_value);

    			if (dirty[0] & /*$cart*/ 16 && a0_href_value !== (a0_href_value = "/" + /*value*/ ctx[27].creator + "/merch/" + /*value*/ ctx[27].id)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty[0] & /*$cart*/ 16 && t4_value !== (t4_value = /*value*/ ctx[27].creator + "")) set_data_dev(t4, t4_value);

    			if (dirty[0] & /*$cart*/ 16 && a1_href_value !== (a1_href_value = "/" + /*value*/ ctx[27].creator)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty[0] & /*$cart, updateColor*/ 272) {
    				each_value_2 = /*value*/ ctx[27].colors;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_2$2(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(div2, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_2.length;
    			}

    			if (dirty[0] & /*$cart, handleChangeSize*/ 80) {
    				each_value_1 = ["S", "M", "L", "XL"];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < 4; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < 4; i += 1) {
    					each_blocks[i].d(1);
    				}
    			}

    			if (dirty[0] & /*$cart*/ 16 && input0_value_value !== (input0_value_value = /*value*/ ctx[27].quantity
    			? /*value*/ ctx[27].quantity
    			: 1) && input0.value !== input0_value_value) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if (dirty[0] & /*$cart*/ 16 && t17_value !== (t17_value = /*value*/ ctx[27].price + "")) set_data_dev(t17, t17_value);

    			if (dirty[0] & /*$cart*/ 16 && t21_value !== (t21_value = /*value*/ ctx[27].price * (/*value*/ ctx[27].quantity
    			? /*value*/ ctx[27].quantity
    			: 1) + "")) set_data_dev(t21, t21_value);

    			if (dirty[0] & /*$cart*/ 16 && input1_value_value !== (input1_value_value = /*value*/ ctx[27].quantity
    			? /*value*/ ctx[27].quantity
    			: 1) && input1.value !== input1_value_value) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if (dirty[0] & /*$cart*/ 16 && t31_value !== (t31_value = /*value*/ ctx[27].price + "")) set_data_dev(t31, t31_value);

    			if (dirty[0] & /*$cart*/ 16 && t35_value !== (t35_value = /*value*/ ctx[27].price * (/*value*/ ctx[27].quantity
    			? /*value*/ ctx[27].quantity
    			: 1) + "")) set_data_dev(t35, t35_value);

    			if (dirty[0] & /*$user, $cart*/ 48 && img3.src !== (img3_src_value = /*$user*/ ctx[5] && /*$user*/ ctx[5].docData && /*$user*/ ctx[5].docData.wishlist && /*$user*/ ctx[5].docData?.wishlist[/*value*/ ctx[27].creator + "-" + /*value*/ ctx[27].id]
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/heart.png")) {
    				attr_dev(img3, "src", img3_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div26);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t39);
    			if (detaching) detach_dev(hr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(161:12) {#each Object.entries($cart.items) as [key, value]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let if_block_anchor;
    	let if_block = /*loaded*/ ctx[0] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*loaded*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $cart;
    	let $user;
    	validate_store(cart, "cart");
    	component_subscribe($$self, cart, $$value => $$invalidate(4, $cart = $$value));
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(5, $user = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Cart", slots, []);
    	let quantity = 1;
    	let loaded = false;

    	let unsubscribeCart = () => {
    		
    	};

    	let cartItems = 0;

    	onMount(() => {
    		document.title = "Unify - Cart";
    		$$invalidate(1, cartItems = Object.keys($cart.items).length);

    		/* if (Object.keys($cart.items).length == 0) {
        navigate("/");
    } */
    		$$invalidate(0, loaded = true);

    		let params = new URLSearchParams(location.search);

    		if (params.get("error") == "sizes") {
    			$$invalidate(3, noSize = true);
    			window.scrollTo({ top: 0, behavior: "smooth" });
    		}

    		window.scrollTo({ top: 0, behavior: "smooth" });
    	});

    	const handleChangeSize = (key, fsize) => {
    		console.log(key);
    		console.log(fsize);

    		set_store_value(
    			cart,
    			$cart = {
    				...$cart,
    				items: {
    					...$cart.items,
    					[key]: { ...$cart.items[key], size: fsize }
    				}
    			},
    			$cart
    		);

    		console.log($cart);
    	};

    	const updateQuantity = (key, e) => {
    		set_store_value(
    			cart,
    			$cart = {
    				...$cart,
    				items: {
    					...$cart.items,
    					[key]: {
    						...$cart.items[key],
    						quantity: e.target.value
    					}
    				}
    			},
    			$cart
    		);
    	};

    	const updateColor = (key, col) => {
    		set_store_value(
    			cart,
    			$cart = {
    				...$cart,
    				items: {
    					...$cart.items,
    					[key]: { ...$cart.items[key], color: col }
    				}
    			},
    			$cart
    		);
    	};

    	const isSelected = () => {
    		return;
    	};

    	const calculateTotal = () => {
    		
    	};

    	let normalTotal = 0;

    	unsubscribeCart = cart.subscribe(data => {
    		$$invalidate(2, normalTotal = Object.entries(data.items).reduce(
    			(acc, [key, value]) => {
    				acc += value.price * (value.quantity ? value.quantity : 1);
    				return acc;
    			},
    			0
    		));
    	});

    	const removeItem = key => {
    		cart.remove(key);
    	};

    	let noSize = false;

    	const verifyBeforeFinalize = () => {
    		$$invalidate(3, noSize = false);

    		Object.entries($cart.items).forEach(([key, item]) => {
    			console.log(item);

    			if (item.size == undefined) {
    				$$invalidate(3, noSize = true);
    				window.scrollTo({ top: 0, behavior: "smooth" });
    			}
    		});

    		if (noSize == false) {
    			navigate("/checkout");
    		}
    	};

    	onDestroy(() => {
    		unsubscribeCart();
    	});

    	const addWishlist = nid => {
    		if ($user == 0 || $user == undefined) {
    			navigate("/signin?backurl=/cart");
    			return;
    		}

    		if ($user.docData.wishlist && Object.keys($user.docData.wishlist).includes(nid)) {
    			// remove it
    			console.log("removing " + nid);

    			db.collection("users").doc($user.uid).update({
    				["wishlist." + nid]: firebase.firestore.FieldValue.delete()
    			});

    			delete $user.docData.wishlist[nid];
    			user.set($user);
    		} else {
    			console.log("adding " + nid);

    			notification.set({
    				accentColor: "success",
    				title: "success",
    				content: "Article Added to WishList"
    			});

    			db.collection("users").doc($user.uid).set({ wishlist: { [nid]: true } }, { merge: true });

    			set_store_value(
    				user,
    				$user = {
    					...$user,
    					docData: {
    						...$user.docData,
    						wishlist: { ...$user.docData.wishlist, [nid]: true }
    					}
    				},
    				$user
    			);
    		}
    	};

    	const writable_props = [];

    	Object_1$7.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<Cart> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (key, col) => {
    		updateColor(key, col);
    	};

    	const click_handler_1 = (key, size, e) => {
    		handleChangeSize(key, size);
    	};

    	const click_handler_2 = (value, each_value, each_index) => {
    		value.quantity <= 1 || value.quantity == undefined
    		? set_store_value(cart, each_value[each_index][1].quantity = 1, $cart)
    		: set_store_value(cart, each_value[each_index][1].quantity -= 1, $cart);

    		console.log("clicked");
    	};

    	const change_handler = (key, e) => {
    		updateQuantity(key, e);
    	};

    	const click_handler_3 = (value, each_value, each_index) => {
    		value.quantity != undefined
    		? set_store_value(cart, each_value[each_index][1].quantity += 1, $cart)
    		: set_store_value(cart, each_value[each_index][1].quantity = 2, $cart);
    	};

    	const click_handler_4 = key => {
    		removeItem(key);
    	};

    	const click_handler_5 = (value, each_value, each_index) => {
    		value.quantity <= 1 || value.quantity == undefined
    		? set_store_value(cart, each_value[each_index][1].quantity = 1, $cart)
    		: set_store_value(cart, each_value[each_index][1].quantity -= 1, $cart);
    	};

    	const change_handler_1 = (key, e) => {
    		updateQuantity(key, e);
    	};

    	const click_handler_6 = (value, each_value, each_index) => {
    		value.quantity != undefined
    		? set_store_value(cart, each_value[each_index][1].quantity += 1, $cart)
    		: set_store_value(cart, each_value[each_index][1].quantity = 2, $cart);
    	};

    	const click_handler_7 = key => {
    		removeItem(key);
    	};

    	$$self.$capture_state = () => ({
    		cart,
    		user,
    		db,
    		navigate,
    		onMount,
    		onDestroy,
    		textToHex,
    		notification,
    		link,
    		quantity,
    		loaded,
    		unsubscribeCart,
    		cartItems,
    		handleChangeSize,
    		updateQuantity,
    		updateColor,
    		isSelected,
    		calculateTotal,
    		normalTotal,
    		removeItem,
    		noSize,
    		verifyBeforeFinalize,
    		addWishlist,
    		$cart,
    		$user
    	});

    	$$self.$inject_state = $$props => {
    		if ("quantity" in $$props) quantity = $$props.quantity;
    		if ("loaded" in $$props) $$invalidate(0, loaded = $$props.loaded);
    		if ("unsubscribeCart" in $$props) unsubscribeCart = $$props.unsubscribeCart;
    		if ("cartItems" in $$props) $$invalidate(1, cartItems = $$props.cartItems);
    		if ("normalTotal" in $$props) $$invalidate(2, normalTotal = $$props.normalTotal);
    		if ("noSize" in $$props) $$invalidate(3, noSize = $$props.noSize);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		loaded,
    		cartItems,
    		normalTotal,
    		noSize,
    		$cart,
    		$user,
    		handleChangeSize,
    		updateQuantity,
    		updateColor,
    		removeItem,
    		verifyBeforeFinalize,
    		addWishlist,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		change_handler,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		change_handler_1,
    		click_handler_6,
    		click_handler_7
    	];
    }

    class Cart$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Cart",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src\routes\CartPage.svelte generated by Svelte v3.32.3 */

    function create_fragment$r(ctx) {
    	let cart;
    	let current;
    	cart = new Cart$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(cart.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(cart, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(cart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(cart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(cart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CartPage", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CartPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Cart: Cart$1 });
    	return [];
    }

    class CartPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CartPage",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    const states = {
        "Tunis": {
            "cities": [
                "Tunis",
                "Le Bardo",
                "Le Kram",
                "La Goulette",
                "Carthage",
                "Sidi Bou Said",
                "La Marsa",
                "Sidi Hassine"
            ],
            "postals": ["1000", "1069", "1002", "1073", "1001", "1054", "2016", "2085", "2025", "2026", "1003", "2035", "2051", "2052", "2087", "1046", "2023", "2053", "1074", "2066", "1082", "2092", "1004", "1013", "1029", "1005", "2000", "1006", "1075", "1064", "2062", "1091", "1068", "2042", "1009", "2060", "2089", "1067", "1053", "2078", "2046", "2076", "2045", "1057", "1019", "1008", "1059", "2009", "2017", "2015", "1089", "1027", "1095", "2072", "1007"]
        },
        "Ariana": {
            "cities": [
                "Ariana",
                "La Soukra",
                "Raoued",
                "Kalaat el-Andalous",
                "Sidi Thabet",
                "Ettadhamen-Mnihla"
            ],
            "postals": ["2080", "2027", "2037", "2091", "2058", "2041", "2094", "2061", "2022", "2081", "2056", "2083", "2088", "2020", "2032", "2057", "2035", "2073", "2036", "2073", "2036"]
        },
        "Ben Arous": {
            "cities": [
                "Ben Arous",
                "El Mourouj",
                "Hammam Lif",
                "Hammam Chott",
                "Bou Mhel el-Bassatine",
                "Ezzahra",
                "Rades",
                "Megrine",
                "Mohamedia-Fouchana",
                "Mornag",
                "Khalidia"
            ],
            "postals": ["2013", "2043", "2097", "2059", "2074", "2034", "2065", "1135", "2082", "2093", "2050", "2099", "2096", "2063", "2014", "2033", "2024", "1145", "2090", "2054", "2064", "2044", "2040", "1125", "2098", "2018", "2055", "2084", "1164"]
        },
        "Manouba": {
            "cities": [
                "Manouba",
                "Den Den",
                "Douar Hicher",
                "Oued Ellil",
                "Mornaguia",
                "Borj El Amri",
                "Djedeida",
                "Tebourba",
                "El Battan"
            ],
            "postals": ["1113", "1142", "1134", "1124", "2012", "2075", "2086", "2011", "2010", "2028", "1110", "1153", "1116", "2071", "2021", "2031", "1144", "1130", "1143", "1133", "1114"]
        },
        "Nabeul": {
            "cities": [
                "Nabeul",
                "Dar Chaabane",
                "Beni Khiar",
                "El Maamoura",
                "Somaa",
                "Korba",
                "Tazerka",
                "Menzel Temime",
                "Menzel Horr",
                "El Mida",
                "Kelibia",
                "Azmour",
                "Hammam Ghezeze",
                "Dar Allouch",
                "El Haouaria",
                "Takelsa",
                "Soliman",
                "Korbous",
                "Menzel Bouzelfa",
                "Beni Khalled",
                "Zaouiet Djedidi",
                "Grombalia",
                "Bou Argoub",
                "Hammamet"
            ],
            "postals": ["8021", "8014", "8099", "8060", "8023", "8013", "8066", "8022", "8061", "8040", "8011", "8075", "8026", "8046", "8074", "8036", "8045", "8016", "8044", "8089", "8071", "8093", "8030", "8012", "8092", "8082", "8052", "8084", "8025", "8096", "8056", "8042", "8050", "8032", "8090", "8035", "8055", "8069", "8094", "8065", "8070", "8043", "8024", "8033", "8053", "8076", "8010", "8091", "8080", "8054", "8034", "8015", "8083", "8064", "8000", "8062", "8063", "8051", "8020", "8041", "8073", "8031"]
        },
        "Zaghouan": {
            "cities": [
                "Zaghouan",
                "Zriba",
                "Bir Mcherga",
                "Djebel Oust",
                "El Fahs",
                "Nadhour"
            ],
            "postals": ["1123", "1141", "1193", "1111", "1131", "1162", "1140", "1194", "1146", "1154", "1160", "1163", "1122", "1152", "1112", "1115", "1100", "1155", "1132", "1121"]
        },
        "Bizerte": {
            "cities": [
                "Bizerte",
                "Sejnane",
                "Mateur",
                "Menzel Bourguiba",
                "Tinja",
                "Ghar al Milh",
                "Aousja",
                "Menzel Jemil",
                "Menzel Abderrahmane",
                "El Alia",
                "Ras Jebel",
                "Metline",
                "Raf Raf"
            ],
            "postals": ["7000", "7061", "7053", "7001", "7003", "7002", "7029", "7016", "7081", "7093", "7012", "7020", "7071", "7094", "7064", "7011", "7041", "7027", "7036", "7033", "7014", "7024", "7040", "7022", "7030", "7050", "7042", "7072", "7026", "7035", "7080", "7075", "7034", "7070", "7015", "7098", "7045", "7025", "7010", "7097", "7031", "7032", "7013", "7043", "7060", "7023", "7063", "7021"]
        },
        "Beja": {
            "cities": [
                "Beja",
                "El Maagoula",
                "Zahret Medien",
                "Nefza",
                "Teboursouk",
                "Testour",
                "Goubellat",
                "Majaz al Bab"
            ],
            "postals": ["9030", "9084", "9000", "9031", "9023", "9052", "9021", "9029", "9080", "9083", "9070", "9072", "9071", "9013", "9075", "9015", "9034", "9044", "9024", "9012", "9010", "9011", "9040", "9032", "9046", "9062", "9060", "9014", "9061", "9042", "9022"]
        },
        "Jendouba": {
            "cities": [
                "Jendouba",
                "Bou Salem",
                "Tabarka",
                "Ain Draham",
                "Fernana",
                "Beni M'Tir",
                "Ghardimaou",
                "Oued Melliz"
            ],
            "postals": ["8136", "8130", "8134", "8121", "8135", "8126", "8116", "8143", "8170", "8124", "8173", "8142", "8140", "8114", "8141", "8145", "8160", "8162", "8161", "8117", "8111", "8189", "8100", "8132", "8122", "8196", "8153", "8195", "8131", "8115", "8185", "8194", "8193", "8110", "8112", "8127", "8192", "8128", "8181"]
        },
        "Kef": {
            "cities": [
                "El Kef",
                "Nebeur",
                "Touiref",
                "Sakiet Sidi Youssef",
                "Tajerouine",
                "Menzel Salem",
                "Kalaat es Senam",
                "Kalaat Khasba",
                "Jerissa",
                "El Ksour",
                "Dahmani",
                "Sers"
            ],
            "postals": ["7170", "7114", "7160", "7115", "7113", "7123", "7180", "7135", "7136", "7130", "7117", "7110", "7111", "7131", "7141", "7150", "7153", "7132", "7151", "7133", "7125", "7120", "7112", "7116", "7100", "7122", "7194", "7134"]
        },
        "Siliana": {
            "cities": [
                "Siliana",
                "Bou Arada",
                "Gaafour",
                "El Krib",
                "Sidi Bou Rouis",
                "Maktar",
                "Rouhia",
                "Kesra",
                "Bargou",
                "El Aroussa"
            ],
            "postals": ["6180", "6113", "6134", "6112", "6135", "6116", "6152", "6150", "6172", "6111", "6121", "6110", "6126", "6131", "6141", "6114", "6133", "6125", "6120", "6122", "6132", "6140", "6151", "6142", "6100", "6130", "6123", "6196", "6124", "6143", "6170", "6115", "6173"]
        },
        "Sousse": {
            "cities": [
                "Sousse",
                "Ksibet Thrayet",
                "Ezzouhour",
                "Zaouiet Sousse",
                "Hammam Sousse",
                "Akouda",
                "Kalaa Kebira",
                "Sidi Bou Ali",
                "Hergla",
                "Enfidha",
                "Bouficha",
                "Sidi El Hani",
                "M'saken",
                "Kalaa Seghira",
                "Messaadine",
                "Kondar"
            ],
            "postals": ["4022", "4042", "4017", "4089", "4011", "4012", "4060", "4063", "4062", "4021", "4020", "4016", "4015", "4014", "4013", "4033", "4070", "4099", "4024", "4040", "4045", "4043", "4092", "4010", "4082", "4026", "4025", "4061", "4051", "4054", "4071", "4000", "4059", "4041", "4031", "4023", "4081", "4035", "4095", "4034", "4030", "4032"]
        },
        "Monastir": {
            "cities": [
                "Monastir",
                "Khniss",
                "Ouerdanin",
                "Sahline Moôtmar",
                "Sidi Ameur",
                "Zeramdine",
                "Beni Hassen",
                "Ghenada",
                "Jemmal",
                "Menzel Kamel",
                "Zaouiet Kontoch",
                "Bembla-Mnara",
                "Menzel Ennour",
                "El Masdour",
                "Moknine",
                "Sidi Bennour",
                "Menzel Farsi",
                "Amiret El Fhoul",
                "Amiret Touazra",
                "Amiret El Hojjaj",
                "Cherahil",
                "Bekalta",
                "Teboulba",
                "Ksar Hellal",
                "Ksibet El Mediouni",
                "Benen Bodher",
                "Touza",
                "Sayada",
                "Lemta",
                "Bouhjar",
                "Menzel Hayet"
            ],
            "postals": ["5090", "5091", "5092", "5021", "5022", "5032", "5076", "5036", "5062", "5014", "5026", "5043", "5020", "5028,5020", "5028", "5017", "5027", "5030", "5013", "5070", "5016", "5025", "5063", "5031", "5025,5031", "5023", "5053", "5071", "5054", "5034", "5050", "5024", "5051", "5044", "5060", "5089", "5011", "5000", "5065", "5079", "5052", "5010", "5041", "5012", "5061", "5042", "5015", "5099", "5035", "5035,5015", "5080", "5066", "5040", "5033", "5046", "5045"]
        },
        "Mahdia": {
            "cities": [
                "Mahdia",
                "Rejiche",
                "Bou Merdes",
                "Ouled Chamekh",
                "Chorbane",
                "Hebira",
                "Essouassi",
                "El Djem",
                "Kerker",
                "Chebba",
                "Mellouleche",
                "Sidi Alouane",
                "Ksour Essef",
                "El Bradaa"
            ],
            "postals": ["5112", "5125", "5110", "5170", "5133", "5130", "5135", "5160", "5124", "5153", "5134", "5140", "5145", "5144", "5155", "5113", "5154", "5122", "5180", "5126", "5115", "5136", "5189", "5116", "5146", "5141", "5100", "5111", "5199", "5121", "5131", "5127", "5129", "5150", "5120", "5123", "5190", "5132", "5151", "5193", "5192", "5114", "5117"]
        },
        "Sfax": {
            "cities": [
                "Sfax",
                "Sakiet Ezzit",
                "Chihia",
                "Sakiet Eddaier",
                "Gremda",
                "El Ain",
                "Thyna",
                "Agareb",
                "Jebiniana",
                "El Hencha",
                "Menzel Chaker",
                "Ghraiba, Tunisia",
                "Bir Ali Ben Khelifa",
                "Skhira",
                "Mahares",
                "Kerkennah"
            ],
            "postals": ["3030", "3037", "3057", "3075", "3040", "3082", "3085", "3097", "3026", "3080", "3086", "3077", "3016", "3056", "3087", "3036", "3095", "3046", "3066", "3024", "3034", "3010", "3043", "3033", "3053", "3060", "3044", "3070", "3015", "3035", "3055", "3045", "3025", "3020", "3092", "3014", "3041", "3031", "3021", "3091", "3000", "3047", "3039", "3099", "3089", "3079", "3032", "3051", "3027", "3069", "3049", "3065", "3048", "3052", "3064", "3072", "3071", "3023", "3013", "3083", "3084", "3042", "3074", "3076", "3078", "3059", "3022", "3093", "3012", "3062", "3050", "3073", "3094", "3011", "3054", "3081", "3061", "3063", "3067"]
        },
        "Kairouan": {
            "cities": [
                "Kairouan",
                "Chebika",
                "Sbikha",
                "Oueslatia",
                "Ain Djeloula",
                "Haffouz",
                "Alaa",
                "Hajeb El Ayoun",
                "Nasrallah",
                "Menzel Mehiri",
                "Echrarda",
                "Bou Hajla"
            ],
            "postals": ["3152", "3181", "3180", "3126", "3183", "3133", "3112", "3121", "3161", "3116", "3145", "3150", "3153", "3154", "3160", "3130", "3134", "3113", "3120", "3124", "3143", "3192", "3100", "3199", "3198", "3131", "3191", "3151", "3140", "3129", "3182", "3142", "3193", "3111", "3170", "3114", "3171", "3173", "3115", "3135", "3110", "3132", "3194", "3125", "3196", "3195"]
        },
        "Kasserine": {
            "cities": [
                "Kasserine",
                "Sbeitla",
                "Sbiba",
                "Jedelienne",
                "Thala",
                "Haidra",
                "Foussana",
                "Feriana",
                "Thelepte",
                "Magel Bel Abbes"
            ],
            "postals": ["1281", "1280", "1279", "1216", "1234", "1213", "1223", "1240", "1243", "1242", "1215", "1245", "1241", "1247", "1285", "1221", "1225", "1253", "1237", "1200", "1230", "1233", "1226", "1214", "1294", "1293", "1250", "1263", "1251", "1252", "1256", "1255", "1254", "1211", "1210", "1224", "1231", "1261", "1235", "1271", "1270", "1273", "1220", "1232", "1212", "1222"]
        },
        "Sidi Bouzid": {
            "cities": [
                "Sidi Bouzid",
                "Jilma",
                "Cebalet",
                "Bir El Hafey",
                "Sidi Ali Ben Aoun",
                "Menzel Bouzaiane",
                "Meknassy",
                "Mezzouna",
                "Regueb",
                "Ouled Haffouz"
            ],
            "postals": ["9113", "9126", "9159", "9123", "9122", "9110", "9143", "9140", "9158", "9149", "9144", "9180", "9116", "9183", "9150", "9154", "9151", "9170", "9115", "9173", "9174", "9172", "9120", "9169", "9112", "9100", "9133", "9171", "9141", "9131", "9111", "9132", "9125", "9127", "9121", "9142", "9114", "9139", "9124"]
        },
        "Gabes": {
            "cities": [
                "Gabes",
                "Chenini Nahal",
                "Ghannouch",
                "Metouia",
                "Oudhref",
                "El Hamma",
                "Matmata",
                "Nouvelle Matmata",
                "Mareth",
                "Zarat"
            ],
            "postals": ["6092", "6062", "6027", "6095", "6020", "6060", "6013", "6010", "6010,6052", "6052", "6042", "6089", "6061", "6000", "6099", "6001", "6071", "6040", "6041", "6031", "6051", "6032", "6012,6072", "6012", "6014", "6072", "6033", "6011", "6022", "6021", "6035", "6080", "6016", "6015", "6081", "6036", "6055", "6023", "6056", "6046", "6045", "6026", "6070", "6054", "6034", "6024", "6025", "6044", "6043", "6030"]
        },
        "Mednine": {
            "cities": [
                "Medenine",
                "Beni Khedache",
                "Ben Gardane",
                "Zarzis",
                "Houmt El Souk",
                "Midoun",
                "Ajim"
            ],
            "postals": ["4160", "4163", "4192", "4193", "4183", "4153", "4151", "4110", "4159", "4132", "4122", "4112", "4180", "4185", "4146", "4156", "4195", "4120", "4115", "4186", "4123", "4182", "4136", "4179", "4190", "4100", "4121", "4130", "4142", "4111", "4116", "4176", "4126", "4145", "4199", "4175", "4165", "4113", "4133", "4141", "4143", "4131", "4127", "4191", "4181", "4117", "4135", "4125", "4155", "4150", "4166", "4170", "4134", "4173", "4154", "4124", "4144", "4114", "4164", "4194", "4174", "4172", "4137"]
        },
        "Tataouine": {
            "cities": [
                "Tataouine",
                "Bir Lahmar",
                "Ghomrassen",
                "Dehiba",
                "Remada"
            ],
            "postals": ["3212", "3253", "3220", "3241", "3224", "3271", "3261", "3251", "3235", "3262", "3223", "3200", "3225", "3213", "3244", "3240", "3245", "3286", "3217", "3272", "3233", "3282", "3243", "3263", "3214", "3215", "3284", "3222", "3274", "3232", "3242", "3221", "3252", "3264", "3293", "3211"]
        },
        "Gafsa": {
            "cities": [
                "Gafsa",
                "El Ksar",
                "Moulares",
                "Redeyef",
                "Metlaoui",
                "Mdhila",
                "El Guettar",
                "Sened"
            ],
            "postals": ["2135", "2115", "2139", "2196", "2141", "2111", "2169", "2151", "2121", "2173", "2170", "2100", "2124", "2143", "2142", "2133", "2123", "2112", "2130", "2132", "2134", "2113", "2120", "2140", "2122", "2110", "2161", "2114", "2131", "2180", "2125", "2183", "2181", "2145", "2193", "2195", "2190", "2116", "2192"]
        },
        "Tozeur": {
            "cities": [
                "Tozeur",
                "Degache",
                "Hamet Jerid",
                "Nafta",
                "Tamerza"
            ],
            "postals": ["2263", "2214", "2260", "2262", "2224", "2261", "2223", "2245", "2240", "2212", "2253", "2211", "2233", "2243", "2239", "2210", "2200", "2241", "2213"]
        },
        "Kebili": {
            "cities": [
                "Kebili",
                "Djemna",
                "Douz",
                "El Golaa",
                "Souk Lahad"
            ],
            "postals": ["4222", "4234", "4216", "4215", "4260", "4261", "4264", "4210", "4293", "4280", "4274", "4233", "4294", "4273", "4237", "4232", "4235", "4231", "4236", "4283", "4223", "4230", "4212", "4213", "4253", "4224", "4200", "4243", "4242", "4214", "4263", "4211"]
        }
    };

    /* node_modules\svelte-select\src\Item.svelte generated by Svelte v3.32.3 */

    const file$m = "node_modules\\svelte-select\\src\\Item.svelte";

    function create_fragment$s(ctx) {
    	let div;
    	let raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "";
    	let div_class_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-bdnybl");
    			add_location(div, file$m, 61, 0, 1353);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getOptionLabel, item, filterText*/ 7 && raw_value !== (raw_value = /*getOptionLabel*/ ctx[0](/*item*/ ctx[1], /*filterText*/ ctx[2]) + "")) div.innerHTML = raw_value;
    			if (dirty & /*itemClasses*/ 8 && div_class_value !== (div_class_value = "item " + /*itemClasses*/ ctx[3] + " svelte-bdnybl")) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Item", slots, []);
    	let { isActive = false } = $$props;
    	let { isFirst = false } = $$props;
    	let { isHover = false } = $$props;
    	let { getOptionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	let { filterText = "" } = $$props;
    	let itemClasses = "";
    	const writable_props = ["isActive", "isFirst", "isHover", "getOptionLabel", "item", "filterText"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Item> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("isActive" in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ("isFirst" in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ("isHover" in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ("getOptionLabel" in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    		if ("filterText" in $$props) $$invalidate(2, filterText = $$props.filterText);
    	};

    	$$self.$capture_state = () => ({
    		isActive,
    		isFirst,
    		isHover,
    		getOptionLabel,
    		item,
    		filterText,
    		itemClasses
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(4, isActive = $$props.isActive);
    		if ("isFirst" in $$props) $$invalidate(5, isFirst = $$props.isFirst);
    		if ("isHover" in $$props) $$invalidate(6, isHover = $$props.isHover);
    		if ("getOptionLabel" in $$props) $$invalidate(0, getOptionLabel = $$props.getOptionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    		if ("filterText" in $$props) $$invalidate(2, filterText = $$props.filterText);
    		if ("itemClasses" in $$props) $$invalidate(3, itemClasses = $$props.itemClasses);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive, isFirst, isHover, item*/ 114) {
    			{
    				const classes = [];

    				if (isActive) {
    					classes.push("active");
    				}

    				if (isFirst) {
    					classes.push("first");
    				}

    				if (isHover) {
    					classes.push("hover");
    				}

    				if (item.isGroupHeader) {
    					classes.push("groupHeader");
    				}

    				if (item.isGroupItem) {
    					classes.push("groupItem");
    				}

    				$$invalidate(3, itemClasses = classes.join(" "));
    			}
    		}
    	};

    	return [getOptionLabel, item, filterText, itemClasses, isActive, isFirst, isHover];
    }

    class Item extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {
    			isActive: 4,
    			isFirst: 5,
    			isHover: 6,
    			getOptionLabel: 0,
    			item: 1,
    			filterText: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Item",
    			options,
    			id: create_fragment$s.name
    		});
    	}

    	get isActive() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFirst() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFirst(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isHover() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isHover(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\VirtualList.svelte generated by Svelte v3.32.3 */
    const file$n = "node_modules\\svelte-select\\src\\VirtualList.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    const get_default_slot_changes$1 = dirty => ({
    	item: dirty & /*visible*/ 32,
    	i: dirty & /*visible*/ 32,
    	hoverItemIndex: dirty & /*hoverItemIndex*/ 2
    });

    const get_default_slot_context$1 = ctx => ({
    	item: /*row*/ ctx[23].data,
    	i: /*row*/ ctx[23].index,
    	hoverItemIndex: /*hoverItemIndex*/ ctx[1]
    });

    // (160:57) Missing template
    function fallback_block(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Missing template");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(160:57) Missing template",
    		ctx
    	});

    	return block;
    }

    // (158:2) {#each visible as row (row.index)}
    function create_each_block$9(key_1, ctx) {
    	let svelte_virtual_list_row;
    	let t;
    	let current;
    	const default_slot_template = /*#slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], get_default_slot_context$1);
    	const default_slot_or_fallback = default_slot || fallback_block(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			svelte_virtual_list_row = element("svelte-virtual-list-row");
    			if (default_slot_or_fallback) default_slot_or_fallback.c();
    			t = space();
    			set_custom_element_data(svelte_virtual_list_row, "class", "svelte-p6ehlv");
    			add_location(svelte_virtual_list_row, file$n, 158, 3, 3514);
    			this.first = svelte_virtual_list_row;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_row, anchor);

    			if (default_slot_or_fallback) {
    				default_slot_or_fallback.m(svelte_virtual_list_row, null);
    			}

    			append_dev(svelte_virtual_list_row, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope, visible, hoverItemIndex*/ 16418) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, get_default_slot_changes$1, get_default_slot_context$1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_row);
    			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(158:2) {#each visible as row (row.index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$t(ctx) {
    	let svelte_virtual_list_viewport;
    	let svelte_virtual_list_contents;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let svelte_virtual_list_viewport_resize_listener;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*visible*/ ctx[5];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[23].index;
    	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
    			svelte_virtual_list_contents = element("svelte-virtual-list-contents");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-p6ehlv");
    			add_location(svelte_virtual_list_contents, file$n, 156, 1, 3364);
    			set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-p6ehlv");
    			add_render_callback(() => /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].call(svelte_virtual_list_viewport));
    			add_location(svelte_virtual_list_viewport, file$n, 154, 0, 3222);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svelte_virtual_list_viewport, anchor);
    			append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(svelte_virtual_list_contents, null);
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](svelte_virtual_list_contents);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](svelte_virtual_list_viewport);
    			svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport, /*svelte_virtual_list_viewport_elementresize_handler*/ ctx[18].bind(svelte_virtual_list_viewport));
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(svelte_virtual_list_viewport, "scroll", /*handle_scroll*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$$scope, visible, hoverItemIndex*/ 16418) {
    				each_value = /*visible*/ ctx[5];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block$9, null, get_each_context$9);
    				check_outros();
    			}

    			if (!current || dirty & /*top*/ 64) {
    				set_style(svelte_virtual_list_contents, "padding-top", /*top*/ ctx[6] + "px");
    			}

    			if (!current || dirty & /*bottom*/ 128) {
    				set_style(svelte_virtual_list_contents, "padding-bottom", /*bottom*/ ctx[7] + "px");
    			}

    			if (!current || dirty & /*height*/ 1) {
    				set_style(svelte_virtual_list_viewport, "height", /*height*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svelte_virtual_list_viewport);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			/*svelte_virtual_list_contents_binding*/ ctx[16](null);
    			/*svelte_virtual_list_viewport_binding*/ ctx[17](null);
    			svelte_virtual_list_viewport_resize_listener();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("VirtualList", slots, ['default']);
    	let { items = undefined } = $$props;
    	let { height = "100%" } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { start = 0 } = $$props;
    	let { end = 0 } = $$props;

    	// local state
    	let height_map = [];

    	let rows;
    	let viewport;
    	let contents;
    	let viewport_height = 0;
    	let visible;
    	let mounted;
    	let top = 0;
    	let bottom = 0;
    	let average_height;

    	async function refresh(items, viewport_height, itemHeight) {
    		const { scrollTop } = viewport;
    		await tick(); // wait until the DOM is up to date
    		let content_height = top - scrollTop;
    		let i = start;

    		while (content_height < viewport_height && i < items.length) {
    			let row = rows[i - start];

    			if (!row) {
    				$$invalidate(10, end = i + 1);
    				await tick(); // render the newly visible row
    				row = rows[i - start];
    			}

    			const row_height = height_map[i] = itemHeight || row.offsetHeight;
    			content_height += row_height;
    			i += 1;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = (top + content_height) / end;
    		$$invalidate(7, bottom = remaining * average_height);
    		height_map.length = items.length;
    		$$invalidate(3, viewport.scrollTop = 0, viewport);
    	}

    	async function handle_scroll() {
    		const { scrollTop } = viewport;
    		const old_start = start;

    		for (let v = 0; v < rows.length; v += 1) {
    			height_map[start + v] = itemHeight || rows[v].offsetHeight;
    		}

    		let i = 0;
    		let y = 0;

    		while (i < items.length) {
    			const row_height = height_map[i] || average_height;

    			if (y + row_height > scrollTop) {
    				$$invalidate(9, start = i);
    				$$invalidate(6, top = y);
    				break;
    			}

    			y += row_height;
    			i += 1;
    		}

    		while (i < items.length) {
    			y += height_map[i] || average_height;
    			i += 1;
    			if (y > scrollTop + viewport_height) break;
    		}

    		$$invalidate(10, end = i);
    		const remaining = items.length - end;
    		average_height = y / end;
    		while (i < items.length) height_map[i++] = average_height;
    		$$invalidate(7, bottom = remaining * average_height);

    		// prevent jumping if we scrolled up into unknown territory
    		if (start < old_start) {
    			await tick();
    			let expected_height = 0;
    			let actual_height = 0;

    			for (let i = start; i < old_start; i += 1) {
    				if (rows[i - start]) {
    					expected_height += height_map[i];
    					actual_height += itemHeight || rows[i - start].offsetHeight;
    				}
    			}

    			const d = actual_height - expected_height;
    			viewport.scrollTo(0, scrollTop + d);
    		}
    	} // TODO if we overestimated the space these
    	// rows would occupy we may need to add some

    	// more. maybe we can just call handle_scroll again?
    	// trigger initial refresh
    	onMount(() => {
    		rows = contents.getElementsByTagName("svelte-virtual-list-row");
    		$$invalidate(13, mounted = true);
    	});

    	const writable_props = ["items", "height", "itemHeight", "hoverItemIndex", "start", "end"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VirtualList> was created with unknown prop '${key}'`);
    	});

    	function svelte_virtual_list_contents_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			contents = $$value;
    			$$invalidate(4, contents);
    		});
    	}

    	function svelte_virtual_list_viewport_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			viewport = $$value;
    			$$invalidate(3, viewport);
    		});
    	}

    	function svelte_virtual_list_viewport_elementresize_handler() {
    		viewport_height = this.offsetHeight;
    		$$invalidate(2, viewport_height);
    	}

    	$$self.$$set = $$props => {
    		if ("items" in $$props) $$invalidate(11, items = $$props.items);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("itemHeight" in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("start" in $$props) $$invalidate(9, start = $$props.start);
    		if ("end" in $$props) $$invalidate(10, end = $$props.end);
    		if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tick,
    		items,
    		height,
    		itemHeight,
    		hoverItemIndex,
    		start,
    		end,
    		height_map,
    		rows,
    		viewport,
    		contents,
    		viewport_height,
    		visible,
    		mounted,
    		top,
    		bottom,
    		average_height,
    		refresh,
    		handle_scroll
    	});

    	$$self.$inject_state = $$props => {
    		if ("items" in $$props) $$invalidate(11, items = $$props.items);
    		if ("height" in $$props) $$invalidate(0, height = $$props.height);
    		if ("itemHeight" in $$props) $$invalidate(12, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("start" in $$props) $$invalidate(9, start = $$props.start);
    		if ("end" in $$props) $$invalidate(10, end = $$props.end);
    		if ("height_map" in $$props) height_map = $$props.height_map;
    		if ("rows" in $$props) rows = $$props.rows;
    		if ("viewport" in $$props) $$invalidate(3, viewport = $$props.viewport);
    		if ("contents" in $$props) $$invalidate(4, contents = $$props.contents);
    		if ("viewport_height" in $$props) $$invalidate(2, viewport_height = $$props.viewport_height);
    		if ("visible" in $$props) $$invalidate(5, visible = $$props.visible);
    		if ("mounted" in $$props) $$invalidate(13, mounted = $$props.mounted);
    		if ("top" in $$props) $$invalidate(6, top = $$props.top);
    		if ("bottom" in $$props) $$invalidate(7, bottom = $$props.bottom);
    		if ("average_height" in $$props) average_height = $$props.average_height;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*items, start, end*/ 3584) {
    			$$invalidate(5, visible = items.slice(start, end).map((data, i) => {
    				return { index: i + start, data };
    			}));
    		}

    		if ($$self.$$.dirty & /*mounted, items, viewport_height, itemHeight*/ 14340) {
    			// whenever `items` changes, invalidate the current heightmap
    			if (mounted) refresh(items, viewport_height, itemHeight);
    		}
    	};

    	return [
    		height,
    		hoverItemIndex,
    		viewport_height,
    		viewport,
    		contents,
    		visible,
    		top,
    		bottom,
    		handle_scroll,
    		start,
    		end,
    		items,
    		itemHeight,
    		mounted,
    		$$scope,
    		slots,
    		svelte_virtual_list_contents_binding,
    		svelte_virtual_list_viewport_binding,
    		svelte_virtual_list_viewport_elementresize_handler
    	];
    }

    class VirtualList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {
    			items: 11,
    			height: 0,
    			itemHeight: 12,
    			hoverItemIndex: 1,
    			start: 9,
    			end: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "VirtualList",
    			options,
    			id: create_fragment$t.name
    		});
    	}

    	get items() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get start() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set start(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get end() {
    		throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set end(value) {
    		throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\List.svelte generated by Svelte v3.32.3 */
    const file$o = "node_modules\\svelte-select\\src\\List.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	child_ctx[36] = i;
    	return child_ctx;
    }

    // (210:0) {#if isVirtualList}
    function create_if_block_3$4(ctx) {
    	let div;
    	let virtuallist;
    	let current;

    	virtuallist = new VirtualList({
    			props: {
    				items: /*items*/ ctx[4],
    				itemHeight: /*itemHeight*/ ctx[7],
    				$$slots: {
    					default: [
    						create_default_slot$1,
    						({ item, i }) => ({ 34: item, 36: i }),
    						({ item, i }) => [0, (item ? 8 : 0) | (i ? 32 : 0)]
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(virtuallist.$$.fragment);
    			attr_dev(div, "class", "listContainer virtualList svelte-ux0sbr");
    			add_location(div, file$o, 210, 0, 5850);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(virtuallist, div, null);
    			/*div_binding*/ ctx[20](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const virtuallist_changes = {};
    			if (dirty[0] & /*items*/ 16) virtuallist_changes.items = /*items*/ ctx[4];
    			if (dirty[0] & /*itemHeight*/ 128) virtuallist_changes.itemHeight = /*itemHeight*/ ctx[7];

    			if (dirty[0] & /*Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, items*/ 4918 | dirty[1] & /*$$scope, item, i*/ 104) {
    				virtuallist_changes.$$scope = { dirty, ctx };
    			}

    			virtuallist.$set(virtuallist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(virtuallist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(virtuallist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(virtuallist);
    			/*div_binding*/ ctx[20](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(210:0) {#if isVirtualList}",
    		ctx
    	});

    	return block;
    }

    // (213:2) <VirtualList {items} {itemHeight} let:item let:i>
    function create_default_slot$1(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[2];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[34],
    				filterText: /*filterText*/ ctx[12],
    				getOptionLabel: /*getOptionLabel*/ ctx[5],
    				isFirst: isItemFirst(/*i*/ ctx[36]),
    				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler() {
    		return /*mouseover_handler*/ ctx[18](/*i*/ ctx[36]);
    	}

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[19](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "listItem");
    			add_location(div, file$o, 214, 4, 5970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler, false, false, false),
    					listen_dev(div, "click", click_handler, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[1] & /*item*/ 8) switch_instance_changes.item = /*item*/ ctx[34];
    			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
    			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
    			if (dirty[1] & /*i*/ 32) switch_instance_changes.isFirst = isItemFirst(/*i*/ ctx[36]);
    			if (dirty[0] & /*selectedValue, optionIdentifier*/ 768 | dirty[1] & /*item*/ 8) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 18 | dirty[1] & /*item, i*/ 40) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(213:2) <VirtualList {items} {itemHeight} let:item let:i>",
    		ctx
    	});

    	return block;
    }

    // (232:0) {#if !isVirtualList}
    function create_if_block$d(ctx) {
    	let div;
    	let current;
    	let each_value = /*items*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block_1$2(ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (each_1_else) {
    				each_1_else.c();
    			}

    			attr_dev(div, "class", "listContainer svelte-ux0sbr");
    			add_location(div, file$o, 232, 0, 6477);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			if (each_1_else) {
    				each_1_else.m(div, null);
    			}

    			/*div_binding_1*/ ctx[23](div);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items, handleHover, handleClick, Item, filterText, getOptionLabel, selectedValue, optionIdentifier, hoverItemIndex, noOptionsMessage, hideEmptyState*/ 32630) {
    				each_value = /*items*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();

    				if (!each_value.length && each_1_else) {
    					each_1_else.p(ctx, dirty);
    				} else if (!each_value.length) {
    					each_1_else = create_else_block_1$2(ctx);
    					each_1_else.c();
    					each_1_else.m(div, null);
    				} else if (each_1_else) {
    					each_1_else.d(1);
    					each_1_else = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (each_1_else) each_1_else.d();
    			/*div_binding_1*/ ctx[23](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(232:0) {#if !isVirtualList}",
    		ctx
    	});

    	return block;
    }

    // (254:2) {:else}
    function create_else_block_1$2(ctx) {
    	let if_block_anchor;
    	let if_block = !/*hideEmptyState*/ ctx[10] && create_if_block_2$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (!/*hideEmptyState*/ ctx[10]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$4(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(254:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (255:4) {#if !hideEmptyState}
    function create_if_block_2$4(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*noOptionsMessage*/ ctx[11]);
    			attr_dev(div, "class", "empty svelte-ux0sbr");
    			add_location(div, file$o, 255, 6, 7178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*noOptionsMessage*/ 2048) set_data_dev(t, /*noOptionsMessage*/ ctx[11]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(255:4) {#if !hideEmptyState}",
    		ctx
    	});

    	return block;
    }

    // (237:4) { :else }
    function create_else_block$9(ctx) {
    	let div;
    	let switch_instance;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Item*/ ctx[2];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*item*/ ctx[34],
    				filterText: /*filterText*/ ctx[12],
    				getOptionLabel: /*getOptionLabel*/ ctx[5],
    				isFirst: isItemFirst(/*i*/ ctx[36]),
    				isActive: isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]),
    				isHover: isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4])
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	function mouseover_handler_1() {
    		return /*mouseover_handler_1*/ ctx[21](/*i*/ ctx[36]);
    	}

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[22](/*item*/ ctx[34], /*i*/ ctx[36], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t = space();
    			attr_dev(div, "class", "listItem");
    			add_location(div, file$o, 237, 4, 6691);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseover", mouseover_handler_1, false, false, false),
    					listen_dev(div, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const switch_instance_changes = {};
    			if (dirty[0] & /*items*/ 16) switch_instance_changes.item = /*item*/ ctx[34];
    			if (dirty[0] & /*filterText*/ 4096) switch_instance_changes.filterText = /*filterText*/ ctx[12];
    			if (dirty[0] & /*getOptionLabel*/ 32) switch_instance_changes.getOptionLabel = /*getOptionLabel*/ ctx[5];
    			if (dirty[0] & /*items, selectedValue, optionIdentifier*/ 784) switch_instance_changes.isActive = isItemActive(/*item*/ ctx[34], /*selectedValue*/ ctx[8], /*optionIdentifier*/ ctx[9]);
    			if (dirty[0] & /*hoverItemIndex, items*/ 18) switch_instance_changes.isHover = isItemHover(/*hoverItemIndex*/ ctx[1], /*item*/ ctx[34], /*i*/ ctx[36], /*items*/ ctx[4]);

    			if (switch_value !== (switch_value = /*Item*/ ctx[2])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, t);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(237:4) { :else }",
    		ctx
    	});

    	return block;
    }

    // (235:4) {#if item.isGroupHeader && !item.isSelectable}
    function create_if_block_1$7(ctx) {
    	let div;
    	let t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "listGroupTitle svelte-ux0sbr");
    			add_location(div, file$o, 235, 6, 6611);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*getGroupHeaderLabel, items*/ 80 && t_value !== (t_value = /*getGroupHeaderLabel*/ ctx[6](/*item*/ ctx[34]) + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(235:4) {#if item.isGroupHeader && !item.isSelectable}",
    		ctx
    	});

    	return block;
    }

    // (234:2) {#each items as item, i}
    function create_each_block$a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$7, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*item*/ ctx[34].isGroupHeader && !/*item*/ ctx[34].isSelectable) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(234:2) {#each items as item, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*isVirtualList*/ ctx[3] && create_if_block_3$4(ctx);
    	let if_block1 = !/*isVirtualList*/ ctx[3] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "keydown", /*handleKeyDown*/ ctx[15], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*isVirtualList*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*isVirtualList*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (!/*isVirtualList*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isVirtualList*/ 8) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$d(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function itemClasses(hoverItemIndex, item, itemIndex, items, selectedValue, optionIdentifier, isMulti) {
    	return `${selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]
	? "active "
	: ""}${hoverItemIndex === itemIndex || items.length === 1
	? "hover"
	: ""}`;
    }

    function isItemActive(item, selectedValue, optionIdentifier) {
    	return selectedValue && selectedValue[optionIdentifier] === item[optionIdentifier];
    }

    function isItemFirst(itemIndex) {
    	return itemIndex === 0;
    }

    function isItemHover(hoverItemIndex, item, itemIndex, items) {
    	return hoverItemIndex === itemIndex || items.length === 1;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("List", slots, []);
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { items = [] } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		if (option) return option.isCreator
    		? `Create \"${filterText}\"`
    		: option.label;
    	} } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option.label;
    	} } = $$props;

    	let { itemHeight = 40 } = $$props;
    	let { hoverItemIndex = 0 } = $$props;
    	let { selectedValue = undefined } = $$props;
    	let { optionIdentifier = "value" } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { noOptionsMessage = "No options" } = $$props;
    	let { isMulti = false } = $$props;
    	let { activeItemIndex = 0 } = $$props;
    	let { filterText = "" } = $$props;
    	let isScrollingTimer = 0;
    	let isScrolling = false;
    	let prev_items;
    	let prev_activeItemIndex;
    	let prev_selectedValue;

    	onMount(() => {
    		if (items.length > 0 && !isMulti && selectedValue) {
    			const _hoverItemIndex = items.findIndex(item => item[optionIdentifier] === selectedValue[optionIdentifier]);

    			if (_hoverItemIndex) {
    				$$invalidate(1, hoverItemIndex = _hoverItemIndex);
    			}
    		}

    		scrollToActiveItem("active");

    		container.addEventListener(
    			"scroll",
    			() => {
    				clearTimeout(isScrollingTimer);

    				isScrollingTimer = setTimeout(
    					() => {
    						isScrolling = false;
    					},
    					100
    				);
    			},
    			false
    		);
    	});

    	onDestroy(() => {
    		
    	}); // clearTimeout(isScrollingTimer);

    	beforeUpdate(() => {
    		if (items !== prev_items && items.length > 0) {
    			$$invalidate(1, hoverItemIndex = 0);
    		}

    		// if (prev_activeItemIndex && activeItemIndex > -1) {
    		//   hoverItemIndex = activeItemIndex;
    		//   scrollToActiveItem('active');
    		// }
    		// if (prev_selectedValue && selectedValue) {
    		//   scrollToActiveItem('active');
    		//   if (items && !isMulti) {
    		//     const hoverItemIndex = items.findIndex((item) => item[optionIdentifier] === selectedValue[optionIdentifier]);
    		//     if (hoverItemIndex) {
    		//       hoverItemIndex = hoverItemIndex;
    		//     }
    		//   }
    		// }
    		prev_items = items;

    		prev_activeItemIndex = activeItemIndex;
    		prev_selectedValue = selectedValue;
    	});

    	function handleSelect(item) {
    		if (item.isCreator) return;
    		dispatch("itemSelected", item);
    	}

    	function handleHover(i) {
    		if (isScrolling) return;
    		$$invalidate(1, hoverItemIndex = i);
    	}

    	function handleClick(args) {
    		const { item, i, event } = args;
    		event.stopPropagation();
    		if (selectedValue && !isMulti && selectedValue[optionIdentifier] === item[optionIdentifier]) return closeList();

    		if (item.isCreator) {
    			dispatch("itemCreated", filterText);
    		} else {
    			$$invalidate(16, activeItemIndex = i);
    			$$invalidate(1, hoverItemIndex = i);
    			handleSelect(item);
    		}
    	}

    	function closeList() {
    		dispatch("closeList");
    	}

    	async function updateHoverItem(increment) {
    		if (isVirtualList) return;
    		let isNonSelectableItem = true;

    		while (isNonSelectableItem) {
    			if (increment > 0 && hoverItemIndex === items.length - 1) {
    				$$invalidate(1, hoverItemIndex = 0);
    			} else if (increment < 0 && hoverItemIndex === 0) {
    				$$invalidate(1, hoverItemIndex = items.length - 1);
    			} else {
    				$$invalidate(1, hoverItemIndex = hoverItemIndex + increment);
    			}

    			isNonSelectableItem = items[hoverItemIndex].isGroupHeader && !items[hoverItemIndex].isSelectable;
    		}

    		await tick();
    		scrollToActiveItem("hover");
    	}

    	function handleKeyDown(e) {
    		switch (e.key) {
    			case "ArrowDown":
    				e.preventDefault();
    				items.length && updateHoverItem(1);
    				break;
    			case "ArrowUp":
    				e.preventDefault();
    				items.length && updateHoverItem(-1);
    				break;
    			case "Enter":
    				e.preventDefault();
    				if (items.length === 0) break;
    				const hoverItem = items[hoverItemIndex];
    				if (selectedValue && !isMulti && selectedValue[optionIdentifier] === hoverItem[optionIdentifier]) {
    					closeList();
    					break;
    				}
    				if (hoverItem.isCreator) {
    					dispatch("itemCreated", filterText);
    				} else {
    					$$invalidate(16, activeItemIndex = hoverItemIndex);
    					handleSelect(items[hoverItemIndex]);
    				}
    				break;
    			case "Tab":
    				e.preventDefault();
    				if (items.length === 0) break;
    				if (selectedValue && selectedValue[optionIdentifier] === items[hoverItemIndex][optionIdentifier]) return closeList();
    				$$invalidate(16, activeItemIndex = hoverItemIndex);
    				handleSelect(items[hoverItemIndex]);
    				break;
    		}
    	}

    	function scrollToActiveItem(className) {
    		if (isVirtualList || !container) return;
    		let offsetBounding;
    		const focusedElemBounding = container.querySelector(`.listItem .${className}`);

    		if (focusedElemBounding) {
    			offsetBounding = container.getBoundingClientRect().bottom - focusedElemBounding.getBoundingClientRect().bottom;
    		}

    		$$invalidate(0, container.scrollTop -= offsetBounding, container);
    	}

    	
    	

    	const writable_props = [
    		"container",
    		"Item",
    		"isVirtualList",
    		"items",
    		"getOptionLabel",
    		"getGroupHeaderLabel",
    		"itemHeight",
    		"hoverItemIndex",
    		"selectedValue",
    		"optionIdentifier",
    		"hideEmptyState",
    		"noOptionsMessage",
    		"isMulti",
    		"activeItemIndex",
    		"filterText"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<List> was created with unknown prop '${key}'`);
    	});

    	const mouseover_handler = i => handleHover(i);
    	const click_handler = (item, i, event) => handleClick({ item, i, event });

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	const mouseover_handler_1 = i => handleHover(i);
    	const click_handler_1 = (item, i, event) => handleClick({ item, i, event });

    	function div_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(0, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("container" in $$props) $$invalidate(0, container = $$props.container);
    		if ("Item" in $$props) $$invalidate(2, Item$1 = $$props.Item);
    		if ("isVirtualList" in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
    		if ("items" in $$props) $$invalidate(4, items = $$props.items);
    		if ("getOptionLabel" in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("itemHeight" in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("selectedValue" in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
    		if ("optionIdentifier" in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
    		if ("hideEmptyState" in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
    		if ("noOptionsMessage" in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
    		if ("isMulti" in $$props) $$invalidate(17, isMulti = $$props.isMulti);
    		if ("activeItemIndex" in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
    		if ("filterText" in $$props) $$invalidate(12, filterText = $$props.filterText);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick,
    		dispatch,
    		container,
    		ItemComponent: Item,
    		VirtualList,
    		Item: Item$1,
    		isVirtualList,
    		items,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		hoverItemIndex,
    		selectedValue,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		isMulti,
    		activeItemIndex,
    		filterText,
    		isScrollingTimer,
    		isScrolling,
    		prev_items,
    		prev_activeItemIndex,
    		prev_selectedValue,
    		itemClasses,
    		handleSelect,
    		handleHover,
    		handleClick,
    		closeList,
    		updateHoverItem,
    		handleKeyDown,
    		scrollToActiveItem,
    		isItemActive,
    		isItemFirst,
    		isItemHover
    	});

    	$$self.$inject_state = $$props => {
    		if ("container" in $$props) $$invalidate(0, container = $$props.container);
    		if ("Item" in $$props) $$invalidate(2, Item$1 = $$props.Item);
    		if ("isVirtualList" in $$props) $$invalidate(3, isVirtualList = $$props.isVirtualList);
    		if ("items" in $$props) $$invalidate(4, items = $$props.items);
    		if ("getOptionLabel" in $$props) $$invalidate(5, getOptionLabel = $$props.getOptionLabel);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(6, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("itemHeight" in $$props) $$invalidate(7, itemHeight = $$props.itemHeight);
    		if ("hoverItemIndex" in $$props) $$invalidate(1, hoverItemIndex = $$props.hoverItemIndex);
    		if ("selectedValue" in $$props) $$invalidate(8, selectedValue = $$props.selectedValue);
    		if ("optionIdentifier" in $$props) $$invalidate(9, optionIdentifier = $$props.optionIdentifier);
    		if ("hideEmptyState" in $$props) $$invalidate(10, hideEmptyState = $$props.hideEmptyState);
    		if ("noOptionsMessage" in $$props) $$invalidate(11, noOptionsMessage = $$props.noOptionsMessage);
    		if ("isMulti" in $$props) $$invalidate(17, isMulti = $$props.isMulti);
    		if ("activeItemIndex" in $$props) $$invalidate(16, activeItemIndex = $$props.activeItemIndex);
    		if ("filterText" in $$props) $$invalidate(12, filterText = $$props.filterText);
    		if ("isScrollingTimer" in $$props) isScrollingTimer = $$props.isScrollingTimer;
    		if ("isScrolling" in $$props) isScrolling = $$props.isScrolling;
    		if ("prev_items" in $$props) prev_items = $$props.prev_items;
    		if ("prev_activeItemIndex" in $$props) prev_activeItemIndex = $$props.prev_activeItemIndex;
    		if ("prev_selectedValue" in $$props) prev_selectedValue = $$props.prev_selectedValue;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		container,
    		hoverItemIndex,
    		Item$1,
    		isVirtualList,
    		items,
    		getOptionLabel,
    		getGroupHeaderLabel,
    		itemHeight,
    		selectedValue,
    		optionIdentifier,
    		hideEmptyState,
    		noOptionsMessage,
    		filterText,
    		handleHover,
    		handleClick,
    		handleKeyDown,
    		activeItemIndex,
    		isMulti,
    		mouseover_handler,
    		click_handler,
    		div_binding,
    		mouseover_handler_1,
    		click_handler_1,
    		div_binding_1
    	];
    }

    class List extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$u,
    			create_fragment$u,
    			safe_not_equal,
    			{
    				container: 0,
    				Item: 2,
    				isVirtualList: 3,
    				items: 4,
    				getOptionLabel: 5,
    				getGroupHeaderLabel: 6,
    				itemHeight: 7,
    				hoverItemIndex: 1,
    				selectedValue: 8,
    				optionIdentifier: 9,
    				hideEmptyState: 10,
    				noOptionsMessage: 11,
    				isMulti: 17,
    				activeItemIndex: 16,
    				filterText: 12
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "List",
    			options,
    			id: create_fragment$u.name
    		});
    	}

    	get container() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hoverItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hoverItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeItemIndex() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeItemIndex(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\Selection.svelte generated by Svelte v3.32.3 */

    const file$p = "node_modules\\svelte-select\\src\\Selection.svelte";

    function create_fragment$v(ctx) {
    	let div;
    	let raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "";

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "selection svelte-ch6bh7");
    			add_location(div, file$p, 13, 0, 210);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			div.innerHTML = raw_value;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*getSelectionLabel, item*/ 3 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[0](/*item*/ ctx[1]) + "")) div.innerHTML = raw_value;		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Selection", slots, []);
    	let { getSelectionLabel = undefined } = $$props;
    	let { item = undefined } = $$props;
    	const writable_props = ["getSelectionLabel", "item"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Selection> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("getSelectionLabel" in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    	};

    	$$self.$capture_state = () => ({ getSelectionLabel, item });

    	$$self.$inject_state = $$props => {
    		if ("getSelectionLabel" in $$props) $$invalidate(0, getSelectionLabel = $$props.getSelectionLabel);
    		if ("item" in $$props) $$invalidate(1, item = $$props.item);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [getSelectionLabel, item];
    }

    class Selection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, { getSelectionLabel: 0, item: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Selection",
    			options,
    			id: create_fragment$v.name
    		});
    	}

    	get getSelectionLabel() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get item() {
    		throw new Error("<Selection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set item(value) {
    		throw new Error("<Selection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-select\src\MultiSelection.svelte generated by Svelte v3.32.3 */
    const file$q = "node_modules\\svelte-select\\src\\MultiSelection.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (23:2) {#if !isDisabled && !multiFullItemClearable}
    function create_if_block$e(ctx) {
    	let div;
    	let svg;
    	let path;
    	let mounted;
    	let dispose;

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[6](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124 l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$q, 25, 6, 950);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "role", "presentation");
    			attr_dev(svg, "class", "svelte-14r1jr2");
    			add_location(svg, file$q, 24, 4, 851);
    			attr_dev(div, "class", "multiSelectItem_clear svelte-14r1jr2");
    			add_location(div, file$q, 23, 2, 767);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, path);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(23:2) {#if !isDisabled && !multiFullItemClearable}",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#each selectedValue as value, i}
    function create_each_block$b(ctx) {
    	let div1;
    	let div0;
    	let raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "";
    	let t0;
    	let t1;
    	let div1_class_value;
    	let mounted;
    	let dispose;
    	let if_block = !/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3] && create_if_block$e(ctx);

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[7](/*i*/ ctx[11], ...args);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			attr_dev(div0, "class", "multiSelectItem_label svelte-14r1jr2");
    			add_location(div0, file$q, 19, 2, 636);

    			attr_dev(div1, "class", div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
    			? "active"
    			: "") + " " + (/*isDisabled*/ ctx[2] ? "disabled" : "") + " svelte-14r1jr2");

    			add_location(div1, file$q, 18, 0, 457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			append_dev(div1, t0);
    			if (if_block) if_block.m(div1, null);
    			append_dev(div1, t1);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*getSelectionLabel, selectedValue*/ 17 && raw_value !== (raw_value = /*getSelectionLabel*/ ctx[4](/*value*/ ctx[9]) + "")) div0.innerHTML = raw_value;
    			if (!/*isDisabled*/ ctx[2] && !/*multiFullItemClearable*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					if_block.m(div1, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*activeSelectedValue, isDisabled*/ 6 && div1_class_value !== (div1_class_value = "multiSelectItem " + (/*activeSelectedValue*/ ctx[1] === /*i*/ ctx[11]
    			? "active"
    			: "") + " " + (/*isDisabled*/ ctx[2] ? "disabled" : "") + " svelte-14r1jr2")) {
    				attr_dev(div1, "class", div1_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(18:0) {#each selectedValue as value, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let each_1_anchor;
    	let each_value = /*selectedValue*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*activeSelectedValue, isDisabled, multiFullItemClearable, handleClear, getSelectionLabel, selectedValue*/ 63) {
    				each_value = /*selectedValue*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MultiSelection", slots, []);
    	const dispatch = createEventDispatcher();
    	let { selectedValue = [] } = $$props;
    	let { activeSelectedValue = undefined } = $$props;
    	let { isDisabled = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { getSelectionLabel = undefined } = $$props;

    	function handleClear(i, event) {
    		event.stopPropagation();
    		dispatch("multiItemClear", { i });
    	}

    	const writable_props = [
    		"selectedValue",
    		"activeSelectedValue",
    		"isDisabled",
    		"multiFullItemClearable",
    		"getSelectionLabel"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MultiSelection> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (i, event) => handleClear(i, event);
    	const click_handler_1 = (i, event) => multiFullItemClearable ? handleClear(i, event) : {};

    	$$self.$$set = $$props => {
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("activeSelectedValue" in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
    		if ("isDisabled" in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ("multiFullItemClearable" in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("getSelectionLabel" in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		dispatch,
    		selectedValue,
    		activeSelectedValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear
    	});

    	$$self.$inject_state = $$props => {
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("activeSelectedValue" in $$props) $$invalidate(1, activeSelectedValue = $$props.activeSelectedValue);
    		if ("isDisabled" in $$props) $$invalidate(2, isDisabled = $$props.isDisabled);
    		if ("multiFullItemClearable" in $$props) $$invalidate(3, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("getSelectionLabel" in $$props) $$invalidate(4, getSelectionLabel = $$props.getSelectionLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selectedValue,
    		activeSelectedValue,
    		isDisabled,
    		multiFullItemClearable,
    		getSelectionLabel,
    		handleClear,
    		click_handler,
    		click_handler_1
    	];
    }

    class MultiSelection extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
    			selectedValue: 0,
    			activeSelectedValue: 1,
    			isDisabled: 2,
    			multiFullItemClearable: 3,
    			getSelectionLabel: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MultiSelection",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get selectedValue() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get activeSelectedValue() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set activeSelectedValue(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<MultiSelection>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<MultiSelection>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function isOutOfViewport(elem) {
      const bounding = elem.getBoundingClientRect();
      const out = {};

      out.top = bounding.top < 0;
      out.left = bounding.left < 0;
      out.bottom = bounding.bottom > (window.innerHeight || document.documentElement.clientHeight);
      out.right = bounding.right > (window.innerWidth || document.documentElement.clientWidth);
      out.any = out.top || out.left || out.bottom || out.right;

      return out;
    }

    function debounce(func, wait, immediate) {
      let timeout;

      return function executedFunction() {
        let context = this;
        let args = arguments;

        let later = function() {
          timeout = null;
          if (!immediate) func.apply(context, args);
        };

        let callNow = immediate && !timeout;

        clearTimeout(timeout);

        timeout = setTimeout(later, wait);

        if (callNow) func.apply(context, args);
      };
    }

    /* node_modules\svelte-select\src\ClearIcon.svelte generated by Svelte v3.32.3 */

    const file$r = "node_modules\\svelte-select\\src\\ClearIcon.svelte";

    function create_fragment$x(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "fill", "currentColor");
    			attr_dev(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
    			add_location(path, file$r, 7, 2, 108);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "-2 -2 50 50");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "role", "presentation");
    			add_location(svg, file$r, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ClearIcon", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ClearIcon> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class ClearIcon extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ClearIcon",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* node_modules\svelte-select\src\Select.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$8, console: console_1$7 } = globals;
    const file$s = "node_modules\\svelte-select\\src\\Select.svelte";

    // (827:2) {#if Icon}
    function create_if_block_7$1(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*iconProps*/ ctx[18]];
    	var switch_value = /*Icon*/ ctx[17];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty[0] & /*iconProps*/ 262144)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*iconProps*/ ctx[18])])
    			: {};

    			if (switch_value !== (switch_value = /*Icon*/ ctx[17])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(827:2) {#if Icon}",
    		ctx
    	});

    	return block;
    }

    // (831:2) {#if isMulti && selectedValue && selectedValue.length > 0}
    function create_if_block_6(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*MultiSelection*/ ctx[7];

    	function switch_props(ctx) {
    		return {
    			props: {
    				selectedValue: /*selectedValue*/ ctx[0],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[13],
    				activeSelectedValue: /*activeSelectedValue*/ ctx[25],
    				isDisabled: /*isDisabled*/ ctx[10],
    				multiFullItemClearable: /*multiFullItemClearable*/ ctx[9]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
    		switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.selectedValue = /*selectedValue*/ ctx[0];
    			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];
    			if (dirty[0] & /*activeSelectedValue*/ 33554432) switch_instance_changes.activeSelectedValue = /*activeSelectedValue*/ ctx[25];
    			if (dirty[0] & /*isDisabled*/ 1024) switch_instance_changes.isDisabled = /*isDisabled*/ ctx[10];
    			if (dirty[0] & /*multiFullItemClearable*/ 512) switch_instance_changes.multiFullItemClearable = /*multiFullItemClearable*/ ctx[9];

    			if (switch_value !== (switch_value = /*MultiSelection*/ ctx[7])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					switch_instance.$on("multiItemClear", /*handleMultiItemClear*/ ctx[29]);
    					switch_instance.$on("focus", /*handleFocus*/ ctx[32]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(831:2) {#if isMulti && selectedValue && selectedValue.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (852:2) {:else}
    function create_else_block_1$3(ctx) {
    	let input_1;
    	let mounted;
    	let dispose;

    	let input_1_levels = [
    		/*_inputAttributes*/ ctx[26],
    		{ placeholder: /*placeholderText*/ ctx[28] },
    		{ style: /*inputStyles*/ ctx[15] }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign(input_1_data, input_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-17qb5ew", true);
    			add_location(input_1, file$s, 852, 4, 21497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding_1*/ ctx[63](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler_1*/ ctx[64])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
    				dirty[0] & /*placeholderText*/ 268435456 && { placeholder: /*placeholderText*/ ctx[28] },
    				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] }
    			]));

    			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
    				set_input_value(input_1, /*filterText*/ ctx[1]);
    			}

    			toggle_class(input_1, "svelte-17qb5ew", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding_1*/ ctx[63](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(852:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (843:2) {#if isDisabled}
    function create_if_block_5$2(ctx) {
    	let input_1;
    	let mounted;
    	let dispose;

    	let input_1_levels = [
    		/*_inputAttributes*/ ctx[26],
    		{ placeholder: /*placeholderText*/ ctx[28] },
    		{ style: /*inputStyles*/ ctx[15] },
    		{ disabled: true }
    	];

    	let input_1_data = {};

    	for (let i = 0; i < input_1_levels.length; i += 1) {
    		input_1_data = assign(input_1_data, input_1_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			set_attributes(input_1, input_1_data);
    			toggle_class(input_1, "svelte-17qb5ew", true);
    			add_location(input_1, file$s, 843, 4, 21285);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[61](input_1);
    			set_input_value(input_1, /*filterText*/ ctx[1]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "focus", /*handleFocus*/ ctx[32], false, false, false),
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[62])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			set_attributes(input_1, input_1_data = get_spread_update(input_1_levels, [
    				dirty[0] & /*_inputAttributes*/ 67108864 && /*_inputAttributes*/ ctx[26],
    				dirty[0] & /*placeholderText*/ 268435456 && { placeholder: /*placeholderText*/ ctx[28] },
    				dirty[0] & /*inputStyles*/ 32768 && { style: /*inputStyles*/ ctx[15] },
    				{ disabled: true }
    			]));

    			if (dirty[0] & /*filterText*/ 2 && input_1.value !== /*filterText*/ ctx[1]) {
    				set_input_value(input_1, /*filterText*/ ctx[1]);
    			}

    			toggle_class(input_1, "svelte-17qb5ew", true);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[61](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(843:2) {#if isDisabled}",
    		ctx
    	});

    	return block;
    }

    // (862:2) {#if !isMulti && showSelectedItem}
    function create_if_block_4$3(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*Selection*/ ctx[6];

    	function switch_props(ctx) {
    		return {
    			props: {
    				item: /*selectedValue*/ ctx[0],
    				getSelectionLabel: /*getSelectionLabel*/ ctx[13]
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "selectedItem svelte-17qb5ew");
    			add_location(div, file$s, 862, 4, 21730);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "focus", /*handleFocus*/ ctx[32], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty[0] & /*selectedValue*/ 1) switch_instance_changes.item = /*selectedValue*/ ctx[0];
    			if (dirty[0] & /*getSelectionLabel*/ 8192) switch_instance_changes.getSelectionLabel = /*getSelectionLabel*/ ctx[13];

    			if (switch_value !== (switch_value = /*Selection*/ ctx[6])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(862:2) {#if !isMulti && showSelectedItem}",
    		ctx
    	});

    	return block;
    }

    // (871:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}
    function create_if_block_3$5(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	let mounted;
    	let dispose;
    	var switch_value = /*ClearIcon*/ ctx[23];

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "clearSelect svelte-17qb5ew");
    			add_location(div, file$s, 871, 4, 21982);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", prevent_default(/*handleClear*/ ctx[24]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = /*ClearIcon*/ ctx[23])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(871:2) {#if showSelectedItem && isClearable && !isDisabled && !isWaiting}",
    		ctx
    	});

    	return block;
    }

    // (877:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}
    function create_if_block_1$8(ctx) {
    	let div;

    	function select_block_type_1(ctx, dirty) {
    		if (/*indicatorSvg*/ ctx[22]) return create_if_block_2$5;
    		return create_else_block$a;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "indicator svelte-17qb5ew");
    			add_location(div, file$s, 877, 4, 22281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_block.m(div, null);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div, null);
    				}
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(877:2) {#if showIndicator || (showChevron && !selectedValue || (!isSearchable && !isDisabled && !isWaiting && ((showSelectedItem && !isClearable) || !showSelectedItem)))}",
    		ctx
    	});

    	return block;
    }

    // (881:6) {:else}
    function create_else_block$a(ctx) {
    	let svg;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n            3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n            1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n            0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n            0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
    			add_location(path, file$s, 886, 10, 22502);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "100%");
    			attr_dev(svg, "viewBox", "0 0 20 20");
    			attr_dev(svg, "focusable", "false");
    			attr_dev(svg, "class", "svelte-17qb5ew");
    			add_location(svg, file$s, 881, 8, 22381);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, path);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(881:6) {:else}",
    		ctx
    	});

    	return block;
    }

    // (879:6) {#if indicatorSvg}
    function create_if_block_2$5(ctx) {
    	let html_tag;
    	let html_anchor;

    	const block = {
    		c: function create() {
    			html_anchor = empty();
    			html_tag = new HtmlTag(html_anchor);
    		},
    		m: function mount(target, anchor) {
    			html_tag.m(/*indicatorSvg*/ ctx[22], target, anchor);
    			insert_dev(target, html_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*indicatorSvg*/ 4194304) html_tag.p(/*indicatorSvg*/ ctx[22]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(html_anchor);
    			if (detaching) html_tag.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(879:6) {#if indicatorSvg}",
    		ctx
    	});

    	return block;
    }

    // (898:2) {#if isWaiting}
    function create_if_block$f(ctx) {
    	let div;
    	let svg;
    	let circle;

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			circle = svg_element("circle");
    			attr_dev(circle, "class", "spinner_path svelte-17qb5ew");
    			attr_dev(circle, "cx", "50");
    			attr_dev(circle, "cy", "50");
    			attr_dev(circle, "r", "20");
    			attr_dev(circle, "fill", "none");
    			attr_dev(circle, "stroke", "currentColor");
    			attr_dev(circle, "stroke-width", "5");
    			attr_dev(circle, "stroke-miterlimit", "10");
    			add_location(circle, file$s, 900, 8, 23007);
    			attr_dev(svg, "class", "spinner_icon svelte-17qb5ew");
    			attr_dev(svg, "viewBox", "25 25 50 50");
    			add_location(svg, file$s, 899, 6, 22950);
    			attr_dev(div, "class", "spinner svelte-17qb5ew");
    			add_location(div, file$s, 898, 4, 22922);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, circle);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(898:2) {#if isWaiting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*Icon*/ ctx[17] && create_if_block_7$1(ctx);
    	let if_block1 = /*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0 && create_if_block_6(ctx);

    	function select_block_type(ctx, dirty) {
    		if (/*isDisabled*/ ctx[10]) return create_if_block_5$2;
    		return create_else_block_1$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block2 = current_block_type(ctx);
    	let if_block3 = !/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[27] && create_if_block_4$3(ctx);
    	let if_block4 = /*showSelectedItem*/ ctx[27] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && create_if_block_3$5(ctx);
    	let if_block5 = (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[27] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[27]))) && create_if_block_1$8(ctx);
    	let if_block6 = /*isWaiting*/ ctx[5] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			attr_dev(div, "class", div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17qb5ew");
    			attr_dev(div, "style", /*containerStyles*/ ctx[12]);
    			toggle_class(div, "hasError", /*hasError*/ ctx[11]);
    			toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
    			toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
    			toggle_class(div, "focused", /*isFocused*/ ctx[4]);
    			add_location(div, file$s, 816, 0, 20631);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t5);
    			if (if_block6) if_block6.m(div, null);
    			/*div_binding*/ ctx[65](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "click", /*handleWindowClick*/ ctx[33], false, false, false),
    					listen_dev(window, "keydown", /*handleKeyDown*/ ctx[31], false, false, false),
    					listen_dev(window, "resize", /*getPosition*/ ctx[30], false, false, false),
    					listen_dev(div, "click", /*handleClick*/ ctx[34], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*Icon*/ ctx[17]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*Icon*/ 131072) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isMulti*/ ctx[8] && /*selectedValue*/ ctx[0] && /*selectedValue*/ ctx[0].length > 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, selectedValue*/ 257) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block2) {
    				if_block2.p(ctx, dirty);
    			} else {
    				if_block2.d(1);
    				if_block2 = current_block_type(ctx);

    				if (if_block2) {
    					if_block2.c();
    					if_block2.m(div, t2);
    				}
    			}

    			if (!/*isMulti*/ ctx[8] && /*showSelectedItem*/ ctx[27]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty[0] & /*isMulti, showSelectedItem*/ 134217984) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_4$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*showSelectedItem*/ ctx[27] && /*isClearable*/ ctx[16] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*showSelectedItem, isClearable, isDisabled, isWaiting*/ 134284320) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_3$5(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*showIndicator*/ ctx[20] || (/*showChevron*/ ctx[19] && !/*selectedValue*/ ctx[0] || !/*isSearchable*/ ctx[14] && !/*isDisabled*/ ctx[10] && !/*isWaiting*/ ctx[5] && (/*showSelectedItem*/ ctx[27] && !/*isClearable*/ ctx[16] || !/*showSelectedItem*/ ctx[27]))) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);
    				} else {
    					if_block5 = create_if_block_1$8(ctx);
    					if_block5.c();
    					if_block5.m(div, t5);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*isWaiting*/ ctx[5]) {
    				if (if_block6) ; else {
    					if_block6 = create_if_block$f(ctx);
    					if_block6.c();
    					if_block6.m(div, null);
    				}
    			} else if (if_block6) {
    				if_block6.d(1);
    				if_block6 = null;
    			}

    			if (!current || dirty[0] & /*containerClasses*/ 2097152 && div_class_value !== (div_class_value = "selectContainer " + /*containerClasses*/ ctx[21] + " svelte-17qb5ew")) {
    				attr_dev(div, "class", div_class_value);
    			}

    			if (!current || dirty[0] & /*containerStyles*/ 4096) {
    				attr_dev(div, "style", /*containerStyles*/ ctx[12]);
    			}

    			if (dirty[0] & /*containerClasses, hasError*/ 2099200) {
    				toggle_class(div, "hasError", /*hasError*/ ctx[11]);
    			}

    			if (dirty[0] & /*containerClasses, isMulti*/ 2097408) {
    				toggle_class(div, "multiSelect", /*isMulti*/ ctx[8]);
    			}

    			if (dirty[0] & /*containerClasses, isDisabled*/ 2098176) {
    				toggle_class(div, "disabled", /*isDisabled*/ ctx[10]);
    			}

    			if (dirty[0] & /*containerClasses, isFocused*/ 2097168) {
    				toggle_class(div, "focused", /*isFocused*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			/*div_binding*/ ctx[65](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let disabled;
    	let showSelectedItem;
    	let placeholderText;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Select", slots, []);
    	const dispatch = createEventDispatcher();
    	let { container = undefined } = $$props;
    	let { input = undefined } = $$props;
    	let { Item: Item$1 = Item } = $$props;
    	let { Selection: Selection$1 = Selection } = $$props;
    	let { MultiSelection: MultiSelection$1 = MultiSelection } = $$props;
    	let { isMulti = false } = $$props;
    	let { multiFullItemClearable = false } = $$props;
    	let { isDisabled = false } = $$props;
    	let { isCreatable = false } = $$props;
    	let { isFocused = false } = $$props;
    	let { selectedValue = undefined } = $$props;
    	let { filterText = "" } = $$props;
    	let { placeholder = "Select..." } = $$props;
    	let { items = [] } = $$props;
    	let { itemFilter = (label, filterText, option) => label.toLowerCase().includes(filterText.toLowerCase()) } = $$props;
    	let { groupBy = undefined } = $$props;
    	let { groupFilter = groups => groups } = $$props;
    	let { isGroupHeaderSelectable = false } = $$props;

    	let { getGroupHeaderLabel = option => {
    		return option.label;
    	} } = $$props;

    	let { getOptionLabel = (option, filterText) => {
    		return option.isCreator
    		? `Create \"${filterText}\"`
    		: option.label;
    	} } = $$props;

    	let { optionIdentifier = "value" } = $$props;
    	let { loadOptions = undefined } = $$props;
    	let { hasError = false } = $$props;
    	let { containerStyles = "" } = $$props;

    	let { getSelectionLabel = option => {
    		if (option) return option.label;
    	} } = $$props;

    	let { createGroupHeaderItem = groupValue => {
    		return { value: groupValue, label: groupValue };
    	} } = $$props;

    	let { createItem = filterText => {
    		return { value: filterText, label: filterText };
    	} } = $$props;

    	let { isSearchable = true } = $$props;
    	let { inputStyles = "" } = $$props;
    	let { isClearable = true } = $$props;
    	let { isWaiting = false } = $$props;
    	let { listPlacement = "auto" } = $$props;
    	let { listOpen = false } = $$props;
    	let { list = undefined } = $$props;
    	let { isVirtualList = false } = $$props;
    	let { loadOptionsInterval = 300 } = $$props;
    	let { noOptionsMessage = "No options" } = $$props;
    	let { hideEmptyState = false } = $$props;
    	let { filteredItems = [] } = $$props;
    	let { inputAttributes = {} } = $$props;
    	let { listAutoWidth = true } = $$props;
    	let { itemHeight = 40 } = $$props;
    	let { Icon = undefined } = $$props;
    	let { iconProps = {} } = $$props;
    	let { showChevron = false } = $$props;
    	let { showIndicator = false } = $$props;
    	let { containerClasses = "" } = $$props;
    	let { indicatorSvg = undefined } = $$props;
    	let { ClearIcon: ClearIcon$1 = ClearIcon } = $$props;
    	let target;
    	let activeSelectedValue;
    	let _items = [];
    	let originalItemsClone;
    	let prev_selectedValue;
    	let prev_listOpen;
    	let prev_filterText;
    	let prev_isFocused;
    	let prev_filteredItems;

    	async function resetFilter() {
    		await tick();
    		$$invalidate(1, filterText = "");
    	}

    	let getItemsHasInvoked = false;

    	const getItems = debounce(
    		async () => {
    			getItemsHasInvoked = true;
    			$$invalidate(5, isWaiting = true);

    			let res = await loadOptions(filterText).catch(err => {
    				console.warn("svelte-select loadOptions error :>> ", err);
    				dispatch("error", { type: "loadOptions", details: err });
    			});

    			if (res && !res.cancelled) {
    				if (res) {
    					$$invalidate(35, items = [...res]);
    					dispatch("loaded", { items });
    				} else {
    					$$invalidate(35, items = []);
    				}

    				$$invalidate(5, isWaiting = false);
    				$$invalidate(4, isFocused = true);
    				$$invalidate(37, listOpen = true);
    			}
    		},
    		loadOptionsInterval
    	);

    	let _inputAttributes = {};

    	beforeUpdate(() => {
    		if (isMulti && selectedValue && selectedValue.length > 1) {
    			checkSelectedValueForDuplicates();
    		}

    		if (!isMulti && selectedValue && prev_selectedValue !== selectedValue) {
    			if (!prev_selectedValue || JSON.stringify(selectedValue[optionIdentifier]) !== JSON.stringify(prev_selectedValue[optionIdentifier])) {
    				dispatch("select", selectedValue);
    			}
    		}

    		if (isMulti && JSON.stringify(selectedValue) !== JSON.stringify(prev_selectedValue)) {
    			if (checkSelectedValueForDuplicates()) {
    				dispatch("select", selectedValue);
    			}
    		}

    		if (container && listOpen !== prev_listOpen) {
    			if (listOpen) {
    				loadList();
    			} else {
    				removeList();
    			}
    		}

    		if (filterText !== prev_filterText) {
    			if (filterText.length > 0) {
    				$$invalidate(4, isFocused = true);
    				$$invalidate(37, listOpen = true);

    				if (loadOptions) {
    					getItems();
    				} else {
    					loadList();
    					$$invalidate(37, listOpen = true);

    					if (isMulti) {
    						$$invalidate(25, activeSelectedValue = undefined);
    					}
    				}
    			} else {
    				setList([]);
    			}

    			if (list) {
    				list.$set({ filterText });
    			}
    		}

    		if (isFocused !== prev_isFocused) {
    			if (isFocused || listOpen) {
    				handleFocus();
    			} else {
    				resetFilter();
    				if (input) input.blur();
    			}
    		}

    		if (prev_filteredItems !== filteredItems) {
    			let _filteredItems = [...filteredItems];

    			if (isCreatable && filterText) {
    				const itemToCreate = createItem(filterText);
    				itemToCreate.isCreator = true;

    				const existingItemWithFilterValue = _filteredItems.find(item => {
    					return item[optionIdentifier] === itemToCreate[optionIdentifier];
    				});

    				let existingSelectionWithFilterValue;

    				if (selectedValue) {
    					if (isMulti) {
    						existingSelectionWithFilterValue = selectedValue.find(selection => {
    							return selection[optionIdentifier] === itemToCreate[optionIdentifier];
    						});
    					} else if (selectedValue[optionIdentifier] === itemToCreate[optionIdentifier]) {
    						existingSelectionWithFilterValue = selectedValue;
    					}
    				}

    				if (!existingItemWithFilterValue && !existingSelectionWithFilterValue) {
    					_filteredItems = [..._filteredItems, itemToCreate];
    				}
    			}

    			setList(_filteredItems);
    		}

    		prev_selectedValue = selectedValue;
    		prev_listOpen = listOpen;
    		prev_filterText = filterText;
    		prev_isFocused = isFocused;
    		prev_filteredItems = filteredItems;
    	});

    	function checkSelectedValueForDuplicates() {
    		let noDuplicates = true;

    		if (selectedValue) {
    			const ids = [];
    			const uniqueValues = [];

    			selectedValue.forEach(val => {
    				if (!ids.includes(val[optionIdentifier])) {
    					ids.push(val[optionIdentifier]);
    					uniqueValues.push(val);
    				} else {
    					noDuplicates = false;
    				}
    			});

    			if (!noDuplicates) $$invalidate(0, selectedValue = uniqueValues);
    		}

    		return noDuplicates;
    	}

    	function findItem(selection) {
    		let matchTo = selection
    		? selection[optionIdentifier]
    		: selectedValue[optionIdentifier];

    		return items.find(item => item[optionIdentifier] === matchTo);
    	}

    	function updateSelectedValueDisplay(items) {
    		if (!items || items.length === 0 || items.some(item => typeof item !== "object")) return;

    		if (!selectedValue || (isMulti
    		? selectedValue.some(selection => !selection || !selection[optionIdentifier])
    		: !selectedValue[optionIdentifier])) return;

    		if (Array.isArray(selectedValue)) {
    			$$invalidate(0, selectedValue = selectedValue.map(selection => findItem(selection) || selection));
    		} else {
    			$$invalidate(0, selectedValue = findItem() || selectedValue);
    		}
    	}

    	async function setList(items) {
    		await tick();
    		if (!listOpen) return;
    		if (list) return list.$set({ items });
    		if (loadOptions && getItemsHasInvoked && items.length > 0) loadList();
    	}

    	function handleMultiItemClear(event) {
    		const { detail } = event;
    		const itemToRemove = selectedValue[detail ? detail.i : selectedValue.length - 1];

    		if (selectedValue.length === 1) {
    			$$invalidate(0, selectedValue = undefined);
    		} else {
    			$$invalidate(0, selectedValue = selectedValue.filter(item => {
    				return item !== itemToRemove;
    			}));
    		}

    		dispatch("clear", itemToRemove);
    		getPosition();
    	}

    	async function getPosition() {
    		await tick();
    		if (!target || !container) return;
    		const { top, height, width } = container.getBoundingClientRect();
    		target.style["min-width"] = `${width}px`;
    		target.style.width = `${listAutoWidth ? "auto" : "100%"}`;
    		target.style.left = "0";

    		if (listPlacement === "top") {
    			target.style.bottom = `${height + 5}px`;
    		} else {
    			target.style.top = `${height + 5}px`;
    		}

    		target = target;

    		if (listPlacement === "auto" && isOutOfViewport(target).bottom) {
    			target.style.top = ``;
    			target.style.bottom = `${height + 5}px`;
    		}

    		target.style.visibility = "";
    	}

    	function handleKeyDown(e) {
    		if (!isFocused) return;

    		switch (e.key) {
    			case "ArrowDown":
    				e.preventDefault();
    				$$invalidate(37, listOpen = true);
    				$$invalidate(25, activeSelectedValue = undefined);
    				break;
    			case "ArrowUp":
    				e.preventDefault();
    				$$invalidate(37, listOpen = true);
    				$$invalidate(25, activeSelectedValue = undefined);
    				break;
    			case "Tab":
    				if (!listOpen) $$invalidate(4, isFocused = false);
    				break;
    			case "Backspace":
    				if (!isMulti || filterText.length > 0) return;
    				if (isMulti && selectedValue && selectedValue.length > 0) {
    					handleMultiItemClear(activeSelectedValue !== undefined
    					? activeSelectedValue
    					: selectedValue.length - 1);

    					if (activeSelectedValue === 0 || activeSelectedValue === undefined) break;

    					$$invalidate(25, activeSelectedValue = selectedValue.length > activeSelectedValue
    					? activeSelectedValue - 1
    					: undefined);
    				}
    				break;
    			case "ArrowLeft":
    				if (list) list.$set({ hoverItemIndex: -1 });
    				if (!isMulti || filterText.length > 0) return;
    				if (activeSelectedValue === undefined) {
    					$$invalidate(25, activeSelectedValue = selectedValue.length - 1);
    				} else if (selectedValue.length > activeSelectedValue && activeSelectedValue !== 0) {
    					$$invalidate(25, activeSelectedValue -= 1);
    				}
    				break;
    			case "ArrowRight":
    				if (list) list.$set({ hoverItemIndex: -1 });
    				if (!isMulti || filterText.length > 0 || activeSelectedValue === undefined) return;
    				if (activeSelectedValue === selectedValue.length - 1) {
    					$$invalidate(25, activeSelectedValue = undefined);
    				} else if (activeSelectedValue < selectedValue.length - 1) {
    					$$invalidate(25, activeSelectedValue += 1);
    				}
    				break;
    		}
    	}

    	function handleFocus() {
    		$$invalidate(4, isFocused = true);
    		if (input) input.focus();
    	}

    	function removeList() {
    		resetFilter();
    		$$invalidate(25, activeSelectedValue = undefined);
    		if (!list) return;
    		list.$destroy();
    		$$invalidate(36, list = undefined);
    		if (!target) return;
    		if (target.parentNode) target.parentNode.removeChild(target);
    		target = undefined;
    		$$invalidate(36, list);
    		target = target;
    	}

    	function handleWindowClick(event) {
    		if (!container) return;

    		const eventTarget = event.path && event.path.length > 0
    		? event.path[0]
    		: event.target;

    		if (container.contains(eventTarget)) return;
    		$$invalidate(4, isFocused = false);
    		$$invalidate(37, listOpen = false);
    		$$invalidate(25, activeSelectedValue = undefined);
    		if (input) input.blur();
    	}

    	function handleClick() {
    		if (isDisabled) return;
    		$$invalidate(4, isFocused = true);
    		$$invalidate(37, listOpen = !listOpen);
    	}

    	function handleClear() {
    		$$invalidate(0, selectedValue = undefined);
    		$$invalidate(37, listOpen = false);
    		dispatch("clear", selectedValue);
    		handleFocus();
    	}

    	async function loadList() {
    		await tick();
    		if (target && list) return;

    		const data = {
    			Item: Item$1,
    			filterText,
    			optionIdentifier,
    			noOptionsMessage,
    			hideEmptyState,
    			isVirtualList,
    			selectedValue,
    			isMulti,
    			getGroupHeaderLabel,
    			items: filteredItems,
    			itemHeight
    		};

    		if (getOptionLabel) {
    			data.getOptionLabel = getOptionLabel;
    		}

    		target = document.createElement("div");

    		Object.assign(target.style, {
    			position: "absolute",
    			"z-index": 2,
    			visibility: "hidden"
    		});

    		$$invalidate(36, list);
    		target = target;
    		if (container) container.appendChild(target);
    		$$invalidate(36, list = new List({ target, props: data }));

    		list.$on("itemSelected", event => {
    			const { detail } = event;

    			if (detail) {
    				const item = Object.assign({}, detail);

    				if (!item.isGroupHeader || item.isSelectable) {
    					if (isMulti) {
    						$$invalidate(0, selectedValue = selectedValue ? selectedValue.concat([item]) : [item]);
    					} else {
    						$$invalidate(0, selectedValue = item);
    					}

    					resetFilter();
    					(($$invalidate(0, selectedValue), $$invalidate(48, optionIdentifier)), $$invalidate(8, isMulti));

    					setTimeout(() => {
    						$$invalidate(37, listOpen = false);
    						$$invalidate(25, activeSelectedValue = undefined);
    					});
    				}
    			}
    		});

    		list.$on("itemCreated", event => {
    			const { detail } = event;

    			if (isMulti) {
    				$$invalidate(0, selectedValue = selectedValue || []);
    				$$invalidate(0, selectedValue = [...selectedValue, createItem(detail)]);
    			} else {
    				$$invalidate(0, selectedValue = createItem(detail));
    			}

    			dispatch("itemCreated", detail);
    			$$invalidate(1, filterText = "");
    			$$invalidate(37, listOpen = false);
    			$$invalidate(25, activeSelectedValue = undefined);
    			resetFilter();
    		});

    		list.$on("closeList", () => {
    			$$invalidate(37, listOpen = false);
    		});

    		($$invalidate(36, list), target = target);
    		getPosition();
    	}

    	onMount(() => {
    		if (isFocused) input.focus();
    		if (listOpen) loadList();

    		if (items && items.length > 0) {
    			$$invalidate(60, originalItemsClone = JSON.stringify(items));
    		}
    	});

    	onDestroy(() => {
    		removeList();
    	});

    	const writable_props = [
    		"container",
    		"input",
    		"Item",
    		"Selection",
    		"MultiSelection",
    		"isMulti",
    		"multiFullItemClearable",
    		"isDisabled",
    		"isCreatable",
    		"isFocused",
    		"selectedValue",
    		"filterText",
    		"placeholder",
    		"items",
    		"itemFilter",
    		"groupBy",
    		"groupFilter",
    		"isGroupHeaderSelectable",
    		"getGroupHeaderLabel",
    		"getOptionLabel",
    		"optionIdentifier",
    		"loadOptions",
    		"hasError",
    		"containerStyles",
    		"getSelectionLabel",
    		"createGroupHeaderItem",
    		"createItem",
    		"isSearchable",
    		"inputStyles",
    		"isClearable",
    		"isWaiting",
    		"listPlacement",
    		"listOpen",
    		"list",
    		"isVirtualList",
    		"loadOptionsInterval",
    		"noOptionsMessage",
    		"hideEmptyState",
    		"filteredItems",
    		"inputAttributes",
    		"listAutoWidth",
    		"itemHeight",
    		"Icon",
    		"iconProps",
    		"showChevron",
    		"showIndicator",
    		"containerClasses",
    		"indicatorSvg",
    		"ClearIcon"
    	];

    	Object_1$8.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(3, input);
    		});
    	}

    	function input_1_input_handler() {
    		filterText = this.value;
    		$$invalidate(1, filterText);
    	}

    	function input_1_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(3, input);
    		});
    	}

    	function input_1_input_handler_1() {
    		filterText = this.value;
    		$$invalidate(1, filterText);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			container = $$value;
    			$$invalidate(2, container);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("container" in $$props) $$invalidate(2, container = $$props.container);
    		if ("input" in $$props) $$invalidate(3, input = $$props.input);
    		if ("Item" in $$props) $$invalidate(39, Item$1 = $$props.Item);
    		if ("Selection" in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
    		if ("MultiSelection" in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
    		if ("isMulti" in $$props) $$invalidate(8, isMulti = $$props.isMulti);
    		if ("multiFullItemClearable" in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("isDisabled" in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
    		if ("isCreatable" in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
    		if ("isFocused" in $$props) $$invalidate(4, isFocused = $$props.isFocused);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("filterText" in $$props) $$invalidate(1, filterText = $$props.filterText);
    		if ("placeholder" in $$props) $$invalidate(41, placeholder = $$props.placeholder);
    		if ("items" in $$props) $$invalidate(35, items = $$props.items);
    		if ("itemFilter" in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
    		if ("groupBy" in $$props) $$invalidate(43, groupBy = $$props.groupBy);
    		if ("groupFilter" in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
    		if ("isGroupHeaderSelectable" in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("getOptionLabel" in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
    		if ("optionIdentifier" in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
    		if ("loadOptions" in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
    		if ("hasError" in $$props) $$invalidate(11, hasError = $$props.hasError);
    		if ("containerStyles" in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
    		if ("getSelectionLabel" in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
    		if ("createGroupHeaderItem" in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ("createItem" in $$props) $$invalidate(51, createItem = $$props.createItem);
    		if ("isSearchable" in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
    		if ("inputStyles" in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
    		if ("isClearable" in $$props) $$invalidate(16, isClearable = $$props.isClearable);
    		if ("isWaiting" in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
    		if ("listPlacement" in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
    		if ("listOpen" in $$props) $$invalidate(37, listOpen = $$props.listOpen);
    		if ("list" in $$props) $$invalidate(36, list = $$props.list);
    		if ("isVirtualList" in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
    		if ("loadOptionsInterval" in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ("noOptionsMessage" in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
    		if ("hideEmptyState" in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
    		if ("filteredItems" in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
    		if ("inputAttributes" in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
    		if ("listAutoWidth" in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
    		if ("itemHeight" in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
    		if ("Icon" in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ("iconProps" in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ("showChevron" in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ("showIndicator" in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ("containerClasses" in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ("indicatorSvg" in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ("ClearIcon" in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    	};

    	$$self.$capture_state = () => ({
    		beforeUpdate,
    		createEventDispatcher,
    		onDestroy,
    		onMount,
    		tick,
    		List,
    		ItemComponent: Item,
    		SelectionComponent: Selection,
    		MultiSelectionComponent: MultiSelection,
    		isOutOfViewport,
    		debounce,
    		DefaultClearIcon: ClearIcon,
    		dispatch,
    		container,
    		input,
    		Item: Item$1,
    		Selection: Selection$1,
    		MultiSelection: MultiSelection$1,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		isCreatable,
    		isFocused,
    		selectedValue,
    		filterText,
    		placeholder,
    		items,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		createGroupHeaderItem,
    		createItem,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		isWaiting,
    		listPlacement,
    		listOpen,
    		list,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		filteredItems,
    		inputAttributes,
    		listAutoWidth,
    		itemHeight,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon: ClearIcon$1,
    		target,
    		activeSelectedValue,
    		_items,
    		originalItemsClone,
    		prev_selectedValue,
    		prev_listOpen,
    		prev_filterText,
    		prev_isFocused,
    		prev_filteredItems,
    		resetFilter,
    		getItemsHasInvoked,
    		getItems,
    		_inputAttributes,
    		checkSelectedValueForDuplicates,
    		findItem,
    		updateSelectedValueDisplay,
    		setList,
    		handleMultiItemClear,
    		getPosition,
    		handleKeyDown,
    		handleFocus,
    		removeList,
    		handleWindowClick,
    		handleClick,
    		handleClear,
    		loadList,
    		disabled,
    		showSelectedItem,
    		placeholderText
    	});

    	$$self.$inject_state = $$props => {
    		if ("container" in $$props) $$invalidate(2, container = $$props.container);
    		if ("input" in $$props) $$invalidate(3, input = $$props.input);
    		if ("Item" in $$props) $$invalidate(39, Item$1 = $$props.Item);
    		if ("Selection" in $$props) $$invalidate(6, Selection$1 = $$props.Selection);
    		if ("MultiSelection" in $$props) $$invalidate(7, MultiSelection$1 = $$props.MultiSelection);
    		if ("isMulti" in $$props) $$invalidate(8, isMulti = $$props.isMulti);
    		if ("multiFullItemClearable" in $$props) $$invalidate(9, multiFullItemClearable = $$props.multiFullItemClearable);
    		if ("isDisabled" in $$props) $$invalidate(10, isDisabled = $$props.isDisabled);
    		if ("isCreatable" in $$props) $$invalidate(40, isCreatable = $$props.isCreatable);
    		if ("isFocused" in $$props) $$invalidate(4, isFocused = $$props.isFocused);
    		if ("selectedValue" in $$props) $$invalidate(0, selectedValue = $$props.selectedValue);
    		if ("filterText" in $$props) $$invalidate(1, filterText = $$props.filterText);
    		if ("placeholder" in $$props) $$invalidate(41, placeholder = $$props.placeholder);
    		if ("items" in $$props) $$invalidate(35, items = $$props.items);
    		if ("itemFilter" in $$props) $$invalidate(42, itemFilter = $$props.itemFilter);
    		if ("groupBy" in $$props) $$invalidate(43, groupBy = $$props.groupBy);
    		if ("groupFilter" in $$props) $$invalidate(44, groupFilter = $$props.groupFilter);
    		if ("isGroupHeaderSelectable" in $$props) $$invalidate(45, isGroupHeaderSelectable = $$props.isGroupHeaderSelectable);
    		if ("getGroupHeaderLabel" in $$props) $$invalidate(46, getGroupHeaderLabel = $$props.getGroupHeaderLabel);
    		if ("getOptionLabel" in $$props) $$invalidate(47, getOptionLabel = $$props.getOptionLabel);
    		if ("optionIdentifier" in $$props) $$invalidate(48, optionIdentifier = $$props.optionIdentifier);
    		if ("loadOptions" in $$props) $$invalidate(49, loadOptions = $$props.loadOptions);
    		if ("hasError" in $$props) $$invalidate(11, hasError = $$props.hasError);
    		if ("containerStyles" in $$props) $$invalidate(12, containerStyles = $$props.containerStyles);
    		if ("getSelectionLabel" in $$props) $$invalidate(13, getSelectionLabel = $$props.getSelectionLabel);
    		if ("createGroupHeaderItem" in $$props) $$invalidate(50, createGroupHeaderItem = $$props.createGroupHeaderItem);
    		if ("createItem" in $$props) $$invalidate(51, createItem = $$props.createItem);
    		if ("isSearchable" in $$props) $$invalidate(14, isSearchable = $$props.isSearchable);
    		if ("inputStyles" in $$props) $$invalidate(15, inputStyles = $$props.inputStyles);
    		if ("isClearable" in $$props) $$invalidate(16, isClearable = $$props.isClearable);
    		if ("isWaiting" in $$props) $$invalidate(5, isWaiting = $$props.isWaiting);
    		if ("listPlacement" in $$props) $$invalidate(52, listPlacement = $$props.listPlacement);
    		if ("listOpen" in $$props) $$invalidate(37, listOpen = $$props.listOpen);
    		if ("list" in $$props) $$invalidate(36, list = $$props.list);
    		if ("isVirtualList" in $$props) $$invalidate(53, isVirtualList = $$props.isVirtualList);
    		if ("loadOptionsInterval" in $$props) $$invalidate(54, loadOptionsInterval = $$props.loadOptionsInterval);
    		if ("noOptionsMessage" in $$props) $$invalidate(55, noOptionsMessage = $$props.noOptionsMessage);
    		if ("hideEmptyState" in $$props) $$invalidate(56, hideEmptyState = $$props.hideEmptyState);
    		if ("filteredItems" in $$props) $$invalidate(38, filteredItems = $$props.filteredItems);
    		if ("inputAttributes" in $$props) $$invalidate(57, inputAttributes = $$props.inputAttributes);
    		if ("listAutoWidth" in $$props) $$invalidate(58, listAutoWidth = $$props.listAutoWidth);
    		if ("itemHeight" in $$props) $$invalidate(59, itemHeight = $$props.itemHeight);
    		if ("Icon" in $$props) $$invalidate(17, Icon = $$props.Icon);
    		if ("iconProps" in $$props) $$invalidate(18, iconProps = $$props.iconProps);
    		if ("showChevron" in $$props) $$invalidate(19, showChevron = $$props.showChevron);
    		if ("showIndicator" in $$props) $$invalidate(20, showIndicator = $$props.showIndicator);
    		if ("containerClasses" in $$props) $$invalidate(21, containerClasses = $$props.containerClasses);
    		if ("indicatorSvg" in $$props) $$invalidate(22, indicatorSvg = $$props.indicatorSvg);
    		if ("ClearIcon" in $$props) $$invalidate(23, ClearIcon$1 = $$props.ClearIcon);
    		if ("target" in $$props) target = $$props.target;
    		if ("activeSelectedValue" in $$props) $$invalidate(25, activeSelectedValue = $$props.activeSelectedValue);
    		if ("_items" in $$props) $$invalidate(75, _items = $$props._items);
    		if ("originalItemsClone" in $$props) $$invalidate(60, originalItemsClone = $$props.originalItemsClone);
    		if ("prev_selectedValue" in $$props) prev_selectedValue = $$props.prev_selectedValue;
    		if ("prev_listOpen" in $$props) prev_listOpen = $$props.prev_listOpen;
    		if ("prev_filterText" in $$props) prev_filterText = $$props.prev_filterText;
    		if ("prev_isFocused" in $$props) prev_isFocused = $$props.prev_isFocused;
    		if ("prev_filteredItems" in $$props) prev_filteredItems = $$props.prev_filteredItems;
    		if ("getItemsHasInvoked" in $$props) getItemsHasInvoked = $$props.getItemsHasInvoked;
    		if ("_inputAttributes" in $$props) $$invalidate(26, _inputAttributes = $$props._inputAttributes);
    		if ("disabled" in $$props) disabled = $$props.disabled;
    		if ("showSelectedItem" in $$props) $$invalidate(27, showSelectedItem = $$props.showSelectedItem);
    		if ("placeholderText" in $$props) $$invalidate(28, placeholderText = $$props.placeholderText);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*isDisabled*/ 1024) {
    			disabled = isDisabled;
    		}

    		if ($$self.$$.dirty[1] & /*items*/ 16) {
    			updateSelectedValueDisplay(items);
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue, isMulti*/ 257 | $$self.$$.dirty[1] & /*optionIdentifier*/ 131072) {
    			{
    				if (typeof selectedValue === "string") {
    					$$invalidate(0, selectedValue = {
    						[optionIdentifier]: selectedValue,
    						label: selectedValue
    					});
    				} else if (isMulti && Array.isArray(selectedValue) && selectedValue.length > 0) {
    					$$invalidate(0, selectedValue = selectedValue.map(item => typeof item === "string"
    					? { value: item, label: item }
    					: item));
    				}
    			}
    		}

    		if ($$self.$$.dirty[1] & /*noOptionsMessage, list*/ 16777248) {
    			{
    				if (noOptionsMessage && list) list.$set({ noOptionsMessage });
    			}
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue, filterText*/ 3) {
    			$$invalidate(27, showSelectedItem = selectedValue && filterText.length === 0);
    		}

    		if ($$self.$$.dirty[0] & /*selectedValue*/ 1 | $$self.$$.dirty[1] & /*placeholder*/ 1024) {
    			$$invalidate(28, placeholderText = selectedValue ? "" : placeholder);
    		}

    		if ($$self.$$.dirty[0] & /*isSearchable*/ 16384 | $$self.$$.dirty[1] & /*inputAttributes*/ 67108864) {
    			{
    				$$invalidate(26, _inputAttributes = Object.assign(
    					{
    						autocomplete: "off",
    						autocorrect: "off",
    						spellcheck: false
    					},
    					inputAttributes
    				));

    				if (!isSearchable) {
    					$$invalidate(26, _inputAttributes.readonly = true, _inputAttributes);
    				}
    			}
    		}

    		if ($$self.$$.dirty[0] & /*filterText, isMulti, selectedValue*/ 259 | $$self.$$.dirty[1] & /*items, loadOptions, originalItemsClone, optionIdentifier, itemFilter, getOptionLabel, groupBy, createGroupHeaderItem, isGroupHeaderSelectable, groupFilter*/ 537884688) {
    			{
    				let _filteredItems;
    				let _items = items;

    				if (items && items.length > 0 && typeof items[0] !== "object") {
    					_items = items.map((item, index) => {
    						return { index, value: item, label: item };
    					});
    				}

    				if (loadOptions && filterText.length === 0 && originalItemsClone) {
    					_filteredItems = JSON.parse(originalItemsClone);
    					_items = JSON.parse(originalItemsClone);
    				} else {
    					_filteredItems = loadOptions
    					? filterText.length === 0 ? [] : _items
    					: _items.filter(item => {
    							let keepItem = true;

    							if (isMulti && selectedValue) {
    								keepItem = !selectedValue.some(value => {
    									return value[optionIdentifier] === item[optionIdentifier];
    								});
    							}

    							if (!keepItem) return false;
    							if (filterText.length < 1) return true;
    							return itemFilter(getOptionLabel(item, filterText), filterText, item);
    						});
    				}

    				if (groupBy) {
    					const groupValues = [];
    					const groups = {};

    					_filteredItems.forEach(item => {
    						const groupValue = groupBy(item);

    						if (!groupValues.includes(groupValue)) {
    							groupValues.push(groupValue);
    							groups[groupValue] = [];

    							if (groupValue) {
    								groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
    									id: groupValue,
    									isGroupHeader: true,
    									isSelectable: isGroupHeaderSelectable
    								}));
    							}
    						}

    						groups[groupValue].push(Object.assign({ isGroupItem: !!groupValue }, item));
    					});

    					const sortedGroupedItems = [];

    					groupFilter(groupValues).forEach(groupValue => {
    						sortedGroupedItems.push(...groups[groupValue]);
    					});

    					$$invalidate(38, filteredItems = sortedGroupedItems);
    				} else {
    					$$invalidate(38, filteredItems = _filteredItems);
    				}
    			}
    		}
    	};

    	return [
    		selectedValue,
    		filterText,
    		container,
    		input,
    		isFocused,
    		isWaiting,
    		Selection$1,
    		MultiSelection$1,
    		isMulti,
    		multiFullItemClearable,
    		isDisabled,
    		hasError,
    		containerStyles,
    		getSelectionLabel,
    		isSearchable,
    		inputStyles,
    		isClearable,
    		Icon,
    		iconProps,
    		showChevron,
    		showIndicator,
    		containerClasses,
    		indicatorSvg,
    		ClearIcon$1,
    		handleClear,
    		activeSelectedValue,
    		_inputAttributes,
    		showSelectedItem,
    		placeholderText,
    		handleMultiItemClear,
    		getPosition,
    		handleKeyDown,
    		handleFocus,
    		handleWindowClick,
    		handleClick,
    		items,
    		list,
    		listOpen,
    		filteredItems,
    		Item$1,
    		isCreatable,
    		placeholder,
    		itemFilter,
    		groupBy,
    		groupFilter,
    		isGroupHeaderSelectable,
    		getGroupHeaderLabel,
    		getOptionLabel,
    		optionIdentifier,
    		loadOptions,
    		createGroupHeaderItem,
    		createItem,
    		listPlacement,
    		isVirtualList,
    		loadOptionsInterval,
    		noOptionsMessage,
    		hideEmptyState,
    		inputAttributes,
    		listAutoWidth,
    		itemHeight,
    		originalItemsClone,
    		input_1_binding,
    		input_1_input_handler,
    		input_1_binding_1,
    		input_1_input_handler_1,
    		div_binding
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$y,
    			create_fragment$y,
    			safe_not_equal,
    			{
    				container: 2,
    				input: 3,
    				Item: 39,
    				Selection: 6,
    				MultiSelection: 7,
    				isMulti: 8,
    				multiFullItemClearable: 9,
    				isDisabled: 10,
    				isCreatable: 40,
    				isFocused: 4,
    				selectedValue: 0,
    				filterText: 1,
    				placeholder: 41,
    				items: 35,
    				itemFilter: 42,
    				groupBy: 43,
    				groupFilter: 44,
    				isGroupHeaderSelectable: 45,
    				getGroupHeaderLabel: 46,
    				getOptionLabel: 47,
    				optionIdentifier: 48,
    				loadOptions: 49,
    				hasError: 11,
    				containerStyles: 12,
    				getSelectionLabel: 13,
    				createGroupHeaderItem: 50,
    				createItem: 51,
    				isSearchable: 14,
    				inputStyles: 15,
    				isClearable: 16,
    				isWaiting: 5,
    				listPlacement: 52,
    				listOpen: 37,
    				list: 36,
    				isVirtualList: 53,
    				loadOptionsInterval: 54,
    				noOptionsMessage: 55,
    				hideEmptyState: 56,
    				filteredItems: 38,
    				inputAttributes: 57,
    				listAutoWidth: 58,
    				itemHeight: 59,
    				Icon: 17,
    				iconProps: 18,
    				showChevron: 19,
    				showIndicator: 20,
    				containerClasses: 21,
    				indicatorSvg: 22,
    				ClearIcon: 23,
    				handleClear: 24
    			},
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get container() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set container(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get input() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set input(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Item() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Item(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Selection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Selection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get MultiSelection() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set MultiSelection(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isMulti() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isMulti(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiFullItemClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiFullItemClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isCreatable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isCreatable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isFocused() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isFocused(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selectedValue() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selectedValue(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterText() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterText(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get placeholder() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set placeholder(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get items() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set items(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupBy() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupBy(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get groupFilter() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set groupFilter(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isGroupHeaderSelectable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isGroupHeaderSelectable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getGroupHeaderLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getGroupHeaderLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getOptionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getOptionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get optionIdentifier() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set optionIdentifier(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptions() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptions(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasError() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasError(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get getSelectionLabel() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set getSelectionLabel(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createGroupHeaderItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createGroupHeaderItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get createItem() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set createItem(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isSearchable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isSearchable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputStyles() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputStyles(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isClearable() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isClearable(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isWaiting() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isWaiting(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listPlacement() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listPlacement(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listOpen() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listOpen(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get list() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set list(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isVirtualList() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isVirtualList(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loadOptionsInterval() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loadOptionsInterval(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noOptionsMessage() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noOptionsMessage(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hideEmptyState() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hideEmptyState(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filteredItems() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filteredItems(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inputAttributes() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inputAttributes(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get listAutoWidth() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set listAutoWidth(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get itemHeight() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set itemHeight(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get Icon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set Icon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get iconProps() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set iconProps(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showChevron() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showChevron(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showIndicator() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showIndicator(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get containerClasses() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set containerClasses(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicatorSvg() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicatorSvg(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get ClearIcon() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ClearIcon(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get handleClear() {
    		return this.$$.ctx[24];
    	}

    	set handleClear(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CheckoutPage\Popup.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$9, console: console_1$8 } = globals;
    const file$t = "src\\components\\CheckoutPage\\Popup.svelte";

    function create_fragment$z(ctx) {
    	let div14;
    	let div2;
    	let div1;
    	let t0;
    	let div0;
    	let t2;
    	let hr0;
    	let t3;
    	let div12;
    	let div4;
    	let div3;
    	let t4;
    	let input0;
    	let t5;
    	let div7;
    	let div5;
    	let t7;
    	let div6;
    	let a;
    	let t9;
    	let input1;
    	let input1_value_value;
    	let t10;
    	let div8;
    	let t11;
    	let textarea;
    	let t12;
    	let div9;
    	let t13;
    	let select0;
    	let t14;
    	let div10;
    	let t15;
    	let select1;
    	let t16;
    	let div11;
    	let t17;
    	let select2;
    	let t18;
    	let div13;
    	let hr1;
    	let t19;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	select0 = new Select({
    			props: {
    				items: Object.keys(states).map(func),
    				selectedValue: {
    					value: /*form*/ ctx[0].info.state,
    					label: /*form*/ ctx[0].info.state
    				}
    			},
    			$$inline: true
    		});

    	select0.$on("select", /*handleSelectState*/ ctx[4]);

    	select1 = new Select({
    			props: {
    				items: states[/*form*/ ctx[0].info.state
    				? /*form*/ ctx[0].info.state
    				: "Tunis"].cities.map(func_1),
    				selectedValue: {
    					value: /*form*/ ctx[0].info.city,
    					label: /*form*/ ctx[0].info.city
    				}
    			},
    			$$inline: true
    		});

    	select1.$on("select", /*handleSelectCity*/ ctx[5]);

    	select2 = new Select({
    			props: {
    				items: states[/*form*/ ctx[0].info.state
    				? /*form*/ ctx[0].info.state
    				: "Tunis"].postals.map(func_2),
    				selectedValue: {
    					value: /*form*/ ctx[0].info.postal,
    					label: /*form*/ ctx[0].info.postal
    				}
    			},
    			$$inline: true
    		});

    	select2.$on("select", /*handleSelectPostal*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			t0 = text("Modifier l'adresse\r\n                ");
    			div0 = element("div");
    			div0.textContent = "X";
    			t2 = space();
    			hr0 = element("hr");
    			t3 = space();
    			div12 = element("div");
    			div4 = element("div");
    			div3 = element("div");
    			t4 = text("Name *:\r\n                ");
    			input0 = element("input");
    			t5 = space();
    			div7 = element("div");
    			div5 = element("div");
    			div5.textContent = "Phone Number *:";
    			t7 = space();
    			div6 = element("div");
    			a = element("a");
    			a.textContent = "Edit";
    			t9 = space();
    			input1 = element("input");
    			t10 = space();
    			div8 = element("div");
    			t11 = text("Address *:\r\n            ");
    			textarea = element("textarea");
    			t12 = space();
    			div9 = element("div");
    			t13 = text("Region *:\r\n            \r\n            ");
    			create_component(select0.$$.fragment);
    			t14 = space();
    			div10 = element("div");
    			t15 = text("City *:\r\n            \r\n            ");
    			create_component(select1.$$.fragment);
    			t16 = space();
    			div11 = element("div");
    			t17 = text("Postal Code *:\r\n            \r\n            ");
    			create_component(select2.$$.fragment);
    			t18 = space();
    			div13 = element("div");
    			hr1 = element("hr");
    			t19 = space();
    			button = element("button");
    			button.textContent = "Save";
    			attr_dev(div0, "class", "exit_button svelte-17j1ek2");
    			add_location(div0, file$t, 214, 16, 4747);
    			attr_dev(div1, "class", "popup_title_text svelte-17j1ek2");
    			add_location(div1, file$t, 212, 12, 4663);
    			attr_dev(hr0, "class", "svelte-17j1ek2");
    			add_location(hr0, file$t, 218, 12, 4862);
    			attr_dev(div2, "class", "popup_title svelte-17j1ek2");
    			add_location(div2, file$t, 211, 4, 4624);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "first_name_input svelte-17j1ek2");
    			add_location(input0, file$t, 224, 16, 5034);
    			attr_dev(div3, "class", "first_name svelte-17j1ek2");
    			add_location(div3, file$t, 222, 12, 4967);
    			attr_dev(div4, "class", "name_lastname svelte-17j1ek2");
    			add_location(div4, file$t, 221, 8, 4926);
    			attr_dev(div5, "class", "phone_num_text");
    			add_location(div5, file$t, 231, 12, 5219);
    			attr_dev(a, "href", "/phoneverification?backurl=/checkout");
    			attr_dev(a, "class", "country_num svelte-17j1ek2");
    			add_location(a, file$t, 233, 16, 5330);
    			input1.disabled = true;
    			attr_dev(input1, "type", "text");
    			input1.value = input1_value_value = /*$user*/ ctx[3].phoneNumber;
    			attr_dev(input1, "class", "num svelte-17j1ek2");
    			add_location(input1, file$t, 234, 16, 5432);
    			attr_dev(div6, "class", "inputs editphone svelte-17j1ek2");
    			add_location(div6, file$t, 232, 12, 5282);
    			attr_dev(div7, "class", "phone_num svelte-17j1ek2");
    			add_location(div7, file$t, 230, 8, 5182);
    			attr_dev(textarea, "type", "text");
    			attr_dev(textarea, "class", "address_input svelte-17j1ek2");
    			add_location(textarea, file$t, 240, 12, 5620);
    			attr_dev(div8, "class", "address svelte-17j1ek2");
    			add_location(div8, file$t, 238, 8, 5561);
    			attr_dev(div9, "class", "region svelte-17j1ek2");
    			add_location(div9, file$t, 243, 8, 5735);
    			attr_dev(div10, "class", "city svelte-17j1ek2");
    			add_location(div10, file$t, 255, 8, 6316);
    			attr_dev(div11, "class", "city svelte-17j1ek2");
    			add_location(div11, file$t, 264, 8, 6916);
    			attr_dev(div12, "class", "edit_address_popup svelte-17j1ek2");
    			add_location(div12, file$t, 220, 4, 4884);
    			attr_dev(hr1, "class", "svelte-17j1ek2");
    			add_location(hr1, file$t, 279, 8, 7605);
    			attr_dev(button, "class", "svelte-17j1ek2");
    			add_location(button, file$t, 280, 8, 7619);
    			attr_dev(div13, "class", "Save_btn svelte-17j1ek2");
    			add_location(div13, file$t, 278, 4, 7573);
    			attr_dev(div14, "class", "bg_edit_address_popup svelte-17j1ek2");
    			add_location(div14, file$t, 209, 0, 4581);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div2);
    			append_dev(div2, div1);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			append_dev(div2, t2);
    			append_dev(div2, hr0);
    			append_dev(div14, t3);
    			append_dev(div14, div12);
    			append_dev(div12, div4);
    			append_dev(div4, div3);
    			append_dev(div3, t4);
    			append_dev(div3, input0);
    			set_input_value(input0, /*form*/ ctx[0].info.name);
    			append_dev(div12, t5);
    			append_dev(div12, div7);
    			append_dev(div7, div5);
    			append_dev(div7, t7);
    			append_dev(div7, div6);
    			append_dev(div6, a);
    			append_dev(div6, t9);
    			append_dev(div6, input1);
    			append_dev(div12, t10);
    			append_dev(div12, div8);
    			append_dev(div8, t11);
    			append_dev(div8, textarea);
    			set_input_value(textarea, /*form*/ ctx[0].info.address);
    			append_dev(div12, t12);
    			append_dev(div12, div9);
    			append_dev(div9, t13);
    			mount_component(select0, div9, null);
    			append_dev(div12, t14);
    			append_dev(div12, div10);
    			append_dev(div10, t15);
    			mount_component(select1, div10, null);
    			append_dev(div12, t16);
    			append_dev(div12, div11);
    			append_dev(div11, t17);
    			mount_component(select2, div11, null);
    			append_dev(div14, t18);
    			append_dev(div14, div13);
    			append_dev(div13, hr1);
    			append_dev(div13, t19);
    			append_dev(div13, button);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", /*click_handler*/ ctx[7], false, false, false),
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[8]),
    					action_destroyer(link.call(null, a)),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[9]),
    					listen_dev(button, "click", /*click_handler_1*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*form*/ 1 && input0.value !== /*form*/ ctx[0].info.name) {
    				set_input_value(input0, /*form*/ ctx[0].info.name);
    			}

    			if (!current || dirty & /*$user*/ 8 && input1_value_value !== (input1_value_value = /*$user*/ ctx[3].phoneNumber) && input1.value !== input1_value_value) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if (dirty & /*form*/ 1) {
    				set_input_value(textarea, /*form*/ ctx[0].info.address);
    			}

    			const select0_changes = {};

    			if (dirty & /*form*/ 1) select0_changes.selectedValue = {
    				value: /*form*/ ctx[0].info.state,
    				label: /*form*/ ctx[0].info.state
    			};

    			select0.$set(select0_changes);
    			const select1_changes = {};

    			if (dirty & /*form*/ 1) select1_changes.items = states[/*form*/ ctx[0].info.state
    			? /*form*/ ctx[0].info.state
    			: "Tunis"].cities.map(func_1);

    			if (dirty & /*form*/ 1) select1_changes.selectedValue = {
    				value: /*form*/ ctx[0].info.city,
    				label: /*form*/ ctx[0].info.city
    			};

    			select1.$set(select1_changes);
    			const select2_changes = {};

    			if (dirty & /*form*/ 1) select2_changes.items = states[/*form*/ ctx[0].info.state
    			? /*form*/ ctx[0].info.state
    			: "Tunis"].postals.map(func_2);

    			if (dirty & /*form*/ 1) select2_changes.selectedValue = {
    				value: /*form*/ ctx[0].info.postal,
    				label: /*form*/ ctx[0].info.postal
    			};

    			select2.$set(select2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select0.$$.fragment, local);
    			transition_in(select1.$$.fragment, local);
    			transition_in(select2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select0.$$.fragment, local);
    			transition_out(select1.$$.fragment, local);
    			transition_out(select2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    			destroy_component(select0);
    			destroy_component(select1);
    			destroy_component(select2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func = i => {
    	return { value: i, label: i };
    };

    const func_1 = i => {
    	return { value: i, label: i };
    };

    const func_2 = i => {
    	return { value: i, label: i };
    };

    function instance$z($$self, $$props, $$invalidate) {
    	let $popup,
    		$$unsubscribe_popup = noop,
    		$$subscribe_popup = () => ($$unsubscribe_popup(), $$unsubscribe_popup = subscribe(popup, $$value => $$invalidate(2, $popup = $$value)), popup);

    	let $user;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(3, $user = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_popup());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Popup", slots, []);
    	let { form = { info: {} } } = $$props;
    	let { popup } = $$props;
    	validate_store(popup, "popup");
    	$$subscribe_popup();
    	console.log(form);

    	const handleSelectState = event => {
    		$$invalidate(0, form.info.state = event.detail.value, form);
    		$$invalidate(0, form.info.city = states[form.info.state].cities[0], form);
    		$$invalidate(0, form.info.postal = states[form.info.city].postals[0], form);
    	};

    	const handleSelectCity = event => {
    		$$invalidate(0, form.info.city = event.detail.value, form);
    	};

    	const handleSelectPostal = event => {
    		$$invalidate(0, form.info.postal = event.detail.value, form);
    		console.log(form);
    	};

    	const writable_props = ["form", "popup"];

    	Object_1$9.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<Popup> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		set_store_value(popup, $popup = false, $popup);
    	};

    	function input0_input_handler() {
    		form.info.name = this.value;
    		$$invalidate(0, form);
    	}

    	function textarea_input_handler() {
    		form.info.address = this.value;
    		$$invalidate(0, form);
    	}

    	const click_handler_1 = () => {
    		set_store_value(popup, $popup = false, $popup);
    	};

    	$$self.$$set = $$props => {
    		if ("form" in $$props) $$invalidate(0, form = $$props.form);
    		if ("popup" in $$props) $$subscribe_popup($$invalidate(1, popup = $$props.popup));
    	};

    	$$self.$capture_state = () => ({
    		link,
    		user,
    		states,
    		Select,
    		form,
    		popup,
    		handleSelectState,
    		handleSelectCity,
    		handleSelectPostal,
    		$popup,
    		$user
    	});

    	$$self.$inject_state = $$props => {
    		if ("form" in $$props) $$invalidate(0, form = $$props.form);
    		if ("popup" in $$props) $$subscribe_popup($$invalidate(1, popup = $$props.popup));
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		form,
    		popup,
    		$popup,
    		$user,
    		handleSelectState,
    		handleSelectCity,
    		handleSelectPostal,
    		click_handler,
    		input0_input_handler,
    		textarea_input_handler,
    		click_handler_1
    	];
    }

    class Popup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, { form: 0, popup: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Popup",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*popup*/ ctx[1] === undefined && !("popup" in props)) {
    			console_1$8.warn("<Popup> was created without expected prop 'popup'");
    		}
    	}

    	get form() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get popup() {
    		throw new Error("<Popup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set popup(value) {
    		throw new Error("<Popup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CheckoutPage\Form.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$a, console: console_1$9 } = globals;
    const file$u = "src\\components\\CheckoutPage\\Form.svelte";

    function create_fragment$A(ctx) {
    	let div14;
    	let div2;
    	let div1;
    	let div0;
    	let t1;
    	let input0;
    	let t2;
    	let div5;
    	let div3;
    	let t4;
    	let div4;
    	let a;
    	let t6;
    	let input1;
    	let input1_value_value;
    	let t7;
    	let div7;
    	let div6;
    	let t9;
    	let textarea;
    	let t10;
    	let div9;
    	let div8;
    	let t12;
    	let select0;
    	let t13;
    	let div11;
    	let div10;
    	let t15;
    	let select1;
    	let t16;
    	let div13;
    	let div12;
    	let t18;
    	let select2;
    	let current;
    	let mounted;
    	let dispose;

    	select0 = new Select({
    			props: {
    				items: Object.keys(states).map(func$1),
    				selectedValue: {
    					value: /*form*/ ctx[0].info.state,
    					label: /*form*/ ctx[0].info.state
    				}
    			},
    			$$inline: true
    		});

    	select0.$on("select", /*handleSelectState*/ ctx[2]);

    	select1 = new Select({
    			props: {
    				items: states[/*form*/ ctx[0].info.state
    				? /*form*/ ctx[0].info.state
    				: "Tunis"].cities.map(func_1$1),
    				selectedValue: {
    					value: /*form*/ ctx[0].info.city,
    					label: /*form*/ ctx[0].info.city
    				}
    			},
    			$$inline: true
    		});

    	select1.$on("select", /*handleSelectCity*/ ctx[3]);

    	select2 = new Select({
    			props: {
    				items: states[/*form*/ ctx[0].info.state
    				? /*form*/ ctx[0].info.state
    				: "Tunis"].postals.map(func_2$1),
    				selectedValue: {
    					value: /*form*/ ctx[0].info.postal,
    					label: /*form*/ ctx[0].info.postal
    				}
    			},
    			$$inline: true
    		});

    	select2.$on("select", /*handleSelectPostal*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Name *:";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			div5 = element("div");
    			div3 = element("div");
    			div3.textContent = "Phone Number *:";
    			t4 = space();
    			div4 = element("div");
    			a = element("a");
    			a.textContent = "Edit";
    			t6 = space();
    			input1 = element("input");
    			t7 = space();
    			div7 = element("div");
    			div6 = element("div");
    			div6.textContent = "Address *:";
    			t9 = space();
    			textarea = element("textarea");
    			t10 = space();
    			div9 = element("div");
    			div8 = element("div");
    			div8.textContent = "Region *:";
    			t12 = space();
    			create_component(select0.$$.fragment);
    			t13 = space();
    			div11 = element("div");
    			div10 = element("div");
    			div10.textContent = "City *:";
    			t15 = space();
    			create_component(select1.$$.fragment);
    			t16 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div12.textContent = "Postal Code *:";
    			t18 = space();
    			create_component(select2.$$.fragment);
    			attr_dev(div0, "class", "first_name_text title-input-text svelte-1qjbepw");
    			add_location(div0, file$u, 214, 16, 4589);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "first_name_input svelte-1qjbepw");
    			add_location(input0, file$u, 215, 16, 4666);
    			attr_dev(div1, "class", "first_name svelte-1qjbepw");
    			add_location(div1, file$u, 213, 12, 4547);
    			attr_dev(div2, "class", "name_lastname svelte-1qjbepw");
    			add_location(div2, file$u, 212, 8, 4506);
    			attr_dev(div3, "class", "phone_num_text title-input-text svelte-1qjbepw");
    			add_location(div3, file$u, 222, 12, 4851);
    			attr_dev(a, "href", "/phoneverification?backurl=/checkout");
    			attr_dev(a, "class", "country_num svelte-1qjbepw");
    			add_location(a, file$u, 224, 16, 4979);
    			input1.disabled = true;
    			attr_dev(input1, "type", "text");
    			input1.value = input1_value_value = /*$user*/ ctx[1].phoneNumber;
    			attr_dev(input1, "class", "num svelte-1qjbepw");
    			add_location(input1, file$u, 225, 16, 5081);
    			attr_dev(div4, "class", "inputs editphone svelte-1qjbepw");
    			add_location(div4, file$u, 223, 12, 4931);
    			attr_dev(div5, "class", "phone_num svelte-1qjbepw");
    			add_location(div5, file$u, 221, 8, 4814);
    			attr_dev(div6, "class", "title-input-text svelte-1qjbepw");
    			add_location(div6, file$u, 231, 12, 5259);
    			attr_dev(textarea, "type", "text");
    			attr_dev(textarea, "class", "address_input svelte-1qjbepw");
    			add_location(textarea, file$u, 234, 12, 5351);
    			attr_dev(div7, "class", "address svelte-1qjbepw");
    			add_location(div7, file$u, 229, 8, 5210);
    			attr_dev(div8, "class", "title-input-text svelte-1qjbepw");
    			add_location(div8, file$u, 239, 12, 5514);
    			attr_dev(div9, "class", "region svelte-1qjbepw");
    			add_location(div9, file$u, 237, 8, 5466);
    			attr_dev(div10, "class", "title-input-text svelte-1qjbepw");
    			add_location(div10, file$u, 254, 12, 6175);
    			attr_dev(div11, "class", "city svelte-1qjbepw");
    			add_location(div11, file$u, 252, 8, 6129);
    			attr_dev(div12, "class", "title-input-text svelte-1qjbepw");
    			add_location(div12, file$u, 266, 12, 6857);
    			attr_dev(div13, "class", "city svelte-1qjbepw");
    			add_location(div13, file$u, 264, 8, 6811);
    			attr_dev(div14, "class", "edit_address_popup svelte-1qjbepw");
    			add_location(div14, file$u, 211, 4, 4464);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div2);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			append_dev(div1, input0);
    			set_input_value(input0, /*form*/ ctx[0].info.name);
    			append_dev(div14, t2);
    			append_dev(div14, div5);
    			append_dev(div5, div3);
    			append_dev(div5, t4);
    			append_dev(div5, div4);
    			append_dev(div4, a);
    			append_dev(div4, t6);
    			append_dev(div4, input1);
    			append_dev(div14, t7);
    			append_dev(div14, div7);
    			append_dev(div7, div6);
    			append_dev(div7, t9);
    			append_dev(div7, textarea);
    			set_input_value(textarea, /*form*/ ctx[0].info.address);
    			append_dev(div14, t10);
    			append_dev(div14, div9);
    			append_dev(div9, div8);
    			append_dev(div9, t12);
    			mount_component(select0, div9, null);
    			append_dev(div14, t13);
    			append_dev(div14, div11);
    			append_dev(div11, div10);
    			append_dev(div11, t15);
    			mount_component(select1, div11, null);
    			append_dev(div14, t16);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div13, t18);
    			mount_component(select2, div13, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[6]),
    					action_destroyer(link.call(null, a)),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[7])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*form*/ 1 && input0.value !== /*form*/ ctx[0].info.name) {
    				set_input_value(input0, /*form*/ ctx[0].info.name);
    			}

    			if (!current || dirty & /*$user*/ 2 && input1_value_value !== (input1_value_value = /*$user*/ ctx[1].phoneNumber) && input1.value !== input1_value_value) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if (dirty & /*form*/ 1) {
    				set_input_value(textarea, /*form*/ ctx[0].info.address);
    			}

    			const select0_changes = {};

    			if (dirty & /*form*/ 1) select0_changes.selectedValue = {
    				value: /*form*/ ctx[0].info.state,
    				label: /*form*/ ctx[0].info.state
    			};

    			select0.$set(select0_changes);
    			const select1_changes = {};

    			if (dirty & /*form*/ 1) select1_changes.items = states[/*form*/ ctx[0].info.state
    			? /*form*/ ctx[0].info.state
    			: "Tunis"].cities.map(func_1$1);

    			if (dirty & /*form*/ 1) select1_changes.selectedValue = {
    				value: /*form*/ ctx[0].info.city,
    				label: /*form*/ ctx[0].info.city
    			};

    			select1.$set(select1_changes);
    			const select2_changes = {};

    			if (dirty & /*form*/ 1) select2_changes.items = states[/*form*/ ctx[0].info.state
    			? /*form*/ ctx[0].info.state
    			: "Tunis"].postals.map(func_2$1);

    			if (dirty & /*form*/ 1) select2_changes.selectedValue = {
    				value: /*form*/ ctx[0].info.postal,
    				label: /*form*/ ctx[0].info.postal
    			};

    			select2.$set(select2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(select0.$$.fragment, local);
    			transition_in(select1.$$.fragment, local);
    			transition_in(select2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(select0.$$.fragment, local);
    			transition_out(select1.$$.fragment, local);
    			transition_out(select2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    			destroy_component(select0);
    			destroy_component(select1);
    			destroy_component(select2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const func$1 = i => {
    	return { value: i, label: i };
    };

    const func_1$1 = i => {
    	return { value: i, label: i };
    };

    const func_2$1 = i => {
    	return { value: i, label: i };
    };

    function instance$A($$self, $$props, $$invalidate) {
    	let $user;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(1, $user = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Form", slots, []);
    	let { form = { info: {} } } = $$props;
    	let { popup } = $$props;
    	console.log(form);

    	const handleSelectState = event => {
    		$$invalidate(0, form.info.state = event.detail.value, form);
    		$$invalidate(0, form.info.city = states[form.info.state].cities[0], form);
    		$$invalidate(0, form.info.postal = states[form.info.city].postals[0], form);
    	};

    	const handleSelectCity = event => {
    		$$invalidate(0, form.info.city = event.detail.value, form);
    	};

    	const handleSelectPostal = event => {
    		$$invalidate(0, form.info.postal = event.detail.value, form);
    		console.log(form);
    	};

    	const writable_props = ["form", "popup"];

    	Object_1$a.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<Form> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		form.info.name = this.value;
    		$$invalidate(0, form);
    	}

    	function textarea_input_handler() {
    		form.info.address = this.value;
    		$$invalidate(0, form);
    	}

    	$$self.$$set = $$props => {
    		if ("form" in $$props) $$invalidate(0, form = $$props.form);
    		if ("popup" in $$props) $$invalidate(5, popup = $$props.popup);
    	};

    	$$self.$capture_state = () => ({
    		link,
    		user,
    		states,
    		Select,
    		form,
    		popup,
    		handleSelectState,
    		handleSelectCity,
    		handleSelectPostal,
    		$user
    	});

    	$$self.$inject_state = $$props => {
    		if ("form" in $$props) $$invalidate(0, form = $$props.form);
    		if ("popup" in $$props) $$invalidate(5, popup = $$props.popup);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		form,
    		$user,
    		handleSelectState,
    		handleSelectCity,
    		handleSelectPostal,
    		popup,
    		input0_input_handler,
    		textarea_input_handler
    	];
    }

    class Form extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { form: 0, popup: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Form",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*popup*/ ctx[5] === undefined && !("popup" in props)) {
    			console_1$9.warn("<Form> was created without expected prop 'popup'");
    		}
    	}

    	get form() {
    		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set form(value) {
    		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get popup() {
    		throw new Error("<Form>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set popup(value) {
    		throw new Error("<Form>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\CheckoutPage\orderCompletion.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$b, console: console_1$a } = globals;
    const file$v = "src\\components\\CheckoutPage\\orderCompletion.svelte";

    // (462:12) {:else}
    function create_else_block$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Finalize Your Order");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(462:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (460:12) {#if submitting}
    function create_if_block_1$9(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(460:12) {#if submitting}",
    		ctx
    	});

    	return block;
    }

    // (469:0) {#if $popup}
    function create_if_block$g(ctx) {
    	let popup_1;
    	let updating_form;
    	let updating_popup;
    	let current;

    	function popup_1_form_binding(value) {
    		/*popup_1_form_binding*/ ctx[10](value);
    	}

    	function popup_1_popup_binding(value) {
    		/*popup_1_popup_binding*/ ctx[11](value);
    	}

    	let popup_1_props = {};

    	if (/*form*/ ctx[2] !== void 0) {
    		popup_1_props.form = /*form*/ ctx[2];
    	}

    	if (/*popup*/ ctx[0] !== void 0) {
    		popup_1_props.popup = /*popup*/ ctx[0];
    	}

    	popup_1 = new Popup({ props: popup_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(popup_1, "form", popup_1_form_binding));
    	binding_callbacks.push(() => bind(popup_1, "popup", popup_1_popup_binding));

    	const block = {
    		c: function create() {
    			create_component(popup_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(popup_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const popup_1_changes = {};

    			if (!updating_form && dirty & /*form*/ 4) {
    				updating_form = true;
    				popup_1_changes.form = /*form*/ ctx[2];
    				add_flush_callback(() => updating_form = false);
    			}

    			if (!updating_popup && dirty & /*popup*/ 1) {
    				updating_popup = true;
    				popup_1_changes.popup = /*popup*/ ctx[0];
    				add_flush_callback(() => updating_popup = false);
    			}

    			popup_1.$set(popup_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(popup_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(popup_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(popup_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(469:0) {#if $popup}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div28;
    	let span0;
    	let t1;
    	let hr0;
    	let t2;
    	let div4;
    	let div1;
    	let div0;
    	let i0;
    	let t3;
    	let t4;
    	let div3;
    	let div2;
    	let form_1;
    	let updating_form;
    	let t5;
    	let hr1;
    	let t6;
    	let div14;
    	let div6;
    	let div5;
    	let i1;
    	let t7;
    	let t8;
    	let div13;
    	let div12;
    	let div9;
    	let div8;
    	let div7;
    	let t9;
    	let t10;
    	let div10;
    	let t11;
    	let span1;
    	let t13;
    	let span2;
    	let t15;
    	let div11;
    	let t16;
    	let span3;
    	let t18;
    	let t19;
    	let hr2;
    	let t20;
    	let div27;
    	let div16;
    	let div15;
    	let i2;
    	let t21;
    	let t22;
    	let div22;
    	let div21;
    	let div19;
    	let div18;
    	let div17;
    	let t23;
    	let t24;
    	let div20;

    	let t25_value = ({
    		en: "Make sure to prepare the exact amount of the order. The delivery people do not always have cash on hand to give you change",
    		fr: "Assurez-vous de préparer le montant exact de la commande. Les livreurs ne disposent pas toujours d'espèces pour vous rendre la monnaie."
    	})[/*$lang*/ ctx[4]] + "";

    	let t25;
    	let t26;
    	let div23;
    	let t27;
    	let div26;
    	let div24;
    	let span4;
    	let t29;
    	let span5;
    	let t31;
    	let t32;
    	let div25;
    	let span6;
    	let t33;
    	let t34;
    	let t35;
    	let span7;
    	let t37;
    	let t38;
    	let hr3;
    	let t39;
    	let span8;
    	let t40;
    	let t41;
    	let t42;
    	let t43;
    	let button;
    	let current_block_type_index;
    	let if_block4;
    	let t44;
    	let if_block5_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	function form_1_form_binding(value) {
    		/*form_1_form_binding*/ ctx[9](value);
    	}

    	let form_1_props = {};

    	if (/*form*/ ctx[2] !== void 0) {
    		form_1_props.form = /*form*/ ctx[2];
    	}

    	form_1 = new Form({ props: form_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(form_1, "form", form_1_form_binding));
    	const if_block_creators = [create_if_block_1$9, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*submitting*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block5 = /*$popup*/ ctx[5] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			div28 = element("div");
    			span0 = element("span");
    			span0.textContent = "Order Completion";
    			t1 = space();
    			hr0 = element("hr");
    			t2 = space();
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			i0 = element("i");
    			t3 = text("\r\n            Address");
    			t4 = space();
    			div3 = element("div");
    			div2 = element("div");
    			create_component(form_1.$$.fragment);
    			t5 = space();
    			hr1 = element("hr");
    			t6 = space();
    			div14 = element("div");
    			div6 = element("div");
    			div5 = element("div");
    			i1 = element("i");
    			t7 = text("\r\n            Delivery Method");
    			t8 = space();
    			div13 = element("div");
    			div12 = element("div");
    			div9 = element("div");
    			div8 = element("div");
    			div7 = element("div");
    			t9 = text(" Standard");
    			t10 = space();
    			div10 = element("div");
    			t11 = text("Your delivery will arrive between the\r\n                    ");
    			span1 = element("span");
    			span1.textContent = `${/*minDdate*/ ctx[6]}`;
    			t13 = text("\r\n                    and the\r\n                    ");
    			span2 = element("span");
    			span2.textContent = `${/*maxdDate*/ ctx[7]}`;
    			t15 = space();
    			div11 = element("div");
    			t16 = text("Delivery fees:\r\n                    ");
    			span3 = element("span");
    			span3.textContent = "Free";
    			t18 = space();
    			t19 = space();
    			hr2 = element("hr");
    			t20 = space();
    			div27 = element("div");
    			div16 = element("div");
    			div15 = element("div");
    			i2 = element("i");
    			t21 = text("\r\n            Payment Method");
    			t22 = space();
    			div22 = element("div");
    			div21 = element("div");
    			div19 = element("div");
    			div18 = element("div");
    			div17 = element("div");
    			t23 = text("Cash on delivery");
    			t24 = space();
    			div20 = element("div");
    			t25 = text(t25_value);
    			t26 = space();
    			div23 = element("div");
    			t27 = space();
    			div26 = element("div");
    			div24 = element("div");
    			span4 = element("span");
    			span4.textContent = "Subtotal";
    			t29 = space();
    			span5 = element("span");
    			span5.textContent = "Shipping";
    			t31 = space();
    			t32 = space();
    			div25 = element("div");
    			span6 = element("span");
    			t33 = text(/*normalTotal*/ ctx[1]);
    			t34 = text(" DT");
    			t35 = space();
    			span7 = element("span");
    			span7.textContent = "Free";
    			t37 = space();
    			t38 = space();
    			hr3 = element("hr");
    			t39 = space();
    			span8 = element("span");
    			t40 = text("Total: ");
    			t41 = text(/*normalTotal*/ ctx[1]);
    			t42 = text(" DT");
    			t43 = space();
    			button = element("button");
    			if_block4.c();
    			t44 = space();
    			if (if_block5) if_block5.c();
    			if_block5_anchor = empty();
    			attr_dev(span0, "class", "title svelte-o3y9eu");
    			add_location(span0, file$v, 347, 4, 8672);
    			attr_dev(hr0, "class", "svelte-o3y9eu");
    			add_location(hr0, file$v, 349, 4, 8723);
    			attr_dev(i0, "class", "fas fa-check svelte-o3y9eu");
    			add_location(i0, file$v, 352, 31, 8826);
    			attr_dev(div0, "class", "check svelte-o3y9eu");
    			add_location(div0, file$v, 352, 12, 8807);
    			attr_dev(div1, "class", "address_title svelte-o3y9eu");
    			add_location(div1, file$v, 351, 8, 8766);
    			attr_dev(div2, "class", "address_info svelte-o3y9eu");
    			add_location(div2, file$v, 358, 12, 8945);
    			attr_dev(div3, "class", "section2 svelte-o3y9eu");
    			add_location(div3, file$v, 356, 8, 8907);
    			attr_dev(div4, "class", "address svelte-o3y9eu");
    			add_location(div4, file$v, 350, 4, 8735);
    			attr_dev(hr1, "class", "svelte-o3y9eu");
    			add_location(hr1, file$v, 380, 4, 9841);
    			attr_dev(i1, "class", "fas fa-check svelte-o3y9eu");
    			add_location(i1, file$v, 383, 31, 9946);
    			attr_dev(div5, "class", "check svelte-o3y9eu");
    			add_location(div5, file$v, 383, 12, 9927);
    			attr_dev(div6, "class", "delivery_title svelte-o3y9eu");
    			add_location(div6, file$v, 382, 8, 9885);
    			attr_dev(div7, "class", "shape svelte-o3y9eu");
    			add_location(div7, file$v, 389, 68, 10186);
    			attr_dev(div8, "class", "shape_border svelte-o3y9eu");
    			add_location(div8, file$v, 389, 42, 10160);
    			attr_dev(div9, "class", "method_title svelte-o3y9eu");
    			add_location(div9, file$v, 389, 16, 10134);
    			attr_dev(span1, "class", "Accent_color svelte-o3y9eu");
    			add_location(span1, file$v, 392, 20, 10352);
    			attr_dev(span2, "class", "Accent_color svelte-o3y9eu");
    			add_location(span2, file$v, 394, 20, 10447);
    			attr_dev(div10, "class", "method_desc svelte-o3y9eu");
    			add_location(div10, file$v, 390, 16, 10246);
    			attr_dev(span3, "class", "Accent_color svelte-o3y9eu");
    			add_location(span3, file$v, 398, 20, 10616);
    			attr_dev(div11, "class", "method_fees svelte-o3y9eu");
    			add_location(div11, file$v, 396, 16, 10533);
    			attr_dev(div12, "class", "delivery_method svelte-o3y9eu");
    			add_location(div12, file$v, 388, 12, 10087);
    			attr_dev(div13, "class", "delivery_methods svelte-o3y9eu");
    			add_location(div13, file$v, 387, 8, 10043);
    			attr_dev(div14, "class", "delivery svelte-o3y9eu");
    			add_location(div14, file$v, 381, 4, 9853);
    			attr_dev(hr2, "class", "svelte-o3y9eu");
    			add_location(hr2, file$v, 408, 4, 10915);
    			attr_dev(i2, "class", "fas fa-check svelte-o3y9eu");
    			add_location(i2, file$v, 412, 31, 11020);
    			attr_dev(div15, "class", "check svelte-o3y9eu");
    			add_location(div15, file$v, 412, 12, 11001);
    			attr_dev(div16, "class", "payment_title svelte-o3y9eu");
    			add_location(div16, file$v, 411, 8, 10960);
    			attr_dev(div17, "class", "shape svelte-o3y9eu");
    			add_location(div17, file$v, 418, 46, 11269);
    			attr_dev(div18, "class", "shape_border svelte-o3y9eu");
    			add_location(div18, file$v, 418, 20, 11243);
    			attr_dev(div19, "class", "method_title svelte-o3y9eu");
    			add_location(div19, file$v, 417, 16, 11195);
    			attr_dev(div20, "class", "method_desc svelte-o3y9eu");
    			add_location(div20, file$v, 420, 16, 11354);
    			attr_dev(div21, "class", "payment_method");
    			add_location(div21, file$v, 416, 12, 11149);
    			attr_dev(div22, "class", "payment_methods svelte-o3y9eu");
    			add_location(div22, file$v, 415, 8, 11106);
    			attr_dev(div23, "class", "coupon svelte-o3y9eu");
    			add_location(div23, file$v, 425, 8, 11755);
    			attr_dev(span4, "class", "subtotal svelte-o3y9eu");
    			add_location(span4, file$v, 440, 16, 12263);
    			attr_dev(span5, "class", "shipping svelte-o3y9eu");
    			add_location(span5, file$v, 441, 16, 12319);
    			attr_dev(div24, "class", "titles svelte-o3y9eu");
    			add_location(div24, file$v, 439, 12, 12225);
    			attr_dev(span6, "class", "subtotal svelte-o3y9eu");
    			add_location(span6, file$v, 450, 16, 12649);
    			attr_dev(span7, "class", "shipping svelte-o3y9eu");
    			add_location(span7, file$v, 451, 16, 12713);
    			attr_dev(div25, "class", "prices svelte-o3y9eu");
    			add_location(div25, file$v, 449, 12, 12611);
    			attr_dev(div26, "class", "final_total svelte-o3y9eu");
    			add_location(div26, file$v, 438, 8, 12186);
    			attr_dev(hr3, "class", "svelte-o3y9eu");
    			add_location(hr3, file$v, 455, 8, 12874);
    			attr_dev(span8, "class", "total svelte-o3y9eu");
    			add_location(span8, file$v, 456, 8, 12890);
    			attr_dev(button, "class", "finilize_btn svelte-o3y9eu");
    			add_location(button, file$v, 458, 8, 12952);
    			attr_dev(div27, "class", "payment svelte-o3y9eu");
    			add_location(div27, file$v, 410, 4, 10929);
    			attr_dev(div28, "class", "container svelte-o3y9eu");
    			add_location(div28, file$v, 346, 0, 8643);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div28, anchor);
    			append_dev(div28, span0);
    			append_dev(div28, t1);
    			append_dev(div28, hr0);
    			append_dev(div28, t2);
    			append_dev(div28, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div0, i0);
    			append_dev(div1, t3);
    			append_dev(div4, t4);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			mount_component(form_1, div2, null);
    			append_dev(div28, t5);
    			append_dev(div28, hr1);
    			append_dev(div28, t6);
    			append_dev(div28, div14);
    			append_dev(div14, div6);
    			append_dev(div6, div5);
    			append_dev(div5, i1);
    			append_dev(div6, t7);
    			append_dev(div14, t8);
    			append_dev(div14, div13);
    			append_dev(div13, div12);
    			append_dev(div12, div9);
    			append_dev(div9, div8);
    			append_dev(div8, div7);
    			append_dev(div9, t9);
    			append_dev(div12, t10);
    			append_dev(div12, div10);
    			append_dev(div10, t11);
    			append_dev(div10, span1);
    			append_dev(div10, t13);
    			append_dev(div10, span2);
    			append_dev(div12, t15);
    			append_dev(div12, div11);
    			append_dev(div11, t16);
    			append_dev(div11, span3);
    			append_dev(div14, t18);
    			append_dev(div28, t19);
    			append_dev(div28, hr2);
    			append_dev(div28, t20);
    			append_dev(div28, div27);
    			append_dev(div27, div16);
    			append_dev(div16, div15);
    			append_dev(div15, i2);
    			append_dev(div16, t21);
    			append_dev(div27, t22);
    			append_dev(div27, div22);
    			append_dev(div22, div21);
    			append_dev(div21, div19);
    			append_dev(div19, div18);
    			append_dev(div18, div17);
    			append_dev(div19, t23);
    			append_dev(div21, t24);
    			append_dev(div21, div20);
    			append_dev(div20, t25);
    			append_dev(div27, t26);
    			append_dev(div27, div23);
    			append_dev(div27, t27);
    			append_dev(div27, div26);
    			append_dev(div26, div24);
    			append_dev(div24, span4);
    			append_dev(div24, t29);
    			append_dev(div24, span5);
    			append_dev(div24, t31);
    			append_dev(div26, t32);
    			append_dev(div26, div25);
    			append_dev(div25, span6);
    			append_dev(span6, t33);
    			append_dev(span6, t34);
    			append_dev(div25, t35);
    			append_dev(div25, span7);
    			append_dev(div25, t37);
    			append_dev(div27, t38);
    			append_dev(div27, hr3);
    			append_dev(div27, t39);
    			append_dev(div27, span8);
    			append_dev(span8, t40);
    			append_dev(span8, t41);
    			append_dev(span8, t42);
    			append_dev(div27, t43);
    			append_dev(div27, button);
    			if_blocks[current_block_type_index].m(button, null);
    			insert_dev(target, t44, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, if_block5_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*finalizeOrder*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const form_1_changes = {};

    			if (!updating_form && dirty & /*form*/ 4) {
    				updating_form = true;
    				form_1_changes.form = /*form*/ ctx[2];
    				add_flush_callback(() => updating_form = false);
    			}

    			form_1.$set(form_1_changes);

    			if ((!current || dirty & /*$lang*/ 16) && t25_value !== (t25_value = ({
    				en: "Make sure to prepare the exact amount of the order. The delivery people do not always have cash on hand to give you change",
    				fr: "Assurez-vous de préparer le montant exact de la commande. Les livreurs ne disposent pas toujours d'espèces pour vous rendre la monnaie."
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t25, t25_value);

    			if (!current || dirty & /*normalTotal*/ 2) set_data_dev(t33, /*normalTotal*/ ctx[1]);
    			if (!current || dirty & /*normalTotal*/ 2) set_data_dev(t41, /*normalTotal*/ ctx[1]);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks[current_block_type_index];

    				if (!if_block4) {
    					if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(button, null);
    			}

    			if (/*$popup*/ ctx[5]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*$popup*/ 32) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block$g(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(form_1.$$.fragment, local);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(form_1.$$.fragment, local);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div28);
    			destroy_component(form_1);
    			if_blocks[current_block_type_index].d();
    			if (detaching) detach_dev(t44);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(if_block5_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let $cart;
    	let $user;
    	let $lang;

    	let $popup,
    		$$unsubscribe_popup = noop,
    		$$subscribe_popup = () => ($$unsubscribe_popup(), $$unsubscribe_popup = subscribe(popup, $$value => $$invalidate(5, $popup = $$value)), popup);

    	validate_store(cart, "cart");
    	component_subscribe($$self, cart, $$value => $$invalidate(14, $cart = $$value));
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(15, $user = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(4, $lang = $$value));
    	$$self.$$.on_destroy.push(() => $$unsubscribe_popup());
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("OrderCompletion", slots, []);
    	let [minDdate, maxdDate] = generateDeliveryDate();
    	let popup = writable(false);
    	validate_store(popup, "popup");
    	$$subscribe_popup();

    	let unsubscribePopup = popup.subscribe(v => {
    		v
    		? document.body.style.overflowY = "hidden"
    		: document.body.style.overflowY = "scroll";
    	});

    	onMount(() => {
    		document.title = "Unify - Checkout";
    	});

    	let normalTotal = 0;

    	let unsubscribeCart = () => {
    		
    	};

    	unsubscribeCart = cart.subscribe(data => {
    		$$invalidate(1, normalTotal = Object.entries(data.items).reduce(
    			(acc, [key, value]) => {
    				acc += value.price * (value.quantity ? value.quantity : 1);
    				return acc;
    			},
    			0
    		));
    	});

    	onDestroy(() => {
    		document.body.style.overflowY = "scroll";
    		unsubscribeCart();
    		unsubscribePopup();
    	});

    	console.log(Object.fromEntries(Object.entries($cart.items).map(([key, values]) => [key, [values.id, values.creator, values.quantity, values.size]])));

    	let form = {
    		cart: {
    			cartID: $cart.cartID,
    			items: Object.fromEntries(Object.entries($cart.items).map(([key, values]) => [
    				key,
    				{
    					id: values.id,
    					creator: values.creator,
    					quantity: values.quantity,
    					size: values.size,
    					color: values.color
    				}
    			]))
    		},
    		info: {
    			name: $user.displayName ? $user.displayName : "",
    			address: "",
    			state: "Tunis",
    			city: "Tunis",
    			postal: "1000"
    		}
    	};

    	console.log(form);
    	let submitting = false;
    	let addressError = false;

    	const finalizeOrder = async () => {
    		console.log("finalizing");

    		if (submitting == true) {
    			return;
    		}

    		console.log("after if");
    		$$invalidate(3, submitting = true);

    		if (["address", "state", "city", "postal"].some(item => {
    			console.log(form.info[item]);
    			return form.info[item].length == 0;
    		})) {
    			addressError = true;
    			document.querySelector(".address-notification").scrollIntoView({ block: "center" });

    			notification.set({
    				accentColor: "alert",
    				title: "Alert",
    				content: "Fill out your Address"
    			});

    			$$invalidate(3, submitting = false);
    			return;
    		}

    		console.log("doing new form");

    		$$invalidate(2, form = {
    			...form,
    			token: await $user.getIdToken(true)
    		});

    		//
    		await urlPostReq("https://api.unify.tn/.netlify/functions/express/addOrder", form);

    		navigate("/completed?orderid=" + $cart.cartID + "&backurl=/myaccount/orders");
    		cart.reset();
    		$$invalidate(3, submitting = false);
    	};

    	const writable_props = [];

    	Object_1$b.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<OrderCompletion> was created with unknown prop '${key}'`);
    	});

    	function form_1_form_binding(value) {
    		form = value;
    		$$invalidate(2, form);
    	}

    	function popup_1_form_binding(value) {
    		form = value;
    		$$invalidate(2, form);
    	}

    	function popup_1_popup_binding(value) {
    		popup = value;
    		$$subscribe_popup($$invalidate(0, popup));
    	}

    	$$self.$capture_state = () => ({
    		cart,
    		onMount,
    		onDestroy,
    		user,
    		link,
    		navigate,
    		MaterialSpinner,
    		Popup,
    		writable,
    		urlPostReq,
    		notification,
    		generateDeliveryDate,
    		lang,
    		Form,
    		minDdate,
    		maxdDate,
    		popup,
    		unsubscribePopup,
    		normalTotal,
    		unsubscribeCart,
    		form,
    		submitting,
    		addressError,
    		finalizeOrder,
    		$cart,
    		$user,
    		$lang,
    		$popup
    	});

    	$$self.$inject_state = $$props => {
    		if ("minDdate" in $$props) $$invalidate(6, minDdate = $$props.minDdate);
    		if ("maxdDate" in $$props) $$invalidate(7, maxdDate = $$props.maxdDate);
    		if ("popup" in $$props) $$subscribe_popup($$invalidate(0, popup = $$props.popup));
    		if ("unsubscribePopup" in $$props) unsubscribePopup = $$props.unsubscribePopup;
    		if ("normalTotal" in $$props) $$invalidate(1, normalTotal = $$props.normalTotal);
    		if ("unsubscribeCart" in $$props) unsubscribeCart = $$props.unsubscribeCart;
    		if ("form" in $$props) $$invalidate(2, form = $$props.form);
    		if ("submitting" in $$props) $$invalidate(3, submitting = $$props.submitting);
    		if ("addressError" in $$props) addressError = $$props.addressError;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		popup,
    		normalTotal,
    		form,
    		submitting,
    		$lang,
    		$popup,
    		minDdate,
    		maxdDate,
    		finalizeOrder,
    		form_1_form_binding,
    		popup_1_form_binding,
    		popup_1_popup_binding
    	];
    }

    class OrderCompletion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OrderCompletion",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* src\components\CheckoutPage\orderSummary.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$c, console: console_1$b } = globals;
    const file$w = "src\\components\\CheckoutPage\\orderSummary.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i][0];
    	child_ctx[4] = list[i][1];
    	return child_ctx;
    }

    // (195:8) {#each Object.entries($cart.items) as [key, order]}
    function create_each_block$c(ctx) {
    	let div11;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div10;
    	let span0;
    	let t1_value = /*order*/ ctx[4].name + "";
    	let t1;
    	let t2;
    	let span1;
    	let t3_value = /*order*/ ctx[4].creator + "";
    	let t3;
    	let t4;
    	let div5;
    	let div2;
    	let t5;
    	let div1;
    	let t6;
    	let div4;
    	let t7;
    	let div3;
    	let t8_value = /*order*/ ctx[4].size + "";
    	let t8;
    	let t9;
    	let div7;
    	let t10;
    	let div6;
    	let t11_value = /*order*/ ctx[4].price + "";
    	let t11;
    	let t12;
    	let t13;
    	let div9;
    	let t14;
    	let div8;
    	let t15_value = /*order*/ ctx[4].quantity + "";
    	let t15;
    	let t16;
    	let hr;

    	const block = {
    		c: function create() {
    			div11 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div10 = element("div");
    			span0 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			div5 = element("div");
    			div2 = element("div");
    			t5 = text("Color:\r\n                            ");
    			div1 = element("div");
    			t6 = space();
    			div4 = element("div");
    			t7 = text("Size:\r\n                            ");
    			div3 = element("div");
    			t8 = text(t8_value);
    			t9 = space();
    			div7 = element("div");
    			t10 = text("Unit Price:\r\n                        ");
    			div6 = element("div");
    			t11 = text(t11_value);
    			t12 = text(" TND");
    			t13 = space();
    			div9 = element("div");
    			t14 = text("Qty:\r\n                        ");
    			div8 = element("div");
    			t15 = text(t15_value);
    			t16 = space();
    			hr = element("hr");
    			if (img.src !== (img_src_value = /*order*/ ctx[4].imgs[/*order*/ ctx[4].color][/*order*/ ctx[4].featuredFace])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "tshirt");
    			attr_dev(img, "class", "svelte-ylzvgj");
    			add_location(img, file$w, 196, 35, 4678);
    			attr_dev(div0, "class", "p_img svelte-ylzvgj");
    			add_location(div0, file$w, 196, 16, 4659);
    			attr_dev(span0, "class", "p_title svelte-ylzvgj");
    			add_location(span0, file$w, 198, 20, 4814);
    			attr_dev(span1, "class", "p_sub_title svelte-ylzvgj");
    			add_location(span1, file$w, 199, 20, 4877);
    			attr_dev(div1, "class", "shape svelte-ylzvgj");
    			set_style(div1, "background-color", /*order*/ ctx[4].color);
    			add_location(div1, file$w, 203, 28, 5082);
    			attr_dev(div2, "class", "color svelte-ylzvgj");
    			add_location(div2, file$w, 201, 24, 4997);
    			attr_dev(div3, "class", "shape svelte-ylzvgj");
    			add_location(div3, file$w, 209, 28, 5349);
    			attr_dev(div4, "class", "size svelte-ylzvgj");
    			add_location(div4, file$w, 207, 24, 5266);
    			attr_dev(div5, "class", "color_size svelte-ylzvgj");
    			add_location(div5, file$w, 200, 20, 4947);
    			attr_dev(div6, "class", "price svelte-ylzvgj");
    			add_location(div6, file$w, 214, 24, 5555);
    			attr_dev(div7, "class", "unit_price svelte-ylzvgj");
    			add_location(div7, file$w, 212, 20, 5468);
    			attr_dev(div8, "class", "qty svelte-ylzvgj");
    			add_location(div8, file$w, 218, 24, 5725);
    			attr_dev(div9, "class", "quantity svelte-ylzvgj");
    			add_location(div9, file$w, 216, 20, 5647);
    			attr_dev(div10, "class", "info svelte-ylzvgj");
    			add_location(div10, file$w, 197, 16, 4774);
    			attr_dev(div11, "class", "single_product svelte-ylzvgj");
    			add_location(div11, file$w, 195, 12, 4613);
    			attr_dev(hr, "class", "svelte-ylzvgj");
    			add_location(hr, file$w, 222, 12, 5850);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div11, anchor);
    			append_dev(div11, div0);
    			append_dev(div0, img);
    			append_dev(div11, t0);
    			append_dev(div11, div10);
    			append_dev(div10, span0);
    			append_dev(span0, t1);
    			append_dev(div10, t2);
    			append_dev(div10, span1);
    			append_dev(span1, t3);
    			append_dev(div10, t4);
    			append_dev(div10, div5);
    			append_dev(div5, div2);
    			append_dev(div2, t5);
    			append_dev(div2, div1);
    			append_dev(div5, t6);
    			append_dev(div5, div4);
    			append_dev(div4, t7);
    			append_dev(div4, div3);
    			append_dev(div3, t8);
    			append_dev(div10, t9);
    			append_dev(div10, div7);
    			append_dev(div7, t10);
    			append_dev(div7, div6);
    			append_dev(div6, t11);
    			append_dev(div6, t12);
    			append_dev(div10, t13);
    			append_dev(div10, div9);
    			append_dev(div9, t14);
    			append_dev(div9, div8);
    			append_dev(div8, t15);
    			insert_dev(target, t16, anchor);
    			insert_dev(target, hr, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$cart*/ 2 && img.src !== (img_src_value = /*order*/ ctx[4].imgs[/*order*/ ctx[4].color][/*order*/ ctx[4].featuredFace])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*$cart*/ 2 && t1_value !== (t1_value = /*order*/ ctx[4].name + "")) set_data_dev(t1, t1_value);
    			if (dirty & /*$cart*/ 2 && t3_value !== (t3_value = /*order*/ ctx[4].creator + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*$cart*/ 2) {
    				set_style(div1, "background-color", /*order*/ ctx[4].color);
    			}

    			if (dirty & /*$cart*/ 2 && t8_value !== (t8_value = /*order*/ ctx[4].size + "")) set_data_dev(t8, t8_value);
    			if (dirty & /*$cart*/ 2 && t11_value !== (t11_value = /*order*/ ctx[4].price + "")) set_data_dev(t11, t11_value);
    			if (dirty & /*$cart*/ 2 && t15_value !== (t15_value = /*order*/ ctx[4].quantity + "")) set_data_dev(t15, t15_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div11);
    			if (detaching) detach_dev(t16);
    			if (detaching) detach_dev(hr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(195:8) {#each Object.entries($cart.items) as [key, order]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div4;
    	let span0;
    	let t1;
    	let hr0;
    	let t2;
    	let div0;
    	let t3;
    	let div3;
    	let div1;
    	let span1;
    	let t5;
    	let span2;
    	let t7;
    	let t8;
    	let div2;
    	let span3;
    	let t9;
    	let t10;
    	let t11;
    	let span4;
    	let t13;
    	let t14;
    	let hr1;
    	let t15;
    	let span5;
    	let t16;
    	let t17;
    	let t18;
    	let t19;
    	let hr2;
    	let t20;
    	let a;
    	let mounted;
    	let dispose;
    	let each_value = Object.entries(/*$cart*/ ctx[1].items);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			span0 = element("span");
    			span0.textContent = "Order Summary";
    			t1 = space();
    			hr0 = element("hr");
    			t2 = space();
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			div3 = element("div");
    			div1 = element("div");
    			span1 = element("span");
    			span1.textContent = "Subtotal";
    			t5 = space();
    			span2 = element("span");
    			span2.textContent = "Shipping";
    			t7 = space();
    			t8 = space();
    			div2 = element("div");
    			span3 = element("span");
    			t9 = text(/*normalTotal*/ ctx[0]);
    			t10 = text(" DT");
    			t11 = space();
    			span4 = element("span");
    			span4.textContent = "Free";
    			t13 = space();
    			t14 = space();
    			hr1 = element("hr");
    			t15 = space();
    			span5 = element("span");
    			t16 = text("Total: ");
    			t17 = text(/*normalTotal*/ ctx[0]);
    			t18 = text(" DT");
    			t19 = space();
    			hr2 = element("hr");
    			t20 = space();
    			a = element("a");
    			a.textContent = "Back To Cart";
    			attr_dev(span0, "class", "title svelte-ylzvgj");
    			add_location(span0, file$w, 191, 4, 4460);
    			attr_dev(hr0, "class", "svelte-ylzvgj");
    			add_location(hr0, file$w, 192, 4, 4506);
    			attr_dev(div0, "class", "orders svelte-ylzvgj");
    			add_location(div0, file$w, 193, 4, 4518);
    			attr_dev(span1, "class", "subtotal svelte-ylzvgj");
    			add_location(span1, file$w, 227, 12, 5960);
    			attr_dev(span2, "class", "shipping svelte-ylzvgj");
    			add_location(span2, file$w, 228, 12, 6012);
    			attr_dev(div1, "class", "titles svelte-ylzvgj");
    			add_location(div1, file$w, 226, 8, 5926);
    			attr_dev(span3, "class", "subtotal svelte-ylzvgj");
    			add_location(span3, file$w, 237, 12, 6306);
    			attr_dev(span4, "class", "shipping svelte-ylzvgj");
    			add_location(span4, file$w, 238, 12, 6366);
    			attr_dev(div2, "class", "prices svelte-ylzvgj");
    			add_location(div2, file$w, 236, 8, 6272);
    			attr_dev(div3, "class", "final_total svelte-ylzvgj");
    			add_location(div3, file$w, 225, 4, 5891);
    			attr_dev(hr1, "class", "svelte-ylzvgj");
    			add_location(hr1, file$w, 242, 4, 6512);
    			attr_dev(span5, "class", "total svelte-ylzvgj");
    			add_location(span5, file$w, 243, 4, 6524);
    			attr_dev(hr2, "class", "svelte-ylzvgj");
    			add_location(hr2, file$w, 244, 4, 6580);
    			attr_dev(a, "href", "/cart");
    			attr_dev(a, "class", "back_to_cart svelte-ylzvgj");
    			add_location(a, file$w, 245, 4, 6592);
    			attr_dev(div4, "class", "container svelte-ylzvgj");
    			add_location(div4, file$w, 190, 0, 4431);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, span0);
    			append_dev(div4, t1);
    			append_dev(div4, hr0);
    			append_dev(div4, t2);
    			append_dev(div4, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div4, t3);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, span1);
    			append_dev(div1, t5);
    			append_dev(div1, span2);
    			append_dev(div1, t7);
    			append_dev(div3, t8);
    			append_dev(div3, div2);
    			append_dev(div2, span3);
    			append_dev(span3, t9);
    			append_dev(span3, t10);
    			append_dev(div2, t11);
    			append_dev(div2, span4);
    			append_dev(div2, t13);
    			append_dev(div4, t14);
    			append_dev(div4, hr1);
    			append_dev(div4, t15);
    			append_dev(div4, span5);
    			append_dev(span5, t16);
    			append_dev(span5, t17);
    			append_dev(span5, t18);
    			append_dev(div4, t19);
    			append_dev(div4, hr2);
    			append_dev(div4, t20);
    			append_dev(div4, a);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Object, $cart*/ 2) {
    				each_value = Object.entries(/*$cart*/ ctx[1].items);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*normalTotal*/ 1) set_data_dev(t9, /*normalTotal*/ ctx[0]);
    			if (dirty & /*normalTotal*/ 1) set_data_dev(t17, /*normalTotal*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let $cart;
    	validate_store(cart, "cart");
    	component_subscribe($$self, cart, $$value => $$invalidate(1, $cart = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("OrderSummary", slots, []);
    	console.log($cart);
    	let normalTotal = 0;

    	let unsubscribeCart = () => {
    		
    	};

    	unsubscribeCart = cart.subscribe(data => {
    		$$invalidate(0, normalTotal = Object.entries(data.items).reduce(
    			(acc, [key, value]) => {
    				acc += value.price * (value.quantity ? value.quantity : 1);
    				return acc;
    			},
    			0
    		));
    	});

    	onDestroy(() => {
    		unsubscribeCart();
    	});

    	const writable_props = [];

    	Object_1$c.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<OrderSummary> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		link,
    		cart,
    		onMount,
    		onDestroy,
    		normalTotal,
    		unsubscribeCart,
    		$cart
    	});

    	$$self.$inject_state = $$props => {
    		if ("normalTotal" in $$props) $$invalidate(0, normalTotal = $$props.normalTotal);
    		if ("unsubscribeCart" in $$props) unsubscribeCart = $$props.unsubscribeCart;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [normalTotal, $cart];
    }

    class OrderSummary extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OrderSummary",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* src\components\CheckoutPage\Checkout.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$d, console: console_1$c } = globals;
    const file$x = "src\\components\\CheckoutPage\\Checkout.svelte";

    // (90:0) {:else}
    function create_else_block$c(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "80px", height: "80px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-view svelte-14bbl0o");
    			add_location(div, file$x, 90, 4, 2429);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$c.name,
    		type: "else",
    		source: "(90:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (85:0) {#if validated}
    function create_if_block$h(ctx) {
    	let div;
    	let completion;
    	let t;
    	let summary;
    	let current;
    	completion = new OrderCompletion({ $$inline: true });
    	summary = new OrderSummary({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(completion.$$.fragment);
    			t = space();
    			create_component(summary.$$.fragment);
    			attr_dev(div, "class", "container svelte-14bbl0o");
    			add_location(div, file$x, 85, 4, 2334);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(completion, div, null);
    			append_dev(div, t);
    			mount_component(summary, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(completion.$$.fragment, local);
    			transition_in(summary.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(completion.$$.fragment, local);
    			transition_out(summary.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(completion);
    			destroy_component(summary);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(85:0) {#if validated}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$h, create_else_block$c];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*validated*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let $user;
    	let $cart;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(2, $user = $$value));
    	validate_store(cart, "cart");
    	component_subscribe($$self, cart, $$value => $$invalidate(3, $cart = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Checkout", slots, []);
    	let validated = false;

    	let unsubscribeUser = () => {
    		
    	};

    	onMount(() => {
    		console.log($user);

    		if (Object.keys($cart.items).length == 0) {
    			navigate("/cart", { replace: true });
    			return;
    		}

    		if (Object.entries($cart.items).filter(([id, value]) => value.size == undefined).length != 0) {
    			// no sizes
    			navigate("/cart?error=sizes", { replace: true });
    		}

    		unsubscribeUser = user.subscribe(v => {
    			console.log(v);

    			if (v == 0) {
    				return;
    			}

    			if (v == undefined) {
    				console.log("sending sign up");
    				navigate("/signup?backurl=/checkout", { replace: true });
    				return;
    			}

    			if (!v.phoneNumber) {
    				console.log("sending to phone verification");
    				navigate("/phoneverification?backurl=/checkout", { replace: true });
    				return;
    			} else if (!v.emailVerified) {
    				console.log("sending to email verification");
    				navigate("/emailverification?backurl=/checkout", { replace: true });
    				return;
    			}

    			$$invalidate(0, validated = true);
    		});
    	});

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	const writable_props = [];

    	Object_1$d.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$c.warn(`<Checkout> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Completion: OrderCompletion,
    		Summary: OrderSummary,
    		onDestroy,
    		onMount,
    		user,
    		navigate,
    		MaterialSpinner,
    		cart,
    		validated,
    		unsubscribeUser,
    		$user,
    		$cart
    	});

    	$$self.$inject_state = $$props => {
    		if ("validated" in $$props) $$invalidate(0, validated = $$props.validated);
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [validated];
    }

    class Checkout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Checkout",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* src\routes\CheckoutPage.svelte generated by Svelte v3.32.3 */

    function create_fragment$E(ctx) {
    	let checkout;
    	let current;
    	checkout = new Checkout({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(checkout.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkout, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkout.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkout.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkout, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CheckoutPage", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CheckoutPage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Checkout });
    	return [];
    }

    class CheckoutPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CheckoutPage",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src\components\misc\SigninProviders.svelte generated by Svelte v3.32.3 */
    const file$y = "src\\components\\misc\\SigninProviders.svelte";

    // (108:8) {:else}
    function create_else_block_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Google");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$4.name,
    		type: "else",
    		source: "(108:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (106:8) {#if subgoogle}
    function create_if_block_1$a(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(106:8) {#if subgoogle}",
    		ctx
    	});

    	return block;
    }

    // (118:8) {:else}
    function create_else_block$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Facebook");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$d.name,
    		type: "else",
    		source: "(118:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (116:8) {#if subfb}
    function create_if_block$i(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(116:8) {#if subfb}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let div4;
    	let div1;
    	let i0;
    	let t0;
    	let div0;
    	let current_block_type_index;
    	let if_block0;
    	let t1;
    	let div3;
    	let i1;
    	let t2;
    	let div2;
    	let current_block_type_index_1;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$a, create_else_block_1$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*subgoogle*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const if_block_creators_1 = [create_if_block$i, create_else_block$d];
    	const if_blocks_1 = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*subfb*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_1(ctx);
    	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			i0 = element("i");
    			t0 = space();
    			div0 = element("div");
    			if_block0.c();
    			t1 = space();
    			div3 = element("div");
    			i1 = element("i");
    			t2 = space();
    			div2 = element("div");
    			if_block1.c();
    			attr_dev(i0, "class", "fab fa-google-plus-g svelte-1lqlbmp");
    			add_location(i0, file$y, 103, 4, 2792);
    			attr_dev(div0, "class", "text svelte-1lqlbmp");
    			add_location(div0, file$y, 104, 4, 2832);
    			attr_dev(div1, "class", "googleBtn svelte-1lqlbmp");
    			add_location(div1, file$y, 102, 2, 2739);
    			attr_dev(i1, "class", "fab fa-facebook-f svelte-1lqlbmp");
    			add_location(i1, file$y, 113, 4, 3037);
    			attr_dev(div2, "class", "text svelte-1lqlbmp");
    			add_location(div2, file$y, 114, 4, 3074);
    			attr_dev(div3, "class", "fbBtn svelte-1lqlbmp");
    			add_location(div3, file$y, 112, 2, 2986);
    			attr_dev(div4, "class", "signupAlternatives svelte-1lqlbmp");
    			add_location(div4, file$y, 101, 0, 2703);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, i0);
    			append_dev(div1, t0);
    			append_dev(div1, div0);
    			if_blocks[current_block_type_index].m(div0, null);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, i1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			if_blocks_1[current_block_type_index_1].m(div2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*googleSignIn*/ ctx[2], false, false, false),
    					listen_dev(div3, "click", /*facebookSignIn*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div0, null);
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_1(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks_1[current_block_type_index_1];

    				if (!if_block1) {
    					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div2, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			if_blocks[current_block_type_index].d();
    			if_blocks_1[current_block_type_index_1].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SigninProviders", slots, []);
    	let { errorMessage } = $$props;
    	let subgoogle = false;

    	const googleSignIn = async () => {
    		if (subgoogle) {
    			return;
    		}

    		$$invalidate(0, subgoogle = true);
    		const googleProvider = new firebase.auth.GoogleAuthProvider();

    		await auth.signInWithPopup(googleProvider).then(result => {
    			
    		}).catch(error => {
    			// Handle Errors here.
    			error.code; /** @type {firebase.auth.OAuthCredential} */ // ...

    			$$invalidate(4, errorMessage = error.message);

    			// The email of the user's account used.
    			error.email;

    			// The firebase.auth.AuthCredential type that was used.
    			error.credential;
    		}); // ...

    		$$invalidate(0, subgoogle = false);
    	};

    	let subfb = false;

    	const facebookSignIn = async () => {
    		if (subfb) {
    			return;
    		}

    		$$invalidate(1, subfb = true);
    		const facebookProvider = new firebase.auth.FacebookAuthProvider();

    		await auth.signInWithPopup(facebookProvider).then(result => {
    			
    		}).catch(error => {
    			// Handle Errors here.
    			error.code; /** @type {firebase.auth.OAuthCredential} */ // ...

    			$$invalidate(4, errorMessage = error.message);

    			// The email of the user's account used.
    			error.email;

    			// The firebase.auth.AuthCredential type that was used.
    			error.credential;
    		}); // ...

    		$$invalidate(1, subfb = false);
    	};

    	const writable_props = ["errorMessage"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SigninProviders> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("errorMessage" in $$props) $$invalidate(4, errorMessage = $$props.errorMessage);
    	};

    	$$self.$capture_state = () => ({
    		auth,
    		MaterialSpinner,
    		errorMessage,
    		subgoogle,
    		googleSignIn,
    		subfb,
    		facebookSignIn
    	});

    	$$self.$inject_state = $$props => {
    		if ("errorMessage" in $$props) $$invalidate(4, errorMessage = $$props.errorMessage);
    		if ("subgoogle" in $$props) $$invalidate(0, subgoogle = $$props.subgoogle);
    		if ("subfb" in $$props) $$invalidate(1, subfb = $$props.subfb);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [subgoogle, subfb, googleSignIn, facebookSignIn, errorMessage];
    }

    class SigninProviders extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, { errorMessage: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SigninProviders",
    			options,
    			id: create_fragment$F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*errorMessage*/ ctx[4] === undefined && !("errorMessage" in props)) {
    			console.warn("<SigninProviders> was created without expected prop 'errorMessage'");
    		}
    	}

    	get errorMessage() {
    		throw new Error("<SigninProviders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set errorMessage(value) {
    		throw new Error("<SigninProviders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\routes\Signup.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$e, console: console_1$d } = globals;
    const file$z = "src\\routes\\Signup.svelte";

    // (113:16) {#if errorMessage}
    function create_if_block_1$b(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*errorMessage*/ ctx[3]);
    			attr_dev(div, "class", "error-container svelte-1gn2pih");
    			add_location(div, file$z, 113, 20, 4047);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errorMessage*/ 8) set_data_dev(t, /*errorMessage*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(113:16) {#if errorMessage}",
    		ctx
    	});

    	return block;
    }

    // (175:24) {:else}
    function create_else_block$e(ctx) {
    	let t_value = ({ en: "Sign Up", fr: "S'inscrire" })[/*$lang*/ ctx[4]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 16 && t_value !== (t_value = ({ en: "Sign Up", fr: "S'inscrire" })[/*$lang*/ ctx[4]] + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$e.name,
    		type: "else",
    		source: "(175:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (173:24) {#if sub}
    function create_if_block$j(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(173:24) {#if sub}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let div13;
    	let div12;
    	let div2;
    	let a0;
    	let img;
    	let img_src_value;
    	let t0;
    	let t1;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div11;
    	let div3;

    	let t6_value = ({
    		en: "Sign up to Unify",
    		fr: "Inscrivez-vous à Unify"
    	})[/*$lang*/ ctx[4]] + "";

    	let t6;
    	let t7;
    	let signinproviders;
    	let updating_errorMessage;
    	let t8;
    	let div4;

    	let t9_value = ({
    		en: "Or sign up using your email",
    		fr: "Ou inscrivez-vous en utilisant votre email"
    	})[/*$lang*/ ctx[4]] + "";

    	let t9;
    	let t10;
    	let div5;

    	let t11_value = ({
    		en: "Already have an account ? ",
    		fr: "Vous avez déjà un compte? "
    	})[/*$lang*/ ctx[4]] + "";

    	let t11;
    	let a1;

    	let t12_value = ({
    		en: "Sign in here ",
    		fr: "Se connecter ici"
    	})[/*$lang*/ ctx[4]] + "";

    	let t12;
    	let a1_href_value;
    	let t13;
    	let form_1;
    	let t14;
    	let div6;
    	let i0;
    	let t15;
    	let input0;
    	let input0_placeholder_value;
    	let t16;
    	let div7;
    	let i1;
    	let t17;
    	let input1;
    	let input1_placeholder_value;
    	let t18;
    	let div8;
    	let i2;
    	let t19;
    	let input2;
    	let input2_placeholder_value;
    	let t20;
    	let div9;
    	let i3;
    	let t21;
    	let input3;
    	let input3_placeholder_value;
    	let t22;
    	let div10;
    	let button;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;

    	function signinproviders_errorMessage_binding(value) {
    		/*signinproviders_errorMessage_binding*/ ctx[6](value);
    	}

    	let signinproviders_props = {};

    	if (/*errorMessage*/ ctx[3] !== void 0) {
    		signinproviders_props.errorMessage = /*errorMessage*/ ctx[3];
    	}

    	signinproviders = new SigninProviders({
    			props: signinproviders_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(signinproviders, "errorMessage", signinproviders_errorMessage_binding));
    	let if_block0 = /*errorMessage*/ ctx[3] && create_if_block_1$b(ctx);
    	const if_block_creators = [create_if_block$j, create_else_block$e];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*sub*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div13 = element("div");
    			div12 = element("div");
    			div2 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t0 = text("Unify");
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Did you know ?";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "When you buy a merch of a creator , you're supporting a dream";
    			t5 = space();
    			div11 = element("div");
    			div3 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			create_component(signinproviders.$$.fragment);
    			t8 = space();
    			div4 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			div5 = element("div");
    			t11 = text(t11_value);
    			a1 = element("a");
    			t12 = text(t12_value);
    			t13 = space();
    			form_1 = element("form");
    			if (if_block0) if_block0.c();
    			t14 = space();
    			div6 = element("div");
    			i0 = element("i");
    			t15 = space();
    			input0 = element("input");
    			t16 = space();
    			div7 = element("div");
    			i1 = element("i");
    			t17 = space();
    			input1 = element("input");
    			t18 = space();
    			div8 = element("div");
    			i2 = element("i");
    			t19 = space();
    			input2 = element("input");
    			t20 = space();
    			div9 = element("div");
    			i3 = element("i");
    			t21 = space();
    			input3 = element("input");
    			t22 = space();
    			div10 = element("div");
    			button = element("button");
    			if_block1.c();
    			if (img.src !== (img_src_value = "./img/logo.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "svelte-1gn2pih");
    			add_location(img, file$z, 82, 16, 2786);
    			attr_dev(a0, "href", "/");
    			attr_dev(a0, "class", "u_logo svelte-1gn2pih");
    			add_location(a0, file$z, 81, 12, 2732);
    			attr_dev(div0, "class", "title svelte-1gn2pih");
    			add_location(div0, file$z, 84, 12, 2862);
    			attr_dev(div1, "class", "desc svelte-1gn2pih");
    			add_location(div1, file$z, 85, 12, 2915);
    			attr_dev(div2, "class", "left_side svelte-1gn2pih");
    			add_location(div2, file$z, 80, 8, 2695);
    			attr_dev(div3, "class", "title svelte-1gn2pih");
    			add_location(div3, file$z, 93, 12, 3190);
    			attr_dev(div4, "class", "orEmailText svelte-1gn2pih");
    			add_location(div4, file$z, 98, 12, 3384);

    			attr_dev(a1, "href", a1_href_value = "/signin" + (/*backurl*/ ctx[0]
    			? "?backurl=" + /*backurl*/ ctx[0]
    			: ""));

    			attr_dev(a1, "class", "svelte-1gn2pih");
    			add_location(a1, file$z, 105, 21, 3704);
    			attr_dev(div5, "class", "have-acc svelte-1gn2pih");
    			add_location(div5, file$z, 102, 12, 3564);
    			attr_dev(i0, "class", "fas fa-user svelte-1gn2pih");
    			add_location(i0, file$z, 118, 20, 4226);
    			input0.required = true;
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "name svelte-1gn2pih");
    			attr_dev(input0, "placeholder", input0_placeholder_value = ({ en: "Name", fr: "Nom" })[/*$lang*/ ctx[4]]);
    			add_location(input0, file$z, 119, 20, 4273);
    			attr_dev(div6, "class", "input");
    			add_location(div6, file$z, 117, 16, 4185);
    			attr_dev(i1, "class", "fas fa-envelope svelte-1gn2pih");
    			add_location(i1, file$z, 137, 20, 4965);
    			input1.required = true;
    			attr_dev(input1, "type", "email");
    			attr_dev(input1, "class", "email svelte-1gn2pih");
    			attr_dev(input1, "placeholder", input1_placeholder_value = ({ en: "Email", fr: "Email" })[/*$lang*/ ctx[4]]);
    			add_location(input1, file$z, 138, 20, 5016);
    			attr_dev(div7, "class", "input");
    			add_location(div7, file$z, 136, 16, 4924);
    			attr_dev(i2, "class", "fas fa-unlock-alt svelte-1gn2pih");
    			add_location(i2, file$z, 146, 20, 5318);
    			input2.required = true;
    			attr_dev(input2, "type", "password");
    			attr_dev(input2, "class", "password svelte-1gn2pih");
    			attr_dev(input2, "placeholder", input2_placeholder_value = ({ en: "Password", fr: "Mot de passe" })[/*$lang*/ ctx[4]]);
    			add_location(input2, file$z, 147, 20, 5371);
    			attr_dev(div8, "class", "input");
    			add_location(div8, file$z, 145, 16, 5277);
    			attr_dev(i3, "class", "fas fa-unlock-alt svelte-1gn2pih");
    			add_location(i3, file$z, 158, 20, 5789);
    			input3.required = true;
    			attr_dev(input3, "type", "password");
    			attr_dev(input3, "class", "re_password svelte-1gn2pih");

    			attr_dev(input3, "placeholder", input3_placeholder_value = ({
    				en: "Confirm Password",
    				fr: "Confirmez le mot de passe"
    			})[/*$lang*/ ctx[4]]);

    			add_location(input3, file$z, 159, 20, 5842);
    			attr_dev(div9, "class", "input");
    			add_location(div9, file$z, 157, 16, 5748);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "signup_btn svelte-1gn2pih");
    			add_location(button, file$z, 171, 20, 6313);
    			attr_dev(div10, "class", "signup svelte-1gn2pih");
    			add_location(div10, file$z, 170, 16, 6271);
    			attr_dev(form_1, "class", "inputContainer svelte-1gn2pih");
    			add_location(form_1, file$z, 111, 12, 3924);
    			attr_dev(div11, "class", "right_side svelte-1gn2pih");
    			add_location(div11, file$z, 92, 8, 3152);
    			attr_dev(div12, "class", "signUp_container svelte-1gn2pih");
    			add_location(div12, file$z, 79, 4, 2655);
    			attr_dev(div13, "class", "container");
    			add_location(div13, file$z, 78, 0, 2626);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div13, anchor);
    			append_dev(div13, div12);
    			append_dev(div12, div2);
    			append_dev(div2, a0);
    			append_dev(a0, img);
    			append_dev(a0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div12, t5);
    			append_dev(div12, div11);
    			append_dev(div11, div3);
    			append_dev(div3, t6);
    			append_dev(div11, t7);
    			mount_component(signinproviders, div11, null);
    			append_dev(div11, t8);
    			append_dev(div11, div4);
    			append_dev(div4, t9);
    			append_dev(div11, t10);
    			append_dev(div11, div5);
    			append_dev(div5, t11);
    			append_dev(div5, a1);
    			append_dev(a1, t12);
    			append_dev(div11, t13);
    			append_dev(div11, form_1);
    			if (if_block0) if_block0.m(form_1, null);
    			append_dev(form_1, t14);
    			append_dev(form_1, div6);
    			append_dev(div6, i0);
    			append_dev(div6, t15);
    			append_dev(div6, input0);
    			/*input0_binding*/ ctx[7](input0);
    			append_dev(form_1, t16);
    			append_dev(form_1, div7);
    			append_dev(div7, i1);
    			append_dev(div7, t17);
    			append_dev(div7, input1);
    			/*input1_binding*/ ctx[8](input1);
    			append_dev(form_1, t18);
    			append_dev(form_1, div8);
    			append_dev(div8, i2);
    			append_dev(div8, t19);
    			append_dev(div8, input2);
    			/*input2_binding*/ ctx[9](input2);
    			append_dev(form_1, t20);
    			append_dev(form_1, div9);
    			append_dev(div9, i3);
    			append_dev(div9, t21);
    			append_dev(div9, input3);
    			/*input3_binding*/ ctx[10](input3);
    			append_dev(form_1, t22);
    			append_dev(form_1, div10);
    			append_dev(div10, button);
    			if_blocks[current_block_type_index].m(button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					listen_dev(form_1, "submit", prevent_default(/*doSubmit*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$lang*/ 16) && t6_value !== (t6_value = ({
    				en: "Sign up to Unify",
    				fr: "Inscrivez-vous à Unify"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t6, t6_value);

    			const signinproviders_changes = {};

    			if (!updating_errorMessage && dirty & /*errorMessage*/ 8) {
    				updating_errorMessage = true;
    				signinproviders_changes.errorMessage = /*errorMessage*/ ctx[3];
    				add_flush_callback(() => updating_errorMessage = false);
    			}

    			signinproviders.$set(signinproviders_changes);

    			if ((!current || dirty & /*$lang*/ 16) && t9_value !== (t9_value = ({
    				en: "Or sign up using your email",
    				fr: "Ou inscrivez-vous en utilisant votre email"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t9, t9_value);

    			if ((!current || dirty & /*$lang*/ 16) && t11_value !== (t11_value = ({
    				en: "Already have an account ? ",
    				fr: "Vous avez déjà un compte? "
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t11, t11_value);

    			if ((!current || dirty & /*$lang*/ 16) && t12_value !== (t12_value = ({
    				en: "Sign in here ",
    				fr: "Se connecter ici"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t12, t12_value);

    			if (!current || dirty & /*backurl*/ 1 && a1_href_value !== (a1_href_value = "/signin" + (/*backurl*/ ctx[0]
    			? "?backurl=" + /*backurl*/ ctx[0]
    			: ""))) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (/*errorMessage*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$b(ctx);
    					if_block0.c();
    					if_block0.m(form_1, t14);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty & /*$lang*/ 16 && input0_placeholder_value !== (input0_placeholder_value = ({ en: "Name", fr: "Nom" })[/*$lang*/ ctx[4]])) {
    				attr_dev(input0, "placeholder", input0_placeholder_value);
    			}

    			if (!current || dirty & /*$lang*/ 16 && input1_placeholder_value !== (input1_placeholder_value = ({ en: "Email", fr: "Email" })[/*$lang*/ ctx[4]])) {
    				attr_dev(input1, "placeholder", input1_placeholder_value);
    			}

    			if (!current || dirty & /*$lang*/ 16 && input2_placeholder_value !== (input2_placeholder_value = ({ en: "Password", fr: "Mot de passe" })[/*$lang*/ ctx[4]])) {
    				attr_dev(input2, "placeholder", input2_placeholder_value);
    			}

    			if (!current || dirty & /*$lang*/ 16 && input3_placeholder_value !== (input3_placeholder_value = ({
    				en: "Confirm Password",
    				fr: "Confirmez le mot de passe"
    			})[/*$lang*/ ctx[4]])) {
    				attr_dev(input3, "placeholder", input3_placeholder_value);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(button, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(signinproviders.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(signinproviders.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div13);
    			destroy_component(signinproviders);
    			if (if_block0) if_block0.d();
    			/*input0_binding*/ ctx[7](null);
    			/*input1_binding*/ ctx[8](null);
    			/*input2_binding*/ ctx[9](null);
    			/*input3_binding*/ ctx[10](null);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(4, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Signup", slots, []);

    	let unsubscribeUser = () => {
    		
    	};

    	let backurl = "";
    	let params;
    	let newRegister = false;

    	onMount(() => {
    		document.title = "Unify - Signup";
    		params = new URLSearchParams(location.search);
    		$$invalidate(0, backurl = params.get("backurl") || "");

    		unsubscribeUser = user.subscribe(v => {
    			if (v == 0) {
    				console.log("uninited");
    			} else if (v) {
    				if (newRegister == false) {
    					if (params.get("backurl") != null) {
    						navigate(params.get("backurl"), { replace: true });
    					} else {
    						navigate("/myaccount", { replace: true });
    					}
    				} else {
    					if (params.get("backurl")) {
    						navigate("/phoneverification?backurl=" + params.get("backurl"), { replace: true });
    					} else {
    						navigate("/phoneverification", { replace: true });
    					}
    				}
    			}
    		});
    	});

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	let sub = false;

    	const doSubmit = async () => {
    		$$invalidate(1, sub = true);
    		$$invalidate(3, errorMessage = undefined);
    		let lform = Object.fromEntries(Object.entries(form).map(([key, el]) => [key, el.value]));

    		if (lform.repassword != lform.password) {
    			$$invalidate(3, errorMessage = "Passwords do not match");
    			$$invalidate(1, sub = false);
    			return;
    		}

    		await auth.createUserWithEmailAndPassword(lform.email, lform.password).then(async result => {
    			console.log(result.user);
    			await result.user.updateProfile({ displayName: lform.name });
    			new URLSearchParams(location.search);
    			analytics.logEvent("front-signup");
    			newRegister = true;
    			$$invalidate(1, sub = false);
    		}).catch(error => {
    			$$invalidate(3, errorMessage = error.message);
    			$$invalidate(1, sub = false);
    		});

    		$$invalidate(1, sub = false);
    	};

    	const form = {};
    	let errorMessage = undefined;
    	const writable_props = [];

    	Object_1$e.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$d.warn(`<Signup> was created with unknown prop '${key}'`);
    	});

    	function signinproviders_errorMessage_binding(value) {
    		errorMessage = value;
    		$$invalidate(3, errorMessage);
    	}

    	function input0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			form.name = $$value;
    			$$invalidate(2, form);
    		});
    	}

    	function input1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			form.email = $$value;
    			$$invalidate(2, form);
    		});
    	}

    	function input2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			form.password = $$value;
    			$$invalidate(2, form);
    		});
    	}

    	function input3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			form.repassword = $$value;
    			$$invalidate(2, form);
    		});
    	}

    	$$self.$capture_state = () => ({
    		auth,
    		user,
    		analytics,
    		navigate,
    		link,
    		MaterialSpinner,
    		SignInProviders: SigninProviders,
    		onMount,
    		onDestroy,
    		lang,
    		getBackurl,
    		unsubscribeUser,
    		backurl,
    		params,
    		newRegister,
    		sub,
    		doSubmit,
    		form,
    		errorMessage,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    		if ("backurl" in $$props) $$invalidate(0, backurl = $$props.backurl);
    		if ("params" in $$props) params = $$props.params;
    		if ("newRegister" in $$props) newRegister = $$props.newRegister;
    		if ("sub" in $$props) $$invalidate(1, sub = $$props.sub);
    		if ("errorMessage" in $$props) $$invalidate(3, errorMessage = $$props.errorMessage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		backurl,
    		sub,
    		form,
    		errorMessage,
    		$lang,
    		doSubmit,
    		signinproviders_errorMessage_binding,
    		input0_binding,
    		input1_binding,
    		input2_binding,
    		input3_binding
    	];
    }

    class Signup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Signup",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    /* src\routes\Signin.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$f, console: console_1$e } = globals;
    const file$A = "src\\routes\\Signin.svelte";

    // (335:15) {#if errorMessage}
    function create_if_block_1$c(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*errorMessage*/ ctx[3]);
    			attr_dev(div, "class", "error-container svelte-p6mq1e");
    			add_location(div, file$A, 335, 20, 9319);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errorMessage*/ 8) set_data_dev(t, /*errorMessage*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(335:15) {#if errorMessage}",
    		ctx
    	});

    	return block;
    }

    // (370:24) {:else}
    function create_else_block$f(ctx) {
    	let t_value = ({ en: "Sign in", fr: "S'identifier" })[/*$lang*/ ctx[4]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 16 && t_value !== (t_value = ({ en: "Sign in", fr: "S'identifier" })[/*$lang*/ ctx[4]] + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$f.name,
    		type: "else",
    		source: "(370:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (368:24) {#if sub}
    function create_if_block$k(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(368:24) {#if sub}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let div12;
    	let div11;
    	let div2;
    	let a0;
    	let img;
    	let img_src_value;
    	let t0;
    	let t1;
    	let div0;
    	let t3;
    	let div1;
    	let t5;
    	let div10;
    	let div3;

    	let t6_value = ({
    		en: "Sign in to Unify",
    		fr: "Connectez-vous à Unify"
    	})[/*$lang*/ ctx[4]] + "";

    	let t6;
    	let t7;
    	let signinproviders;
    	let updating_errorMessage;
    	let t8;
    	let div4;

    	let t9_value = ({
    		en: "Or use your email account",
    		fr: "Ou utilisez votre compte e-mail"
    	})[/*$lang*/ ctx[4]] + "";

    	let t9;
    	let t10;
    	let div5;

    	let t11_value = ({
    		en: "Don't have an account ?",
    		fr: "Vous n'avez pas de compte?"
    	})[/*$lang*/ ctx[4]] + "";

    	let t11;
    	let t12;
    	let a1;

    	let t13_value = ({
    		en: "Sign up here",
    		fr: "Inscrivez-vous ici"
    	})[/*$lang*/ ctx[4]] + "";

    	let t13;
    	let a1_href_value;
    	let t14;
    	let form_1;
    	let t15;
    	let div6;
    	let i0;
    	let t16;
    	let input0;
    	let input0_placeholder_value;
    	let t17;
    	let div7;
    	let i1;
    	let t18;
    	let input1;
    	let input1_placeholder_value;
    	let t19;
    	let div8;
    	let a2;

    	let t20_value = ({
    		en: "Forget Your Password?",
    		fr: "Mot de passe oublié?"
    	})[/*$lang*/ ctx[4]] + "";

    	let t20;
    	let t21;
    	let div9;
    	let button;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let mounted;
    	let dispose;

    	function signinproviders_errorMessage_binding(value) {
    		/*signinproviders_errorMessage_binding*/ ctx[6](value);
    	}

    	let signinproviders_props = {};

    	if (/*errorMessage*/ ctx[3] !== void 0) {
    		signinproviders_props.errorMessage = /*errorMessage*/ ctx[3];
    	}

    	signinproviders = new SigninProviders({
    			props: signinproviders_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(signinproviders, "errorMessage", signinproviders_errorMessage_binding));
    	let if_block0 = /*errorMessage*/ ctx[3] && create_if_block_1$c(ctx);
    	const if_block_creators = [create_if_block$k, create_else_block$f];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*sub*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div12 = element("div");
    			div11 = element("div");
    			div2 = element("div");
    			a0 = element("a");
    			img = element("img");
    			t0 = text("Unify");
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Dear community,";
    			t3 = space();
    			div1 = element("div");
    			div1.textContent = "One of the greatest gifts a creator can get is SUPPORT.";
    			t5 = space();
    			div10 = element("div");
    			div3 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			create_component(signinproviders.$$.fragment);
    			t8 = space();
    			div4 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			div5 = element("div");
    			t11 = text(t11_value);
    			t12 = space();
    			a1 = element("a");
    			t13 = text(t13_value);
    			t14 = space();
    			form_1 = element("form");
    			if (if_block0) if_block0.c();
    			t15 = space();
    			div6 = element("div");
    			i0 = element("i");
    			t16 = space();
    			input0 = element("input");
    			t17 = space();
    			div7 = element("div");
    			i1 = element("i");
    			t18 = space();
    			input1 = element("input");
    			t19 = space();
    			div8 = element("div");
    			a2 = element("a");
    			t20 = text(t20_value);
    			t21 = space();
    			div9 = element("div");
    			button = element("button");
    			if_block1.c();
    			if (img.src !== (img_src_value = "./img/icon.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "svelte-p6mq1e");
    			add_location(img, file$A, 298, 16, 7862);
    			attr_dev(a0, "href", "/");
    			attr_dev(a0, "class", "u_logo svelte-p6mq1e");
    			add_location(a0, file$A, 297, 12, 7808);
    			attr_dev(div0, "class", "title svelte-p6mq1e");
    			add_location(div0, file$A, 300, 12, 7938);
    			attr_dev(div1, "class", "desc svelte-p6mq1e");
    			add_location(div1, file$A, 301, 12, 7992);
    			attr_dev(div2, "class", "left_side svelte-p6mq1e");
    			add_location(div2, file$A, 296, 8, 7771);
    			attr_dev(div3, "class", "title svelte-p6mq1e");
    			add_location(div3, file$A, 309, 12, 8270);
    			attr_dev(div4, "class", "orEmailText svelte-p6mq1e");
    			add_location(div4, file$A, 316, 12, 8520);

    			attr_dev(a1, "href", a1_href_value = "/signup" + (/*backurl*/ ctx[1]
    			? "?backurl=" + /*backurl*/ ctx[1]
    			: ""));

    			attr_dev(a1, "class", "svelte-p6mq1e");
    			add_location(a1, file$A, 327, 17, 8940);
    			attr_dev(div5, "class", "no-have-acc svelte-p6mq1e");
    			add_location(div5, file$A, 322, 12, 8743);
    			attr_dev(i0, "class", "fas fa-envelope svelte-p6mq1e");
    			add_location(i0, file$A, 340, 20, 9498);
    			attr_dev(input0, "type", "email");
    			attr_dev(input0, "class", "email svelte-p6mq1e");
    			attr_dev(input0, "placeholder", input0_placeholder_value = "\r\n                    " + ({ en: "Email", fr: "Email" })[/*$lang*/ ctx[4]] + "\r\n                ");
    			add_location(input0, file$A, 341, 16, 9547);
    			attr_dev(div6, "class", "input");
    			add_location(div6, file$A, 339, 16, 9457);
    			attr_dev(i1, "class", "fas fa-unlock-alt svelte-p6mq1e");
    			add_location(i1, file$A, 351, 20, 9885);
    			attr_dev(input1, "type", "password");
    			attr_dev(input1, "class", "password svelte-p6mq1e");
    			attr_dev(input1, "placeholder", input1_placeholder_value = ({ en: "Password", fr: "Mot de passe" })[/*$lang*/ ctx[4]]);
    			add_location(input1, file$A, 352, 16, 9936);
    			attr_dev(div7, "class", "input");
    			add_location(div7, file$A, 350, 16, 9844);
    			attr_dev(a2, "href", "/forgotpassword");
    			add_location(a2, file$A, 359, 36, 10233);
    			attr_dev(div8, "class", "forget svelte-p6mq1e");
    			add_location(div8, file$A, 359, 16, 10213);
    			attr_dev(button, "type", "submit");
    			attr_dev(button, "class", "signup_btn svelte-p6mq1e");
    			add_location(button, file$A, 366, 20, 10522);
    			attr_dev(div9, "class", "signup svelte-p6mq1e");
    			add_location(div9, file$A, 365, 16, 10480);
    			attr_dev(form_1, "class", "inputContainer svelte-p6mq1e");
    			add_location(form_1, file$A, 333, 12, 9197);
    			attr_dev(div10, "class", "right_side svelte-p6mq1e");
    			add_location(div10, file$A, 308, 8, 8231);
    			attr_dev(div11, "class", "signUp_container svelte-p6mq1e");
    			add_location(div11, file$A, 295, 4, 7731);
    			attr_dev(div12, "class", "container");
    			add_location(div12, file$A, 294, 0, 7702);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div12, anchor);
    			append_dev(div12, div11);
    			append_dev(div11, div2);
    			append_dev(div2, a0);
    			append_dev(a0, img);
    			append_dev(a0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div11, t5);
    			append_dev(div11, div10);
    			append_dev(div10, div3);
    			append_dev(div3, t6);
    			append_dev(div10, t7);
    			mount_component(signinproviders, div10, null);
    			append_dev(div10, t8);
    			append_dev(div10, div4);
    			append_dev(div4, t9);
    			append_dev(div10, t10);
    			append_dev(div10, div5);
    			append_dev(div5, t11);
    			append_dev(div5, t12);
    			append_dev(div5, a1);
    			append_dev(a1, t13);
    			append_dev(div10, t14);
    			append_dev(div10, form_1);
    			if (if_block0) if_block0.m(form_1, null);
    			append_dev(form_1, t15);
    			append_dev(form_1, div6);
    			append_dev(div6, i0);
    			append_dev(div6, t16);
    			append_dev(div6, input0);
    			/*input0_binding*/ ctx[7](input0);
    			append_dev(form_1, t17);
    			append_dev(form_1, div7);
    			append_dev(div7, i1);
    			append_dev(div7, t18);
    			append_dev(div7, input1);
    			/*input1_binding*/ ctx[8](input1);
    			append_dev(form_1, t19);
    			append_dev(form_1, div8);
    			append_dev(div8, a2);
    			append_dev(a2, t20);
    			append_dev(form_1, t21);
    			append_dev(form_1, div9);
    			append_dev(div9, button);
    			if_blocks[current_block_type_index].m(button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					action_destroyer(link.call(null, a2)),
    					listen_dev(form_1, "submit", prevent_default(/*doSubmit*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$lang*/ 16) && t6_value !== (t6_value = ({
    				en: "Sign in to Unify",
    				fr: "Connectez-vous à Unify"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t6, t6_value);

    			const signinproviders_changes = {};

    			if (!updating_errorMessage && dirty & /*errorMessage*/ 8) {
    				updating_errorMessage = true;
    				signinproviders_changes.errorMessage = /*errorMessage*/ ctx[3];
    				add_flush_callback(() => updating_errorMessage = false);
    			}

    			signinproviders.$set(signinproviders_changes);

    			if ((!current || dirty & /*$lang*/ 16) && t9_value !== (t9_value = ({
    				en: "Or use your email account",
    				fr: "Ou utilisez votre compte e-mail"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t9, t9_value);

    			if ((!current || dirty & /*$lang*/ 16) && t11_value !== (t11_value = ({
    				en: "Don't have an account ?",
    				fr: "Vous n'avez pas de compte?"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t11, t11_value);

    			if ((!current || dirty & /*$lang*/ 16) && t13_value !== (t13_value = ({
    				en: "Sign up here",
    				fr: "Inscrivez-vous ici"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t13, t13_value);

    			if (!current || dirty & /*backurl*/ 2 && a1_href_value !== (a1_href_value = "/signup" + (/*backurl*/ ctx[1]
    			? "?backurl=" + /*backurl*/ ctx[1]
    			: ""))) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (/*errorMessage*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$c(ctx);
    					if_block0.c();
    					if_block0.m(form_1, t15);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!current || dirty & /*$lang*/ 16 && input0_placeholder_value !== (input0_placeholder_value = "\r\n                    " + ({ en: "Email", fr: "Email" })[/*$lang*/ ctx[4]] + "\r\n                ")) {
    				attr_dev(input0, "placeholder", input0_placeholder_value);
    			}

    			if (!current || dirty & /*$lang*/ 16 && input1_placeholder_value !== (input1_placeholder_value = ({ en: "Password", fr: "Mot de passe" })[/*$lang*/ ctx[4]])) {
    				attr_dev(input1, "placeholder", input1_placeholder_value);
    			}

    			if ((!current || dirty & /*$lang*/ 16) && t20_value !== (t20_value = ({
    				en: "Forget Your Password?",
    				fr: "Mot de passe oublié?"
    			})[/*$lang*/ ctx[4]] + "")) set_data_dev(t20, t20_value);

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(button, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(signinproviders.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(signinproviders.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div12);
    			destroy_component(signinproviders);
    			if (if_block0) if_block0.d();
    			/*input0_binding*/ ctx[7](null);
    			/*input1_binding*/ ctx[8](null);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(4, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Signin", slots, []);

    	let unsubscribeUser = () => {
    		
    	};

    	let sub = false;
    	let params;
    	let backurl = "";
    	let newLogin = false;

    	onMount(() => {
    		params = new URLSearchParams(location.search);
    		$$invalidate(1, backurl = params.get("backurl") || "");
    		document.title = "Unify - Signin";

    		unsubscribeUser = user.subscribe(v => {
    			if (v == 0) {
    				console.log("uninited");
    			} else if (v) {
    				if (newLogin == false) {
    					if (params.get("backurl") != null) {
    						navigate(params.get("backurl"), { replace: true });
    					} else {
    						navigate("/myaccount", { replace: true });
    					}
    				}
    			}
    		});
    	});

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	const doSubmit = async () => {
    		if (sub) {
    			return;
    		}

    		$$invalidate(0, sub = true);
    		let lform = Object.fromEntries(Object.entries(form).map(([key, el]) => [key, el.value]));

    		await firebase.auth().signInWithEmailAndPassword(lform.email, lform.password).then(user => {
    			newLogin = true;
    			$$invalidate(0, sub = false);
    		}).catch(error => {
    			$$invalidate(3, errorMessage = error.message);
    			$$invalidate(0, sub = false);
    		});

    		$$invalidate(0, sub = false);
    	};

    	const form = {};
    	let errorMessage = undefined;
    	let subgoogle = false;

    	const googleSignIn = async () => {
    		if (subgoogle) {
    			return;
    		}

    		subgoogle = true;
    		const googleProvider = new firebase.auth.GoogleAuthProvider();

    		await auth.signInWithPopup(googleProvider).then(result => {
    			
    		}).catch(error => {
    			// Handle Errors here.
    			error.code; /** @type {firebase.auth.OAuthCredential} */ // ...

    			$$invalidate(3, errorMessage = error.message);

    			// The email of the user's account used.
    			error.email;

    			// The firebase.auth.AuthCredential type that was used.
    			error.credential;
    		}); // ...

    		subgoogle = false;
    	};

    	let subfb = false;

    	const facebookSignIn = async () => {
    		if (subfb) {
    			return;
    		}

    		subfb = true;
    		const facebookProvider = new firebase.auth.FacebookAuthProvider();

    		await auth.signInWithPopup(facebookProvider).then(result => {
    			
    		}).catch(error => {
    			// Handle Errors here.
    			error.code; /** @type {firebase.auth.OAuthCredential} */ // ...

    			$$invalidate(3, errorMessage = error.message);

    			// The email of the user's account used.
    			error.email;

    			// The firebase.auth.AuthCredential type that was used.
    			error.credential;
    		}); // ...

    		subfb = false;
    	};

    	const writable_props = [];

    	Object_1$f.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$e.warn(`<Signin> was created with unknown prop '${key}'`);
    	});

    	function signinproviders_errorMessage_binding(value) {
    		errorMessage = value;
    		$$invalidate(3, errorMessage);
    	}

    	function input0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			form.email = $$value;
    			$$invalidate(2, form);
    		});
    	}

    	function input1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			form.password = $$value;
    			$$invalidate(2, form);
    		});
    	}

    	$$self.$capture_state = () => ({
    		link,
    		navigate,
    		auth,
    		user,
    		onMount,
    		onDestroy,
    		MaterialSpinner,
    		SignInProviders: SigninProviders,
    		lang,
    		unsubscribeUser,
    		sub,
    		params,
    		backurl,
    		newLogin,
    		doSubmit,
    		form,
    		errorMessage,
    		subgoogle,
    		googleSignIn,
    		subfb,
    		facebookSignIn,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    		if ("sub" in $$props) $$invalidate(0, sub = $$props.sub);
    		if ("params" in $$props) params = $$props.params;
    		if ("backurl" in $$props) $$invalidate(1, backurl = $$props.backurl);
    		if ("newLogin" in $$props) newLogin = $$props.newLogin;
    		if ("errorMessage" in $$props) $$invalidate(3, errorMessage = $$props.errorMessage);
    		if ("subgoogle" in $$props) subgoogle = $$props.subgoogle;
    		if ("subfb" in $$props) subfb = $$props.subfb;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		sub,
    		backurl,
    		form,
    		errorMessage,
    		$lang,
    		doSubmit,
    		signinproviders_errorMessage_binding,
    		input0_binding,
    		input1_binding
    	];
    }

    class Signin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Signin",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src\routes\PhoneVerification.svelte generated by Svelte v3.32.3 */

    const { console: console_1$f } = globals;
    const file$B = "src\\routes\\PhoneVerification.svelte";

    // (203:4) {:else}
    function create_else_block_2$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Success: Phone Updated.";
    			attr_dev(div, "class", "title svelte-1g92s3b");
    			add_location(div, file$B, 203, 8, 6895);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$1.name,
    		type: "else",
    		source: "(203:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (153:4) {#if succOperation == false}
    function create_if_block$l(ctx) {
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let form;
    	let i;
    	let t2;
    	let input;
    	let input_value_value;
    	let t3;
    	let t4;
    	let div3;
    	let t5;
    	let div2;
    	let button;
    	let current_block_type_index;
    	let if_block4;
    	let current;
    	let mounted;
    	let dispose;

    	function select_block_type_1(ctx, dirty) {
    		if (/*$user*/ ctx[6] && /*$user*/ ctx[6].phoneNumber) return create_if_block_5$3;
    		return create_else_block_1$5;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*errorMessage*/ ctx[3] && create_if_block_4$4(ctx);
    	let if_block2 = /*confResInitied*/ ctx[2] && create_if_block_3$6(ctx);
    	let if_block3 = /*confResInitied*/ ctx[2] && create_if_block_2$6(ctx);
    	const if_block_creators = [create_if_block_1$d, create_else_block$g];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*sendingCode*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			div1 = element("div");
    			form = element("form");
    			i = element("i");
    			t2 = space();
    			input = element("input");
    			t3 = space();
    			if (if_block2) if_block2.c();
    			t4 = space();
    			div3 = element("div");
    			if (if_block3) if_block3.c();
    			t5 = space();
    			div2 = element("div");
    			button = element("button");
    			if_block4.c();
    			attr_dev(div0, "class", "title svelte-1g92s3b");
    			add_location(div0, file$B, 153, 4, 5264);
    			attr_dev(i, "class", "fas fa-phone svelte-1g92s3b");
    			add_location(i, file$B, 167, 12, 5677);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "verification svelte-1g92s3b");
    			attr_dev(input, "placeholder", "Phone Number");

    			input.value = input_value_value = /*$user*/ ctx[6] && /*$user*/ ctx[6].phoneNumber
    			? /*$user*/ ctx[6].phoneNumber
    			: "";

    			add_location(input, file$B, 168, 12, 5717);
    			attr_dev(form, "class", "input");
    			add_location(form, file$B, 166, 8, 5607);
    			attr_dev(div1, "class", "inputContainer svelte-1g92s3b");
    			add_location(div1, file$B, 165, 4, 5569);
    			attr_dev(button, "id", "sign-in-button");
    			attr_dev(button, "class", "resend_btn svelte-1g92s3b");
    			add_location(button, file$B, 193, 12, 6604);
    			attr_dev(div2, "class", "resend");
    			add_location(div2, file$B, 192, 8, 6570);
    			attr_dev(div3, "class", "verification_btns svelte-1g92s3b");
    			add_location(div3, file$B, 188, 4, 6383);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			if_block0.m(div0, null);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, form);
    			append_dev(form, i);
    			append_dev(form, t2);
    			append_dev(form, input);
    			/*input_binding*/ ctx[9](input);
    			append_dev(div1, t3);
    			if (if_block2) if_block2.m(div1, null);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, div3, anchor);
    			if (if_block3) if_block3.m(div3, null);
    			append_dev(div3, t5);
    			append_dev(div3, div2);
    			append_dev(div2, button);
    			if_blocks[current_block_type_index].m(button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(form, "submit", prevent_default(/*SendCode*/ ctx[7]), false, true, false),
    					listen_dev(button, "click", /*SendCode*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div0, null);
    				}
    			}

    			if (/*errorMessage*/ ctx[3]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_4$4(ctx);
    					if_block1.c();
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (!current || dirty & /*$user*/ 64 && input_value_value !== (input_value_value = /*$user*/ ctx[6] && /*$user*/ ctx[6].phoneNumber
    			? /*$user*/ ctx[6].phoneNumber
    			: "") && input.value !== input_value_value) {
    				prop_dev(input, "value", input_value_value);
    			}

    			if (/*confResInitied*/ ctx[2]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);
    				} else {
    					if_block2 = create_if_block_3$6(ctx);
    					if_block2.c();
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if (/*confResInitied*/ ctx[2]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_2$6(ctx);
    					if_block3.c();
    					if_block3.m(div3, t5);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block4 = if_blocks[current_block_type_index];

    				if (!if_block4) {
    					if_block4 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block4.c();
    				}

    				transition_in(if_block4, 1);
    				if_block4.m(button, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if_block0.d();
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			/*input_binding*/ ctx[9](null);
    			if (if_block2) if_block2.d();
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(div3);
    			if (if_block3) if_block3.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(153:4) {#if succOperation == false}",
    		ctx
    	});

    	return block;
    }

    // (157:8) {:else}
    function create_else_block_1$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Verify your phone number");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$5.name,
    		type: "else",
    		source: "(157:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (155:8) {#if $user && $user.phoneNumber}
    function create_if_block_5$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Update your phone number");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(155:8) {#if $user && $user.phoneNumber}",
    		ctx
    	});

    	return block;
    }

    // (161:4) {#if errorMessage}
    function create_if_block_4$4(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*errorMessage*/ ctx[3]);
    			attr_dev(div, "class", "error-container svelte-1g92s3b");
    			add_location(div, file$B, 161, 8, 5479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errorMessage*/ 8) set_data_dev(t, /*errorMessage*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(161:4) {#if errorMessage}",
    		ctx
    	});

    	return block;
    }

    // (177:8) {#if confResInitied}
    function create_if_block_3$6(ctx) {
    	let form;
    	let i;
    	let t;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			form = element("form");
    			i = element("i");
    			t = space();
    			input = element("input");
    			attr_dev(i, "class", "fas fa-key svelte-1g92s3b");
    			add_location(i, file$B, 178, 16, 6099);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "verification svelte-1g92s3b");
    			attr_dev(input, "placeholder", "Verification Code");
    			add_location(input, file$B, 179, 16, 6141);
    			attr_dev(form, "class", "input");
    			add_location(form, file$B, 177, 12, 6023);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, i);
    			append_dev(form, t);
    			append_dev(form, input);
    			/*input_binding_1*/ ctx[10](input);

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*verifyCode*/ ctx[8]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			/*input_binding_1*/ ctx[10](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(177:8) {#if confResInitied}",
    		ctx
    	});

    	return block;
    }

    // (190:8) {#if confResInitied}
    function create_if_block_2$6(ctx) {
    	let div;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "Verify";
    			attr_dev(button, "class", "send_btn svelte-1g92s3b");
    			add_location(button, file$B, 190, 30, 6476);
    			attr_dev(div, "class", "send");
    			add_location(div, file$B, 190, 12, 6458);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*verifyCode*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(190:8) {#if confResInitied}",
    		ctx
    	});

    	return block;
    }

    // (197:16) {:else}
    function create_else_block$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Send");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$g.name,
    		type: "else",
    		source: "(197:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (195:16) {#if sendingCode}
    function create_if_block_1$d(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(195:16) {#if sendingCode}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div2;
    	let a;
    	let img;
    	let img_src_value;
    	let t0;
    	let t1;
    	let current_block_type_index;
    	let if_block;
    	let t2;
    	let div0;
    	let t3;
    	let div1;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$l, create_else_block_2$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*succOperation*/ ctx[5] == false) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			a = element("a");
    			img = element("img");
    			t0 = text("Unify");
    			t1 = space();
    			if_block.c();
    			t2 = space();
    			div0 = element("div");
    			t3 = space();
    			div1 = element("div");
    			if (img.src !== (img_src_value = "./img/logo.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "svelte-1g92s3b");
    			add_location(img, file$B, 150, 8, 5170);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "u_logo svelte-1g92s3b");
    			add_location(a, file$B, 149, 4, 5124);
    			attr_dev(div0, "class", "circle_top svelte-1g92s3b");
    			add_location(div0, file$B, 209, 4, 6988);
    			attr_dev(div1, "class", "circle_bottom svelte-1g92s3b");
    			add_location(div1, file$B, 210, 4, 7020);
    			attr_dev(div2, "class", "left_side svelte-1g92s3b");
    			add_location(div2, file$B, 148, 0, 5095);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, a);
    			append_dev(a, img);
    			append_dev(a, t0);
    			append_dev(div2, t1);
    			if_blocks[current_block_type_index].m(div2, null);
    			append_dev(div2, t2);
    			append_dev(div2, div0);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div2, t2);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let $user;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(6, $user = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PhoneVerification", slots, []);

    	user.subscribe(v => {
    		if (v == 0) {
    			console.log("initng");
    		} else if (v == undefined) {
    			console.log("no user");
    			navigate("/signup");
    		}
    	});

    	let phone;
    	let code;
    	let confResInitied = false;
    	let errorMessage = undefined;
    	let sendingCode = false;

    	onMount(() => {
    		window.recaptchaVerifier = new firebase.auth.RecaptchaVerifier("sign-in-button",
    		{
    				"size": "invisible",
    				"callback": response => {
    					// reCAPTCHA solved, allow signInWithPhoneNumber.
    					(() => {
    						console.log("solved");
    					})();
    				}
    			});

    		console.log(location.search);
    		new URLSearchParams(location.search);
    		document.title = "Unify - Phone Verification";
    	});

    	const SendCode = async () => {
    		if (sendingCode) {
    			return;
    		}

    		$$invalidate(3, errorMessage = undefined);
    		$$invalidate(4, sendingCode = true);
    		let lphone = phone.value;
    		console.log(lphone);

    		if (!lphone.includes("+")) {
    			lphone = "+216" + lphone;
    		}

    		if ($user && $user.phoneNumber && lphone == $user.phoneNumber) {
    			$$invalidate(3, errorMessage = "To update your phone number you need to input an new one");
    			$$invalidate(4, sendingCode = false);
    			return;
    		}

    		console.log(lphone);

    		await auth.signInWithPhoneNumber(lphone, window.recaptchaVerifier).then(confirmationResult => {
    			// SMS sent. Prompt user to type the code from the message, then sign the
    			// user in with confirmationResult.confirm(code).
    			console.log(confirmationResult);

    			window.confirmationResult = confirmationResult;
    			console.log(window.confirmationResult);
    			$$invalidate(2, confResInitied = true);
    			$$invalidate(4, sendingCode = false);
    		}).catch(error => {
    			// Error; SMS not sent
    			// ...
    			window.recaptchaVerifier.render().then(function (widgetId) {
    				grecaptcha.reset(widgetId); // ...
    			});

    			$$invalidate(3, errorMessage = "An error occured while sending SMS please try again");
    			$$invalidate(4, sendingCode = false);
    		});

    		$$invalidate(4, sendingCode = false);
    	};

    	let succOperation = false;

    	const verifyCode = async () => {
    		$$invalidate(3, errorMessage = "");
    		console.log("first");

    		if (code.value == undefined || code.value == null || code.value == "") {
    			$$invalidate(3, errorMessage = "Please enter the code you received on your phone");
    			$$invalidate(5, succOperation = false);
    			verifyingCode = false;
    			return;
    		}

    		var credential = firebase.auth.PhoneAuthProvider.credential(window.confirmationResult.verificationId, code.value);
    		console.log("second");
    		console.log(credential);

    		if ($user) {
    			console.log("4");

    			try {
    				await $user.updatePhoneNumber(credential);
    				console.log($user);
    				$$invalidate(5, succOperation = true);
    			} catch(error) {
    				console.log(error);

    				if (error.code == "auth/invalid-verification-code") {
    					$$invalidate(3, errorMessage = "The code is incorrect, please verify it.");
    					$$invalidate(5, succOperation = false);
    				} else if (error.code == "auth/credential-already-in-use") {
    					console.log("inside");
    					$$invalidate(3, errorMessage = "Phone number already in use by another account");
    					$$invalidate(5, succOperation = false);
    				} else if (error.code == "auth/missing-verification-code") {
    					$$invalidate(3, errorMessage = "Unexpected error occured no code was written");
    					$$invalidate(5, succOperation = false);
    				} else {
    					$$invalidate(3, errorMessage = "Unexpected error occured, please trying");
    					$$invalidate(5, succOperation = false);
    				}
    			}
    		}

    		if (succOperation) {
    			let params = new URLSearchParams(location.search);

    			if (params.get("backurl") != null) {
    				navigate(params.get("backurl"));
    			}
    		}

    		return;
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$f.warn(`<PhoneVerification> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			phone = $$value;
    			$$invalidate(0, phone);
    		});
    	}

    	function input_binding_1($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			code = $$value;
    			$$invalidate(1, code);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		user,
    		auth,
    		MaterialSpinner,
    		navigate,
    		link,
    		phone,
    		code,
    		confResInitied,
    		errorMessage,
    		sendingCode,
    		SendCode,
    		succOperation,
    		verifyCode,
    		$user
    	});

    	$$self.$inject_state = $$props => {
    		if ("phone" in $$props) $$invalidate(0, phone = $$props.phone);
    		if ("code" in $$props) $$invalidate(1, code = $$props.code);
    		if ("confResInitied" in $$props) $$invalidate(2, confResInitied = $$props.confResInitied);
    		if ("errorMessage" in $$props) $$invalidate(3, errorMessage = $$props.errorMessage);
    		if ("sendingCode" in $$props) $$invalidate(4, sendingCode = $$props.sendingCode);
    		if ("succOperation" in $$props) $$invalidate(5, succOperation = $$props.succOperation);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		phone,
    		code,
    		confResInitied,
    		errorMessage,
    		sendingCode,
    		succOperation,
    		$user,
    		SendCode,
    		verifyCode,
    		input_binding,
    		input_binding_1
    	];
    }

    class PhoneVerification extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PhoneVerification",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* src\components\UserProfile\Profile.svelte generated by Svelte v3.32.3 */

    const { console: console_1$g } = globals;
    const file$C = "src\\components\\UserProfile\\Profile.svelte";

    // (437:12) {:else}
    function create_else_block_3$1(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_3$1.name,
    		type: "else",
    		source: "(437:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (420:12) {#if !handlingFacebook}
    function create_if_block_2$7(ctx) {
    	let i;
    	let t;
    	let show_if;
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (show_if == null || dirty & /*providers*/ 4) show_if = !!/*providers*/ ctx[2].includes("facebook.com");
    		if (show_if) return create_if_block_3$7;
    		return create_else_block_2$2;
    	}

    	let current_block_type = select_block_type_1(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			i = element("i");
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(i, "class", "fab fa-facebook-f svelte-1l2nsjq svelte-1rtnk10");
    			attr_dev(i, "aria-hidden", "true");
    			add_location(i, file$C, 420, 16, 12823);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(420:12) {#if !handlingFacebook}",
    		ctx
    	});

    	return block;
    }

    // (429:20) {:else}
    function create_else_block_2$2(ctx) {
    	let t_value = ({
    		"fr": "Connecter avec Facebook",
    		"en": "Connect with Facebook"
    	})[/*$lang*/ ctx[9]] + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 512 && t_value !== (t_value = ({
    				"fr": "Connecter avec Facebook",
    				"en": "Connect with Facebook"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2$2.name,
    		type: "else",
    		source: "(429:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (422:16) {#if providers.includes('facebook.com')}
    function create_if_block_3$7(ctx) {
    	let t_value = ({
    		"fr": "Dissocier Facebook",
    		"en": "Unlink Facebook"
    	})[/*$lang*/ ctx[9]] + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 512 && t_value !== (t_value = ({
    				"fr": "Dissocier Facebook",
    				"en": "Unlink Facebook"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(422:16) {#if providers.includes('facebook.com')}",
    		ctx
    	});

    	return block;
    }

    // (460:12) {:else}
    function create_else_block_1$6(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$6.name,
    		type: "else",
    		source: "(460:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (442:12) {#if !handlingGoogle}
    function create_if_block$m(ctx) {
    	let i;
    	let t;
    	let show_if;
    	let if_block_anchor;

    	function select_block_type_3(ctx, dirty) {
    		if (show_if == null || dirty & /*providers*/ 4) show_if = !!/*providers*/ ctx[2].includes("google.com");
    		if (show_if) return create_if_block_1$e;
    		return create_else_block$h;
    	}

    	let current_block_type = select_block_type_3(ctx, -1);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			i = element("i");
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			attr_dev(i, "class", "fab fa-google-plus-g svelte-1l2nsjq svelte-1rtnk10");
    			attr_dev(i, "aria-hidden", "true");
    			add_location(i, file$C, 442, 16, 13695);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t, anchor);
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_3(ctx, dirty)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t);
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(442:12) {#if !handlingGoogle}",
    		ctx
    	});

    	return block;
    }

    // (452:20) {:else}
    function create_else_block$h(ctx) {
    	let t_value = ({
    		"fr": "Connecter avec Google",
    		"en": "Connect with Google"
    	})[/*$lang*/ ctx[9]] + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 512 && t_value !== (t_value = ({
    				"fr": "Connecter avec Google",
    				"en": "Connect with Google"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$h.name,
    		type: "else",
    		source: "(452:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (445:20) {#if providers.includes('google.com')}
    function create_if_block_1$e(ctx) {
    	let t_value = ({
    		"fr": "Dissocier Google",
    		"en": "Unlink Google"
    	})[/*$lang*/ ctx[9]] + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$lang*/ 512 && t_value !== (t_value = ({
    				"fr": "Dissocier Google",
    				"en": "Unlink Google"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(445:20) {#if providers.includes('google.com')}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div25;
    	let div0;
    	let t0_value = ({ "fr": "Mon Compte", "en": "My Account" })[/*$lang*/ ctx[9]] + "";
    	let t0;
    	let t1;
    	let hr;
    	let t2;
    	let div13;
    	let div6;
    	let div1;

    	let t3_value = ({
    		"fr": "Données de compte",
    		"en": "Account Data"
    	})[/*$lang*/ ctx[9]] + "";

    	let t3;
    	let t4;
    	let div3;
    	let div2;
    	let t5_value = ({ "fr": "Email", "en": "Email" })[/*$lang*/ ctx[9]] + "";
    	let t5;
    	let t6;
    	let input0;
    	let input0_value_value;
    	let t7;
    	let div5;
    	let div4;

    	let t8_value = ({
    		"fr": "Numéro de téléphone",
    		"en": "Phone Number"
    	})[/*$lang*/ ctx[9]] + "";

    	let t8;
    	let t9;
    	let input1;
    	let input1_value_value;
    	let t10;
    	let div12;
    	let div7;

    	let t11_value = ({
    		"fr": "Données personnelles",
    		"en": "Personal Data"
    	})[/*$lang*/ ctx[9]] + "";

    	let t11;
    	let t12;
    	let div9;
    	let div8;
    	let t13_value = ({ "fr": "Nom", "en": "Name" })[/*$lang*/ ctx[9]] + "";
    	let t13;
    	let t14;
    	let input2;
    	let input2_value_value;
    	let t15;
    	let div11;
    	let div10;

    	let t16_value = ({
    		"fr": "Date de naissance",
    		"en": "Date of Birth"
    	})[/*$lang*/ ctx[9]] + "";

    	let t16;
    	let t17;
    	let input3;
    	let input3_value_value;
    	let t18;
    	let button0;
    	let t19_value = ({ "fr": "Enregistrer", "en": "Save" })[/*$lang*/ ctx[9]] + "";
    	let t19;
    	let t20;
    	let div17;
    	let div14;

    	let t21_value = ({
    		"fr": "Liez vos comptes",
    		"en": "Link Your Accounts"
    	})[/*$lang*/ ctx[9]] + "";

    	let t21;
    	let t22;
    	let div15;
    	let current_block_type_index;
    	let if_block0;
    	let t23;
    	let div16;
    	let current_block_type_index_1;
    	let if_block1;
    	let t24;
    	let form;
    	let div18;

    	let t25_value = ({
    		"fr": "Changez Votre Mot de Passe",
    		"en": "Change Your Password"
    	})[/*$lang*/ ctx[9]] + "";

    	let t25;
    	let t26;
    	let div20;
    	let div19;

    	let t27_value = ({
    		"fr": "Mot de Passe Actuel",
    		"en": "Actual Password"
    	})[/*$lang*/ ctx[9]] + "";

    	let t27;
    	let t28;
    	let input4;
    	let t29;
    	let div22;
    	let div21;

    	let t30_value = ({
    		"fr": "Nouveau Mot de Passe",
    		"en": "New Password"
    	})[/*$lang*/ ctx[9]] + "";

    	let t30;
    	let t31;
    	let input5;
    	let t32;
    	let div24;
    	let div23;

    	let t33_value = ({
    		"fr": "Confirmez le Mot de Passe",
    		"en": "Confirm Password"
    	})[/*$lang*/ ctx[9]] + "";

    	let t33;
    	let t34;
    	let input6;
    	let t35;
    	let button1;

    	let t36_value = ({
    		"fr": "Changer le Mot de Passe",
    		"en": "Change Password"
    	})[/*$lang*/ ctx[9]] + "";

    	let t36;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_2$7, create_else_block_3$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*handlingFacebook*/ ctx[4]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	const if_block_creators_1 = [create_if_block$m, create_else_block_1$6];
    	const if_blocks_1 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (!/*handlingGoogle*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index_1 = select_block_type_2(ctx);
    	if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);

    	const block = {
    		c: function create() {
    			div25 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			div13 = element("div");
    			div6 = element("div");
    			div1 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div3 = element("div");
    			div2 = element("div");
    			t5 = text(t5_value);
    			t6 = space();
    			input0 = element("input");
    			t7 = space();
    			div5 = element("div");
    			div4 = element("div");
    			t8 = text(t8_value);
    			t9 = space();
    			input1 = element("input");
    			t10 = space();
    			div12 = element("div");
    			div7 = element("div");
    			t11 = text(t11_value);
    			t12 = space();
    			div9 = element("div");
    			div8 = element("div");
    			t13 = text(t13_value);
    			t14 = space();
    			input2 = element("input");
    			t15 = space();
    			div11 = element("div");
    			div10 = element("div");
    			t16 = text(t16_value);
    			t17 = space();
    			input3 = element("input");
    			t18 = space();
    			button0 = element("button");
    			t19 = text(t19_value);
    			t20 = space();
    			div17 = element("div");
    			div14 = element("div");
    			t21 = text(t21_value);
    			t22 = space();
    			div15 = element("div");
    			if_block0.c();
    			t23 = space();
    			div16 = element("div");
    			if_block1.c();
    			t24 = space();
    			form = element("form");
    			div18 = element("div");
    			t25 = text(t25_value);
    			t26 = space();
    			div20 = element("div");
    			div19 = element("div");
    			t27 = text(t27_value);
    			t28 = space();
    			input4 = element("input");
    			t29 = space();
    			div22 = element("div");
    			div21 = element("div");
    			t30 = text(t30_value);
    			t31 = space();
    			input5 = element("input");
    			t32 = space();
    			div24 = element("div");
    			div23 = element("div");
    			t33 = text(t33_value);
    			t34 = space();
    			input6 = element("input");
    			t35 = space();
    			button1 = element("button");
    			t36 = text(t36_value);
    			attr_dev(div0, "class", "big_title svelte-1rtnk10");
    			add_location(div0, file$C, 335, 4, 9407);
    			attr_dev(hr, "class", "svelte-1rtnk10");
    			add_location(hr, file$C, 341, 4, 9644);
    			attr_dev(div1, "class", "title svelte-1rtnk10");
    			add_location(div1, file$C, 344, 12, 9729);
    			attr_dev(div2, "class", "title svelte-1rtnk10");
    			add_location(div2, file$C, 351, 16, 10016);
    			attr_dev(input0, "type", "email");
    			attr_dev(input0, "class", "email svelte-1rtnk10");
    			input0.disabled = true;
    			input0.value = input0_value_value = /*$user*/ ctx[8].email ? /*$user*/ ctx[8].email : "";
    			add_location(input0, file$C, 357, 16, 10251);
    			attr_dev(div3, "class", "input svelte-1rtnk10");
    			add_location(div3, file$C, 350, 12, 9979);
    			attr_dev(div4, "class", "title svelte-1rtnk10");
    			add_location(div4, file$C, 364, 16, 10490);
    			attr_dev(input1, "type", "phone");
    			attr_dev(input1, "class", "phone_num svelte-1rtnk10");
    			input1.disabled = true;

    			input1.value = input1_value_value = /*$user*/ ctx[8].phoneNumber
    			? /*$user*/ ctx[8].phoneNumber
    			: "";

    			add_location(input1, file$C, 370, 16, 10746);
    			attr_dev(div5, "class", "input svelte-1rtnk10");
    			add_location(div5, file$C, 363, 12, 10453);
    			attr_dev(div6, "class", "account_data svelte-1rtnk10");
    			add_location(div6, file$C, 343, 8, 9689);
    			attr_dev(div7, "class", "title svelte-1rtnk10");
    			add_location(div7, file$C, 378, 12, 11017);
    			attr_dev(div8, "class", "title svelte-1rtnk10");
    			add_location(div8, file$C, 385, 16, 11308);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "class", "name svelte-1rtnk10");

    			input2.value = input2_value_value = /*$user*/ ctx[8].displayName
    			? /*$user*/ ctx[8].displayName
    			: "";

    			add_location(input2, file$C, 391, 16, 11540);
    			attr_dev(div9, "class", "input svelte-1rtnk10");
    			add_location(div9, file$C, 384, 12, 11271);
    			attr_dev(div10, "class", "title svelte-1rtnk10");
    			add_location(div10, file$C, 394, 16, 11716);
    			attr_dev(input3, "type", "date");

    			input3.value = input3_value_value = (/*$user*/ ctx[8].docData?.birthdate)
    			? /*$user*/ ctx[8].docData?.birthdate
    			: "";

    			attr_dev(input3, "class", "birth_date svelte-1rtnk10");
    			add_location(input3, file$C, 400, 16, 11971);
    			attr_dev(div11, "class", "input svelte-1rtnk10");
    			add_location(div11, file$C, 393, 12, 11679);
    			attr_dev(div12, "class", "personal_data svelte-1rtnk10");
    			add_location(div12, file$C, 377, 8, 10976);
    			attr_dev(div13, "class", "user_data svelte-1rtnk10");
    			add_location(div13, file$C, 342, 4, 9656);
    			attr_dev(button0, "class", "save_btn svelte-1rtnk10");
    			add_location(button0, file$C, 404, 4, 12151);
    			attr_dev(div14, "class", "title");
    			add_location(div14, file$C, 412, 8, 12475);
    			attr_dev(div15, "class", "fb svelte-1rtnk10");
    			add_location(div15, file$C, 418, 8, 12726);
    			attr_dev(div16, "class", "youtube svelte-1rtnk10");
    			add_location(div16, file$C, 440, 8, 13597);
    			attr_dev(div17, "class", "link_social_media svelte-1rtnk10");
    			add_location(div17, file$C, 411, 4, 12434);
    			attr_dev(div18, "class", "title svelte-1rtnk10");
    			add_location(div18, file$C, 472, 8, 14722);
    			attr_dev(div19, "class", "title svelte-1rtnk10");
    			add_location(div19, file$C, 479, 12, 15018);
    			attr_dev(input4, "autocomplete", "off");
    			attr_dev(input4, "type", "password");
    			attr_dev(input4, "class", "new_pwd svelte-1rtnk10");
    			add_location(input4, file$C, 485, 12, 15273);
    			attr_dev(div20, "class", "input svelte-1rtnk10");
    			add_location(div20, file$C, 478, 8, 14985);
    			attr_dev(div21, "class", "title svelte-1rtnk10");
    			add_location(div21, file$C, 488, 12, 15415);
    			attr_dev(input5, "autocomplete", "off");
    			attr_dev(input5, "type", "password");
    			attr_dev(input5, "class", "new_pwd svelte-1rtnk10");
    			add_location(input5, file$C, 494, 12, 15668);
    			attr_dev(div22, "class", "input svelte-1rtnk10");
    			add_location(div22, file$C, 487, 8, 15382);
    			attr_dev(div23, "class", "title svelte-1rtnk10");
    			add_location(div23, file$C, 497, 12, 15810);
    			attr_dev(input6, "autocomplete", "off");
    			attr_dev(input6, "type", "password");
    			attr_dev(input6, "class", "confirm_pwd svelte-1rtnk10");
    			add_location(input6, file$C, 503, 12, 16072);
    			attr_dev(div24, "class", "input svelte-1rtnk10");
    			add_location(div24, file$C, 496, 8, 15777);
    			attr_dev(button1, "type", "submit");
    			attr_dev(button1, "class", "save_btn svelte-1rtnk10");
    			add_location(button1, file$C, 505, 8, 16187);
    			attr_dev(form, "class", "pwd_change svelte-1rtnk10");
    			add_location(form, file$C, 471, 4, 14649);
    			attr_dev(div25, "class", "profile_container svelte-1rtnk10");
    			add_location(div25, file$C, 334, 0, 9370);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div25, anchor);
    			append_dev(div25, div0);
    			append_dev(div0, t0);
    			append_dev(div25, t1);
    			append_dev(div25, hr);
    			append_dev(div25, t2);
    			append_dev(div25, div13);
    			append_dev(div13, div6);
    			append_dev(div6, div1);
    			append_dev(div1, t3);
    			append_dev(div6, t4);
    			append_dev(div6, div3);
    			append_dev(div3, div2);
    			append_dev(div2, t5);
    			append_dev(div3, t6);
    			append_dev(div3, input0);
    			append_dev(div6, t7);
    			append_dev(div6, div5);
    			append_dev(div5, div4);
    			append_dev(div4, t8);
    			append_dev(div5, t9);
    			append_dev(div5, input1);
    			append_dev(div13, t10);
    			append_dev(div13, div12);
    			append_dev(div12, div7);
    			append_dev(div7, t11);
    			append_dev(div12, t12);
    			append_dev(div12, div9);
    			append_dev(div9, div8);
    			append_dev(div8, t13);
    			append_dev(div9, t14);
    			append_dev(div9, input2);
    			/*input2_binding*/ ctx[14](input2);
    			append_dev(div12, t15);
    			append_dev(div12, div11);
    			append_dev(div11, div10);
    			append_dev(div10, t16);
    			append_dev(div11, t17);
    			append_dev(div11, input3);
    			/*input3_binding*/ ctx[15](input3);
    			append_dev(div25, t18);
    			append_dev(div25, button0);
    			append_dev(button0, t19);
    			append_dev(div25, t20);
    			append_dev(div25, div17);
    			append_dev(div17, div14);
    			append_dev(div14, t21);
    			append_dev(div17, t22);
    			append_dev(div17, div15);
    			if_blocks[current_block_type_index].m(div15, null);
    			append_dev(div17, t23);
    			append_dev(div17, div16);
    			if_blocks_1[current_block_type_index_1].m(div16, null);
    			append_dev(div25, t24);
    			append_dev(div25, form);
    			append_dev(form, div18);
    			append_dev(div18, t25);
    			append_dev(form, t26);
    			append_dev(form, div20);
    			append_dev(div20, div19);
    			append_dev(div19, t27);
    			append_dev(div20, t28);
    			append_dev(div20, input4);
    			/*input4_binding*/ ctx[16](input4);
    			append_dev(form, t29);
    			append_dev(form, div22);
    			append_dev(div22, div21);
    			append_dev(div21, t30);
    			append_dev(div22, t31);
    			append_dev(div22, input5);
    			/*input5_binding*/ ctx[17](input5);
    			append_dev(form, t32);
    			append_dev(form, div24);
    			append_dev(div24, div23);
    			append_dev(div23, t33);
    			append_dev(div24, t34);
    			append_dev(div24, input6);
    			/*input6_binding*/ ctx[18](input6);
    			append_dev(form, t35);
    			append_dev(form, button1);
    			append_dev(button1, t36);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*doUpdate*/ ctx[10], false, false, false),
    					listen_dev(div15, "click", /*handleFacebook*/ ctx[12], false, false, false),
    					listen_dev(div16, "click", /*handleGoogle*/ ctx[11], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*doPassword*/ ctx[13]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$lang*/ 512) && t0_value !== (t0_value = ({ "fr": "Mon Compte", "en": "My Account" })[/*$lang*/ ctx[9]] + "")) set_data_dev(t0, t0_value);

    			if ((!current || dirty & /*$lang*/ 512) && t3_value !== (t3_value = ({
    				"fr": "Données de compte",
    				"en": "Account Data"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t3, t3_value);

    			if ((!current || dirty & /*$lang*/ 512) && t5_value !== (t5_value = ({ "fr": "Email", "en": "Email" })[/*$lang*/ ctx[9]] + "")) set_data_dev(t5, t5_value);

    			if (!current || dirty & /*$user*/ 256 && input0_value_value !== (input0_value_value = /*$user*/ ctx[8].email ? /*$user*/ ctx[8].email : "") && input0.value !== input0_value_value) {
    				prop_dev(input0, "value", input0_value_value);
    			}

    			if ((!current || dirty & /*$lang*/ 512) && t8_value !== (t8_value = ({
    				"fr": "Numéro de téléphone",
    				"en": "Phone Number"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t8, t8_value);

    			if (!current || dirty & /*$user*/ 256 && input1_value_value !== (input1_value_value = /*$user*/ ctx[8].phoneNumber
    			? /*$user*/ ctx[8].phoneNumber
    			: "")) {
    				prop_dev(input1, "value", input1_value_value);
    			}

    			if ((!current || dirty & /*$lang*/ 512) && t11_value !== (t11_value = ({
    				"fr": "Données personnelles",
    				"en": "Personal Data"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t11, t11_value);

    			if ((!current || dirty & /*$lang*/ 512) && t13_value !== (t13_value = ({ "fr": "Nom", "en": "Name" })[/*$lang*/ ctx[9]] + "")) set_data_dev(t13, t13_value);

    			if (!current || dirty & /*$user*/ 256 && input2_value_value !== (input2_value_value = /*$user*/ ctx[8].displayName
    			? /*$user*/ ctx[8].displayName
    			: "") && input2.value !== input2_value_value) {
    				prop_dev(input2, "value", input2_value_value);
    			}

    			if ((!current || dirty & /*$lang*/ 512) && t16_value !== (t16_value = ({
    				"fr": "Date de naissance",
    				"en": "Date of Birth"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t16, t16_value);

    			if (!current || dirty & /*$user*/ 256 && input3_value_value !== (input3_value_value = (/*$user*/ ctx[8].docData?.birthdate)
    			? /*$user*/ ctx[8].docData?.birthdate
    			: "")) {
    				prop_dev(input3, "value", input3_value_value);
    			}

    			if ((!current || dirty & /*$lang*/ 512) && t19_value !== (t19_value = ({ "fr": "Enregistrer", "en": "Save" })[/*$lang*/ ctx[9]] + "")) set_data_dev(t19, t19_value);

    			if ((!current || dirty & /*$lang*/ 512) && t21_value !== (t21_value = ({
    				"fr": "Liez vos comptes",
    				"en": "Link Your Accounts"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t21, t21_value);

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				} else {
    					if_block0.p(ctx, dirty);
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div15, null);
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_2(ctx);

    			if (current_block_type_index_1 === previous_block_index_1) {
    				if_blocks_1[current_block_type_index_1].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    					if_blocks_1[previous_block_index_1] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks_1[current_block_type_index_1];

    				if (!if_block1) {
    					if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    					if_block1.c();
    				} else {
    					if_block1.p(ctx, dirty);
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div16, null);
    			}

    			if ((!current || dirty & /*$lang*/ 512) && t25_value !== (t25_value = ({
    				"fr": "Changez Votre Mot de Passe",
    				"en": "Change Your Password"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t25, t25_value);

    			if ((!current || dirty & /*$lang*/ 512) && t27_value !== (t27_value = ({
    				"fr": "Mot de Passe Actuel",
    				"en": "Actual Password"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t27, t27_value);

    			if ((!current || dirty & /*$lang*/ 512) && t30_value !== (t30_value = ({
    				"fr": "Nouveau Mot de Passe",
    				"en": "New Password"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t30, t30_value);

    			if ((!current || dirty & /*$lang*/ 512) && t33_value !== (t33_value = ({
    				"fr": "Confirmez le Mot de Passe",
    				"en": "Confirm Password"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t33, t33_value);

    			if ((!current || dirty & /*$lang*/ 512) && t36_value !== (t36_value = ({
    				"fr": "Changer le Mot de Passe",
    				"en": "Change Password"
    			})[/*$lang*/ ctx[9]] + "")) set_data_dev(t36, t36_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div25);
    			/*input2_binding*/ ctx[14](null);
    			/*input3_binding*/ ctx[15](null);
    			if_blocks[current_block_type_index].d();
    			if_blocks_1[current_block_type_index_1].d();
    			/*input4_binding*/ ctx[16](null);
    			/*input5_binding*/ ctx[17](null);
    			/*input6_binding*/ ctx[18](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $user;
    	let $lang;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(8, $user = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(9, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Profile", slots, []);
    	let varname = "";
    	let varbirth = "";
    	let providers = [];

    	user.subscribe(v => {
    		if (v == 0 || v == undefined) {
    			return;
    		}

    		$$invalidate(2, providers = v.providerData.map(item => item.providerId));
    	});

    	const doUpdate = async () => {
    		let updated = false;

    		if (varname.value != $user.displayName) {
    			await $user.updateProfile({ displayName: varname.value });
    			user.set($user);
    			updated = true;
    		}

    		if ($user?.docData?.birthdate == undefined || $user?.docData?.birthdate != varbirth.value) {
    			await db.collection("users").doc($user.uid).set({ birthdate: varbirth.value }, { merge: true });

    			set_store_value(
    				user,
    				$user = {
    					...$user,
    					docData: {
    						...$user.docData,
    						birthdate: varbirth.value
    					}
    				},
    				$user
    			);

    			updated = true;
    		}

    		if (updated) {
    			notification.set({
    				accentColor: "success",
    				title: "Success",
    				content: "Profile Updated"
    			});
    		}
    	};

    	let handlingGoogle = false;

    	const handleGoogle = async () => {
    		if (handlingGoogle) {
    			return;
    		}

    		$$invalidate(3, handlingGoogle = true);

    		if (providers.includes("google.com")) {
    			await $user.unlink("google.com");
    			$$invalidate(2, providers = providers.filter(item => item != "google.com"));
    			console.log(providers);
    		} else {
    			let provider = new firebase.auth.GoogleAuthProvider();

    			await $user.linkWithPopup(provider).then(function (result) {
    				// Accounts successfully linked.
    				result.credential;

    				result.user;
    				console.log(result);
    				$$invalidate(2, providers = [...providers, "google.com"]);
    			}).catch(function (error) {
    				console.log(error);

    				if (error.code == "auth/email-already-in-use") {
    					notification.set({
    						accentColor: "error",
    						title: "Error",
    						contnet: "Email already in use"
    					});
    				}
    			});
    		}

    		$$invalidate(3, handlingGoogle = false);
    	};

    	let handlingFacebook = false;

    	const handleFacebook = async () => {
    		if (handlingFacebook) {
    			return;
    		}

    		$$invalidate(4, handlingFacebook = true);

    		if (providers.includes("facebook.com")) {
    			await $user.unlink("facebook.com");
    			$$invalidate(2, providers = providers.filter(item => item != "facebook.com"));
    			console.log(providers);
    		} else {
    			let provider = new firebase.auth.FacebookAuthProvider();

    			await $user.linkWithPopup(provider).then(function (result) {
    				// Accounts successfully linked.
    				result.credential;

    				result.user;
    				console.log(result);
    				$$invalidate(2, providers = [...providers, "facebook.com"]);
    			}).catch(function (error) {
    				console.log(error);

    				notification.set({
    					accentColor: "error",
    					title: "Error",
    					contnet: "Email already in use"
    				});
    			}); // Handle Errors here.
    			// ...
    		}

    		$$invalidate(4, handlingFacebook = false);
    	};

    	let newPassvar;
    	let renewPassvar;
    	let oldPassvar;

    	const doPassword = async () => {
    		if (newPassvar.value != renewPassvar.value) {
    			notification.set({
    				accentColor: "alert",
    				title: "Alert",
    				content: "Password do not match"
    			});

    			return;
    		}

    		var credentials = firebase.auth.EmailAuthProvider.credential($user.email, oldPassvar.value);
    		let failed = false;

    		await $user.reauthenticateWithCredential(credentials).catch(error => {
    			console.log("error");

    			notification.set({
    				accentColor: "error",
    				title: "Incorrect old password",
    				content: "Old password is incorrect"
    			});

    			failed = true;
    		});

    		if (failed) {
    			return;
    		}

    		await $user.updatePassword(newPassvar.value);

    		/*
    await $user.updatePassword(newPassvar.value).then(function() {
    // Update successful.
    }).catch(async function(error) {
    // An error happened.
        if (error.code == "auth/requires-recent-login") {

            
            var credentials = firebase.auth.EmailAuthProvider.credential(
                $user.email,
                oldPassvar.value
            );
            await $user.reauthenticateWithCredential(credentials);
            await $user.updatePassword(newPassvar.value)
        }
    });
    */
    		notification.set({
    			accentColor: "success",
    			title: "Success",
    			content: "Password Updated"
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$g.warn(`<Profile> was created with unknown prop '${key}'`);
    	});

    	function input2_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			varname = $$value;
    			$$invalidate(0, varname);
    		});
    	}

    	function input3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			varbirth = $$value;
    			$$invalidate(1, varbirth);
    		});
    	}

    	function input4_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			oldPassvar = $$value;
    			$$invalidate(7, oldPassvar);
    		});
    	}

    	function input5_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			newPassvar = $$value;
    			$$invalidate(5, newPassvar);
    		});
    	}

    	function input6_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			renewPassvar = $$value;
    			$$invalidate(6, renewPassvar);
    		});
    	}

    	$$self.$capture_state = () => ({
    		user,
    		db,
    		notification,
    		lang,
    		onMount,
    		onDestroy,
    		MaterialSpinner,
    		varname,
    		varbirth,
    		providers,
    		doUpdate,
    		handlingGoogle,
    		handleGoogle,
    		handlingFacebook,
    		handleFacebook,
    		newPassvar,
    		renewPassvar,
    		oldPassvar,
    		doPassword,
    		$user,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("varname" in $$props) $$invalidate(0, varname = $$props.varname);
    		if ("varbirth" in $$props) $$invalidate(1, varbirth = $$props.varbirth);
    		if ("providers" in $$props) $$invalidate(2, providers = $$props.providers);
    		if ("handlingGoogle" in $$props) $$invalidate(3, handlingGoogle = $$props.handlingGoogle);
    		if ("handlingFacebook" in $$props) $$invalidate(4, handlingFacebook = $$props.handlingFacebook);
    		if ("newPassvar" in $$props) $$invalidate(5, newPassvar = $$props.newPassvar);
    		if ("renewPassvar" in $$props) $$invalidate(6, renewPassvar = $$props.renewPassvar);
    		if ("oldPassvar" in $$props) $$invalidate(7, oldPassvar = $$props.oldPassvar);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		varname,
    		varbirth,
    		providers,
    		handlingGoogle,
    		handlingFacebook,
    		newPassvar,
    		renewPassvar,
    		oldPassvar,
    		$user,
    		$lang,
    		doUpdate,
    		handleGoogle,
    		handleFacebook,
    		doPassword,
    		input2_binding,
    		input3_binding,
    		input4_binding,
    		input5_binding,
    		input6_binding
    	];
    }

    class Profile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Profile",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src\components\UserProfile\Wishlist.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$g, console: console_1$h } = globals;
    const file$D = "src\\components\\UserProfile\\Wishlist.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[11] = list;
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (306:28) {:else}
    function create_else_block$i(ctx) {
    	let span;
    	let t0_value = /*product*/ ctx[10].price + "";
    	let t0;
    	let t1;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(" TND");
    			attr_dev(span, "class", "current_price svelte-mpoksl");
    			add_location(span, file$D, 306, 28, 10003);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*displayProducts*/ 1 && t0_value !== (t0_value = /*product*/ ctx[10].price + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$i.name,
    		type: "else",
    		source: "(306:28) {:else}",
    		ctx
    	});

    	return block;
    }

    // (299:28) {#if product.discount}
    function create_if_block$n(ctx) {
    	let span0;
    	let t0_value = /*product*/ ctx[10].price * (1 - /*product*/ ctx[10].discount) + "";
    	let t0;
    	let t1;
    	let t2;
    	let span3;
    	let span1;
    	let t3_value = /*product*/ ctx[10].price + "";
    	let t3;
    	let t4;
    	let span2;
    	let t5;
    	let t6_value = /*product*/ ctx[10].discount * 100 + "";
    	let t6;
    	let t7;

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			t0 = text(t0_value);
    			t1 = text("\r\n                                TND");
    			t2 = space();
    			span3 = element("span");
    			span1 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			span2 = element("span");
    			t5 = text("-");
    			t6 = text(t6_value);
    			t7 = text("%");
    			attr_dev(span0, "class", "current_price svelte-mpoksl");
    			add_location(span0, file$D, 299, 28, 9556);
    			attr_dev(span1, "class", "price svelte-mpoksl");
    			add_location(span1, file$D, 302, 32, 9756);
    			attr_dev(span2, "class", "percentage_discount svelte-mpoksl");
    			add_location(span2, file$D, 303, 32, 9832);
    			attr_dev(span3, "class", "old_price");
    			add_location(span3, file$D, 301, 28, 9698);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			append_dev(span0, t0);
    			append_dev(span0, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, span3, anchor);
    			append_dev(span3, span1);
    			append_dev(span1, t3);
    			append_dev(span3, t4);
    			append_dev(span3, span2);
    			append_dev(span2, t5);
    			append_dev(span2, t6);
    			append_dev(span2, t7);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*displayProducts*/ 1 && t0_value !== (t0_value = /*product*/ ctx[10].price * (1 - /*product*/ ctx[10].discount) + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*displayProducts*/ 1 && t3_value !== (t3_value = /*product*/ ctx[10].price + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*displayProducts*/ 1 && t6_value !== (t6_value = /*product*/ ctx[10].discount * 100 + "")) set_data_dev(t6, t6_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(span3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(299:28) {#if product.discount}",
    		ctx
    	});

    	return block;
    }

    // (312:24) {#each product.colors as color}
    function create_each_block_1$5(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler_2() {
    		return /*click_handler_2*/ ctx[7](/*product*/ ctx[10], /*color*/ ctx[13], /*each_value*/ ctx[11], /*product_index*/ ctx[12]);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t = space();
    			attr_dev(div0, "class", "color svelte-mpoksl");
    			set_style(div0, "background-color", colors[/*color*/ ctx[13].toLowerCase()]);
    			add_location(div0, file$D, 319, 32, 10711);
    			attr_dev(div1, "class", "color_border svelte-mpoksl");
    			set_style(div1, "border", "0px solid " + colors[/*color*/ ctx[13].toLowerCase()] + " ");
    			toggle_class(div1, "active", /*product*/ ctx[10].color == /*color*/ ctx[13]);
    			add_location(div1, file$D, 312, 28, 10281);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t);

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", click_handler_2, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*displayProducts*/ 1) {
    				set_style(div0, "background-color", colors[/*color*/ ctx[13].toLowerCase()]);
    			}

    			if (dirty & /*displayProducts*/ 1) {
    				set_style(div1, "border", "0px solid " + colors[/*color*/ ctx[13].toLowerCase()] + " ");
    			}

    			if (dirty & /*displayProducts*/ 1) {
    				toggle_class(div1, "active", /*product*/ ctx[10].color == /*color*/ ctx[13]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(312:24) {#each product.colors as color}",
    		ctx
    	});

    	return block;
    }

    // (260:12) {#each displayProducts as product}
    function create_each_block$d(ctx) {
    	let div6;
    	let a;
    	let img0;
    	let img0_src_value;
    	let a_href_value;
    	let t0;
    	let div2;
    	let div0;
    	let img1;
    	let img1_src_value;
    	let t1;
    	let div1;
    	let img2;
    	let img2_src_value;
    	let t2;
    	let div4;
    	let span0;
    	let t3_value = /*product*/ ctx[10].name + "";
    	let t3;
    	let t4;
    	let span1;
    	let t5_value = /*product*/ ctx[10].creator + "";
    	let t5;
    	let t6;
    	let div3;
    	let t7;
    	let div5;
    	let t8;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[5](/*product*/ ctx[10]);
    	}

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[6](/*product*/ ctx[10]);
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*product*/ ctx[10].discount) return create_if_block$n;
    		return create_else_block$i;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);
    	let each_value_1 = /*product*/ ctx[10].colors;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div6 = element("div");
    			a = element("a");
    			img0 = element("img");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			img1 = element("img");
    			t1 = space();
    			div1 = element("div");
    			img2 = element("img");
    			t2 = space();
    			div4 = element("div");
    			span0 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			span1 = element("span");
    			t5 = text(t5_value);
    			t6 = space();
    			div3 = element("div");
    			if_block.c();
    			t7 = space();
    			div5 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t8 = space();
    			attr_dev(img0, "class", "product_img svelte-mpoksl");

    			if (img0.src !== (img0_src_value = /*product*/ ctx[10].imgs[/*product*/ ctx[10].color
    			? /*product*/ ctx[10].color
    			: /*product*/ ctx[10].featuredColor][/*product*/ ctx[10].featuredFace])) attr_dev(img0, "src", img0_src_value);

    			attr_dev(img0, "alt", "product");
    			add_location(img0, file$D, 265, 24, 7689);
    			attr_dev(a, "href", a_href_value = "/" + /*product*/ ctx[10].creator + "/merch/" + /*product*/ ctx[10].id);
    			add_location(a, file$D, 262, 20, 7547);
    			if (img1.src !== (img1_src_value = "/img/misc/cart.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "cart");
    			attr_dev(img1, "class", "svelte-mpoksl");
    			add_location(img1, file$D, 273, 28, 8061);
    			attr_dev(div0, "class", "icon1 svelte-mpoksl");
    			add_location(div0, file$D, 272, 24, 8012);

    			if (img2.src !== (img2_src_value = (/*$user*/ ctx[1].docData?.wishlist[/*product*/ ctx[10].creator + "-" + /*product*/ ctx[10].id])
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/heart.png")) attr_dev(img2, "src", img2_src_value);

    			attr_dev(img2, "alt", "heart");
    			attr_dev(img2, "class", "svelte-mpoksl");
    			add_location(img2, file$D, 291, 28, 9017);
    			attr_dev(div1, "class", "icon2 svelte-mpoksl");
    			add_location(div1, file$D, 289, 24, 8872);
    			attr_dev(div2, "class", "cartBtns svelte-mpoksl");
    			add_location(div2, file$D, 271, 20, 7964);
    			attr_dev(span0, "class", "product_title svelte-mpoksl");
    			add_location(span0, file$D, 295, 24, 9292);
    			attr_dev(span1, "class", "product_creator svelte-mpoksl");
    			add_location(span1, file$D, 296, 24, 9367);
    			attr_dev(div3, "class", "product_price svelte-mpoksl");
    			add_location(div3, file$D, 297, 24, 9447);
    			attr_dev(div4, "class", "productInfo svelte-mpoksl");
    			add_location(div4, file$D, 294, 20, 9241);
    			attr_dev(div5, "class", "colors svelte-mpoksl");
    			add_location(div5, file$D, 310, 20, 10174);
    			attr_dev(div6, "class", "single_product svelte-mpoksl");
    			add_location(div6, file$D, 261, 16, 7497);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, a);
    			append_dev(a, img0);
    			append_dev(div6, t0);
    			append_dev(div6, div2);
    			append_dev(div2, div0);
    			append_dev(div0, img1);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, img2);
    			append_dev(div6, t2);
    			append_dev(div6, div4);
    			append_dev(div4, span0);
    			append_dev(span0, t3);
    			append_dev(div4, t4);
    			append_dev(div4, span1);
    			append_dev(span1, t5);
    			append_dev(div4, t6);
    			append_dev(div4, div3);
    			if_block.m(div3, null);
    			append_dev(div6, t7);
    			append_dev(div6, div5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div5, null);
    			}

    			append_dev(div6, t8);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a)),
    					listen_dev(img1, "click", click_handler, false, false, false),
    					listen_dev(div1, "click", click_handler_1, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*displayProducts*/ 1 && img0.src !== (img0_src_value = /*product*/ ctx[10].imgs[/*product*/ ctx[10].color
    			? /*product*/ ctx[10].color
    			: /*product*/ ctx[10].featuredColor][/*product*/ ctx[10].featuredFace])) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty & /*displayProducts*/ 1 && a_href_value !== (a_href_value = "/" + /*product*/ ctx[10].creator + "/merch/" + /*product*/ ctx[10].id)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty & /*$user, displayProducts*/ 3 && img2.src !== (img2_src_value = (/*$user*/ ctx[1].docData?.wishlist[/*product*/ ctx[10].creator + "-" + /*product*/ ctx[10].id])
    			? "/img/misc/filled-heart-1.png"
    			: "/img/misc/heart.png")) {
    				attr_dev(img2, "src", img2_src_value);
    			}

    			if (dirty & /*displayProducts*/ 1 && t3_value !== (t3_value = /*product*/ ctx[10].name + "")) set_data_dev(t3, t3_value);
    			if (dirty & /*displayProducts*/ 1 && t5_value !== (t5_value = /*product*/ ctx[10].creator + "")) set_data_dev(t5, t5_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div3, null);
    				}
    			}

    			if (dirty & /*colors, displayProducts, console*/ 1) {
    				each_value_1 = /*product*/ ctx[10].colors;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div5, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if_block.d();
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(260:12) {#each displayProducts as product}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let div3;
    	let div0;

    	let t0_value = ({
    		"fr": "Ma Liste D'envie",
    		"en": "My Wishlist"
    	})[/*$lang*/ ctx[2]] + "";

    	let t0;
    	let t1;
    	let hr;
    	let t2;
    	let div2;
    	let div1;
    	let each_value = /*displayProducts*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			div2 = element("div");
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "big_title svelte-mpoksl");
    			add_location(div0, file$D, 250, 4, 7200);
    			attr_dev(hr, "class", "svelte-mpoksl");
    			add_location(hr, file$D, 255, 4, 7338);
    			attr_dev(div1, "class", "u_products svelte-mpoksl");
    			add_location(div1, file$D, 258, 8, 7393);
    			attr_dev(div2, "class", "product_container svelte-mpoksl");
    			add_location(div2, file$D, 257, 4, 7352);
    			attr_dev(div3, "class", "profile_container svelte-mpoksl");
    			add_location(div3, file$D, 249, 0, 7163);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, hr);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$lang*/ 4 && t0_value !== (t0_value = ({
    				"fr": "Ma Liste D'envie",
    				"en": "My Wishlist"
    			})[/*$lang*/ ctx[2]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*displayProducts, colors, console, addWishlist, $user, cart, notification*/ 11) {
    				each_value = /*displayProducts*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div1, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $user;
    	let $lang;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(1, $user = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(2, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Wishlist", slots, []);

    	let unsubscribeUser = () => {
    		
    	};

    	onMount(async () => {
    		unsubscribeUser = user.subscribe(async () => {
    			if ($user?.docData?.wishlist) {
    				$$invalidate(0, displayProducts = []);
    				let mapped = {};

    				for (let slug of Object.keys($user.docData.wishlist)) {
    					let [creatorid, itemid] = slug.split("-", 2);
    					mapped[creatorid] = mapped[creatorid] || [];
    					mapped[creatorid].push(itemid);
    				}

    				for (let [creatorid, items] of Object.entries(mapped)) {
    					let data = await dbWrapper.get("/creators/" + creatorid + "/merch/all");

    					for (let item of items) {
    						let ditem = data[item];

    						for (let [col, facades] of Object.entries(ditem.imgs)) {
    							console.log(facades);

    							for (let [facade, id] of Object.entries(facades)) {
    								let path = "creators/" + creatorid + "/merch/" + item + "/" + facade + "-" + col;
    								console.log(ditem.imgs);
    								ditem.imgs[col][facade] = uuidToImageLink(id, path);
    								console.log(ditem.imgs[col][facade]);
    							}
    						}

    						displayProducts.push(ditem);
    					}
    				}
    			}

    			$$invalidate(0, displayProducts);
    		});
    	});

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	let { params = {} } = $$props;
    	let loaded = false;
    	let displayProducts = [];

    	const addWishlist = nid => {
    		if ($user.docData.wishlist && Object.keys($user.docData.wishlist).includes(nid)) {
    			// remove it
    			console.log("removing " + nid);

    			db.collection("users").doc($user.uid).update({
    				["wishlist." + nid]: firebase.firestore.FieldValue.delete()
    			});

    			delete $user.docData.wishlist[nid];
    			user.set($user);
    		} else {
    			console.log("adding " + nid);
    			db.collection("users").doc($user.uid).set({ wishlist: { [nid]: true } }, { merge: true });

    			set_store_value(
    				user,
    				$user = {
    					...$user,
    					docData: {
    						...$user.docData,
    						wishlist: { ...$user.docData.wishlist, [nid]: true }
    					}
    				},
    				$user
    			);
    		}
    	};

    	const writable_props = ["params"];

    	Object_1$g.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$h.warn(`<Wishlist> was created with unknown prop '${key}'`);
    	});

    	const click_handler = product => {
    		cart.add({
    			[product.creator + "-" + product.id]: { ...product, quantity: 1 }
    		});

    		notification.set({
    			accentColor: "success",
    			title: "success",
    			content: "Article Added to Cart"
    		});
    	};

    	const click_handler_1 = product => {
    		addWishlist(product.creator + "-" + product.id);
    	};

    	const click_handler_2 = (product, color, each_value, product_index) => {
    		$$invalidate(0, each_value[product_index].color = color, displayProducts);
    		console.log(product.color, color);
    	};

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(4, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		dbWrapper,
    		user,
    		db,
    		uuidToImageLink,
    		socialMedias,
    		notification,
    		colors,
    		cart,
    		lang,
    		link,
    		onMount,
    		onDestroy,
    		unsubscribeUser,
    		params,
    		loaded,
    		displayProducts,
    		addWishlist,
    		$user,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    		if ("params" in $$props) $$invalidate(4, params = $$props.params);
    		if ("loaded" in $$props) loaded = $$props.loaded;
    		if ("displayProducts" in $$props) $$invalidate(0, displayProducts = $$props.displayProducts);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		displayProducts,
    		$user,
    		$lang,
    		addWishlist,
    		params,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Wishlist extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, { params: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Wishlist",
    			options,
    			id: create_fragment$K.name
    		});
    	}

    	get params() {
    		throw new Error("<Wishlist>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Wishlist>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\UserProfile\Orders.svelte generated by Svelte v3.32.3 */

    const { Object: Object_1$h, console: console_1$i } = globals;
    const file$E = "src\\components\\UserProfile\\Orders.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    // (486:56) 
    function create_if_block_2$8(ctx) {
    	let div8;
    	let div6;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div5;
    	let t11;
    	let hr;
    	let t12;
    	let div7;
    	let each_value = /*displayProducts*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			div0.textContent = "ID";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Product";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Quantity";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "Price";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "Date";
    			t9 = space();
    			div5 = element("div");
    			div5.textContent = "Status";
    			t11 = space();
    			hr = element("hr");
    			t12 = space();
    			div7 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "id_title svelte-3auqp");
    			add_location(div0, file$E, 488, 12, 13396);
    			attr_dev(div1, "class", "Product_title svelte-3auqp");
    			add_location(div1, file$E, 489, 12, 13440);
    			attr_dev(div2, "class", "Quantity_title svelte-3auqp");
    			add_location(div2, file$E, 490, 12, 13494);
    			attr_dev(div3, "class", "Price_title svelte-3auqp");
    			add_location(div3, file$E, 491, 12, 13550);
    			attr_dev(div4, "class", "Date_title svelte-3auqp");
    			add_location(div4, file$E, 492, 12, 13600);
    			attr_dev(div5, "class", "Status_title svelte-3auqp");
    			add_location(div5, file$E, 493, 12, 13648);
    			attr_dev(div6, "class", "titles svelte-3auqp");
    			add_location(div6, file$E, 487, 8, 13362);
    			attr_dev(hr, "class", "hr_to_remove svelte-3auqp");
    			add_location(hr, file$E, 495, 8, 13712);
    			attr_dev(div7, "class", "u_products svelte-3auqp");
    			add_location(div7, file$E, 496, 8, 13749);
    			attr_dev(div8, "class", "product_container svelte-3auqp");
    			add_location(div8, file$E, 486, 4, 13321);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div6);
    			append_dev(div6, div0);
    			append_dev(div6, t1);
    			append_dev(div6, div1);
    			append_dev(div6, t3);
    			append_dev(div6, div2);
    			append_dev(div6, t5);
    			append_dev(div6, div3);
    			append_dev(div6, t7);
    			append_dev(div6, div4);
    			append_dev(div6, t9);
    			append_dev(div6, div5);
    			append_dev(div8, t11);
    			append_dev(div8, hr);
    			append_dev(div8, t12);
    			append_dev(div8, div7);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div7, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*statusColors, displayProducts, formatTimestampToDate, colors, params*/ 51) {
    				each_value = /*displayProducts*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div7, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(486:56) ",
    		ctx
    	});

    	return block;
    }

    // (484:57) 
    function create_if_block_1$f(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No Products";
    			add_location(div, file$E, 484, 8, 13235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(484:57) ",
    		ctx
    	});

    	return block;
    }

    // (468:4) {#if initialized == false}
    function create_if_block$o(ctx) {
    	let div8;
    	let div6;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div5;
    	let t11;
    	let hr;
    	let t12;
    	let div7;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { height: "75px", width: "75px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div8 = element("div");
    			div6 = element("div");
    			div0 = element("div");
    			div0.textContent = "ID";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "Product";
    			t3 = space();
    			div2 = element("div");
    			div2.textContent = "Quantity";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "Price";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "Date";
    			t9 = space();
    			div5 = element("div");
    			div5.textContent = "Status";
    			t11 = space();
    			hr = element("hr");
    			t12 = space();
    			div7 = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div0, "class", "id_title svelte-3auqp");
    			add_location(div0, file$E, 470, 12, 12687);
    			attr_dev(div1, "class", "Product_title svelte-3auqp");
    			add_location(div1, file$E, 471, 12, 12731);
    			attr_dev(div2, "class", "Quantity_title svelte-3auqp");
    			add_location(div2, file$E, 472, 12, 12785);
    			attr_dev(div3, "class", "Price_title svelte-3auqp");
    			add_location(div3, file$E, 473, 12, 12841);
    			attr_dev(div4, "class", "Date_title svelte-3auqp");
    			add_location(div4, file$E, 474, 12, 12891);
    			attr_dev(div5, "class", "Status_title svelte-3auqp");
    			add_location(div5, file$E, 475, 12, 12939);
    			attr_dev(div6, "class", "titles svelte-3auqp");
    			add_location(div6, file$E, 469, 8, 12653);
    			attr_dev(hr, "class", "hr_to_remove svelte-3auqp");
    			add_location(hr, file$E, 477, 8, 13003);
    			attr_dev(div7, "class", "u_products u-spin-area svelte-3auqp");
    			add_location(div7, file$E, 478, 8, 13040);
    			attr_dev(div8, "class", "product_container svelte-3auqp");
    			add_location(div8, file$E, 468, 4, 12612);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div8, anchor);
    			append_dev(div8, div6);
    			append_dev(div6, div0);
    			append_dev(div6, t1);
    			append_dev(div6, div1);
    			append_dev(div6, t3);
    			append_dev(div6, div2);
    			append_dev(div6, t5);
    			append_dev(div6, div3);
    			append_dev(div6, t7);
    			append_dev(div6, div4);
    			append_dev(div6, t9);
    			append_dev(div6, div5);
    			append_dev(div8, t11);
    			append_dev(div8, hr);
    			append_dev(div8, t12);
    			append_dev(div8, div7);
    			mount_component(materialspinner, div7, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div8);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(468:4) {#if initialized == false}",
    		ctx
    	});

    	return block;
    }

    // (498:17) {#each displayProducts as product}
    function create_each_block$e(ctx) {
    	let div19;
    	let div0;
    	let a0;
    	let img0;
    	let img0_src_value;
    	let a0_href_value;
    	let t0;
    	let div18;
    	let div1;
    	let t1;
    	let t2_value = /*product*/ ctx[10].cartID + "";
    	let t2;
    	let t3;
    	let div10;
    	let a1;
    	let img1;
    	let img1_src_value;
    	let a1_href_value;
    	let t4;
    	let div9;
    	let div2;

    	let t5_value = (/*product*/ ctx[10].name.length > 15
    	? /*product*/ ctx[10].name.substr(0, 10) + "..."
    	: /*product*/ ctx[10].name) + "";

    	let t5;
    	let t6_value = "#" + /*product*/ ctx[10].id + "";
    	let t6;
    	let t7;
    	let div3;
    	let t8_value = /*product*/ ctx[10].creator + "";
    	let t8;
    	let t9;
    	let div8;
    	let div5;
    	let t10;
    	let div4;
    	let t11;
    	let div7;
    	let t12;
    	let div6;
    	let t13_value = /*product*/ ctx[10].size + "";
    	let t13;
    	let t14;
    	let div12;
    	let div11;
    	let t16_value = /*product*/ ctx[10].quantity + "";
    	let t16;
    	let t17;
    	let div14;
    	let div13;
    	let t19_value = /*product*/ ctx[10].price + "";
    	let t19;
    	let t20;
    	let t21;
    	let div16;
    	let div15;
    	let t23_value = /*formatTimestampToDate*/ ctx[5](/*product*/ ctx[10].timestamp) + "";
    	let t23;
    	let t24;
    	let div17;
    	let t25_value = /*product*/ ctx[10].status + "";
    	let t25;
    	let t26;
    	let hr;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div19 = element("div");
    			div0 = element("div");
    			a0 = element("a");
    			img0 = element("img");
    			t0 = space();
    			div18 = element("div");
    			div1 = element("div");
    			t1 = text("#");
    			t2 = text(t2_value);
    			t3 = space();
    			div10 = element("div");
    			a1 = element("a");
    			img1 = element("img");
    			t4 = space();
    			div9 = element("div");
    			div2 = element("div");
    			t5 = text(t5_value);
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			t8 = text(t8_value);
    			t9 = space();
    			div8 = element("div");
    			div5 = element("div");
    			t10 = text("Color:\r\n                                    ");
    			div4 = element("div");
    			t11 = space();
    			div7 = element("div");
    			t12 = text("Size:\r\n                                    ");
    			div6 = element("div");
    			t13 = text(t13_value);
    			t14 = space();
    			div12 = element("div");
    			div11 = element("div");
    			div11.textContent = "Quantity: ";
    			t16 = text(t16_value);
    			t17 = space();
    			div14 = element("div");
    			div13 = element("div");
    			div13.textContent = "Price: ";
    			t19 = text(t19_value);
    			t20 = text(" TND");
    			t21 = space();
    			div16 = element("div");
    			div15 = element("div");
    			div15.textContent = "Date: ";
    			t23 = text(t23_value);
    			t24 = space();
    			div17 = element("div");
    			t25 = text(t25_value);
    			t26 = space();
    			hr = element("hr");
    			attr_dev(img0, "class", "product_img svelte-3auqp");
    			if (img0.src !== (img0_src_value = /*product*/ ctx[10].img)) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "product");
    			add_location(img0, file$E, 502, 28, 14071);
    			attr_dev(a0, "href", a0_href_value = "/" + /*params*/ ctx[0].userid + "/merch/" + /*product*/ ctx[10].id);
    			attr_dev(a0, "class", "p_img svelte-3auqp");
    			add_location(a0, file$E, 501, 24, 13963);
    			attr_dev(div0, "class", "right_part svelte-3auqp");
    			add_location(div0, file$E, 500, 20, 13913);
    			attr_dev(div1, "class", "id svelte-3auqp");
    			add_location(div1, file$E, 506, 24, 14259);
    			attr_dev(img1, "class", "product_img svelte-3auqp");
    			if (img1.src !== (img1_src_value = /*product*/ ctx[10].img)) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "product");
    			add_location(img1, file$E, 510, 28, 14477);
    			attr_dev(a1, "href", a1_href_value = "/" + /*params*/ ctx[0].userid + "/merch/" + /*product*/ ctx[10].id);
    			attr_dev(a1, "class", "p_img svelte-3auqp");
    			add_location(a1, file$E, 509, 24, 14369);
    			attr_dev(div2, "class", "p_title svelte-3auqp");
    			add_location(div2, file$E, 513, 28, 14642);
    			attr_dev(div3, "class", "p_content_creator svelte-3auqp");
    			add_location(div3, file$E, 514, 28, 14792);
    			attr_dev(div4, "class", "shape svelte-3auqp");
    			set_style(div4, "background-color", colors[/*product*/ ctx[10].color.toLowerCase()]);
    			add_location(div4, file$E, 518, 36, 15035);
    			attr_dev(div5, "class", "color svelte-3auqp");
    			add_location(div5, file$E, 516, 32, 14934);
    			attr_dev(div6, "class", "shape svelte-3auqp");
    			add_location(div6, file$E, 522, 36, 15292);
    			attr_dev(div7, "class", "size svelte-3auqp");
    			add_location(div7, file$E, 520, 32, 15193);
    			attr_dev(div8, "class", "color_size svelte-3auqp");
    			add_location(div8, file$E, 515, 28, 14876);
    			attr_dev(div9, "class", "p_info svelte-3auqp");
    			add_location(div9, file$E, 512, 24, 14592);
    			attr_dev(div10, "class", "product svelte-3auqp");
    			add_location(div10, file$E, 508, 20, 14322);
    			attr_dev(div11, "class", "reference svelte-3auqp");
    			add_location(div11, file$E, 529, 42, 15543);
    			attr_dev(div12, "class", "quantity svelte-3auqp");
    			add_location(div12, file$E, 529, 20, 15521);
    			attr_dev(div13, "class", "reference svelte-3auqp");
    			add_location(div13, file$E, 531, 45, 15655);
    			attr_dev(div14, "class", "total_price svelte-3auqp");
    			add_location(div14, file$E, 531, 20, 15630);
    			attr_dev(div15, "class", "reference svelte-3auqp");
    			add_location(div15, file$E, 533, 38, 15758);
    			attr_dev(div16, "class", "date svelte-3auqp");
    			add_location(div16, file$E, 533, 20, 15740);
    			attr_dev(div17, "class", "status svelte-3auqp");
    			set_style(div17, "background-color", "#" + /*statusColors*/ ctx[4][/*product*/ ctx[10].status]);
    			add_location(div17, file$E, 535, 16, 15878);
    			attr_dev(div18, "class", "left_part svelte-3auqp");
    			add_location(div18, file$E, 505, 20, 14210);
    			attr_dev(div19, "class", "single_product svelte-3auqp");
    			add_location(div19, file$E, 499, 16, 13863);
    			attr_dev(hr, "class", "svelte-3auqp");
    			add_location(hr, file$E, 541, 12, 16120);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div19, anchor);
    			append_dev(div19, div0);
    			append_dev(div0, a0);
    			append_dev(a0, img0);
    			append_dev(div19, t0);
    			append_dev(div19, div18);
    			append_dev(div18, div1);
    			append_dev(div1, t1);
    			append_dev(div1, t2);
    			append_dev(div18, t3);
    			append_dev(div18, div10);
    			append_dev(div10, a1);
    			append_dev(a1, img1);
    			append_dev(div10, t4);
    			append_dev(div10, div9);
    			append_dev(div9, div2);
    			append_dev(div2, t5);
    			append_dev(div2, t6);
    			append_dev(div9, t7);
    			append_dev(div9, div3);
    			append_dev(div3, t8);
    			append_dev(div9, t9);
    			append_dev(div9, div8);
    			append_dev(div8, div5);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div8, t11);
    			append_dev(div8, div7);
    			append_dev(div7, t12);
    			append_dev(div7, div6);
    			append_dev(div6, t13);
    			append_dev(div18, t14);
    			append_dev(div18, div12);
    			append_dev(div12, div11);
    			append_dev(div12, t16);
    			append_dev(div18, t17);
    			append_dev(div18, div14);
    			append_dev(div14, div13);
    			append_dev(div14, t19);
    			append_dev(div14, t20);
    			append_dev(div18, t21);
    			append_dev(div18, div16);
    			append_dev(div16, div15);
    			append_dev(div16, t23);
    			append_dev(div18, t24);
    			append_dev(div18, div17);
    			append_dev(div17, t25);
    			insert_dev(target, t26, anchor);
    			insert_dev(target, hr, anchor);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*displayProducts*/ 2 && img0.src !== (img0_src_value = /*product*/ ctx[10].img)) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (dirty & /*params, displayProducts*/ 3 && a0_href_value !== (a0_href_value = "/" + /*params*/ ctx[0].userid + "/merch/" + /*product*/ ctx[10].id)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (dirty & /*displayProducts*/ 2 && t2_value !== (t2_value = /*product*/ ctx[10].cartID + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*displayProducts*/ 2 && img1.src !== (img1_src_value = /*product*/ ctx[10].img)) {
    				attr_dev(img1, "src", img1_src_value);
    			}

    			if (dirty & /*params, displayProducts*/ 3 && a1_href_value !== (a1_href_value = "/" + /*params*/ ctx[0].userid + "/merch/" + /*product*/ ctx[10].id)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			if (dirty & /*displayProducts*/ 2 && t5_value !== (t5_value = (/*product*/ ctx[10].name.length > 15
    			? /*product*/ ctx[10].name.substr(0, 10) + "..."
    			: /*product*/ ctx[10].name) + "")) set_data_dev(t5, t5_value);

    			if (dirty & /*displayProducts*/ 2 && t6_value !== (t6_value = "#" + /*product*/ ctx[10].id + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*displayProducts*/ 2 && t8_value !== (t8_value = /*product*/ ctx[10].creator + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*displayProducts*/ 2) {
    				set_style(div4, "background-color", colors[/*product*/ ctx[10].color.toLowerCase()]);
    			}

    			if (dirty & /*displayProducts*/ 2 && t13_value !== (t13_value = /*product*/ ctx[10].size + "")) set_data_dev(t13, t13_value);
    			if (dirty & /*displayProducts*/ 2 && t16_value !== (t16_value = /*product*/ ctx[10].quantity + "")) set_data_dev(t16, t16_value);
    			if (dirty & /*displayProducts*/ 2 && t19_value !== (t19_value = /*product*/ ctx[10].price + "")) set_data_dev(t19, t19_value);
    			if (dirty & /*displayProducts*/ 2 && t23_value !== (t23_value = /*formatTimestampToDate*/ ctx[5](/*product*/ ctx[10].timestamp) + "")) set_data_dev(t23, t23_value);
    			if (dirty & /*displayProducts*/ 2 && t25_value !== (t25_value = /*product*/ ctx[10].status + "")) set_data_dev(t25, t25_value);

    			if (dirty & /*displayProducts*/ 2) {
    				set_style(div17, "background-color", "#" + /*statusColors*/ ctx[4][/*product*/ ctx[10].status]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div19);
    			if (detaching) detach_dev(t26);
    			if (detaching) detach_dev(hr);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(498:17) {#each displayProducts as product}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let div1;
    	let div0;
    	let t0_value = ({ "fr": "Mes Commandes", "en": "My Orders" })[/*$lang*/ ctx[3]] + "";
    	let t0;
    	let t1;
    	let hr;
    	let t2;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$o, create_if_block_1$f, create_if_block_2$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*initialized*/ ctx[2] == false) return 0;
    		if (/*initialized*/ ctx[2] && /*displayProducts*/ ctx[1].length == 0) return 1;
    		if (/*initialized*/ ctx[2] && /*displayProducts*/ ctx[1].length > 0) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			hr = element("hr");
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "big_title svelte-3auqp");
    			add_location(div0, file$E, 459, 4, 12403);
    			attr_dev(hr, "class", "hr_to_remove svelte-3auqp");
    			add_location(hr, file$E, 465, 4, 12546);
    			attr_dev(div1, "class", "profile_container svelte-3auqp");
    			add_location(div1, file$E, 458, 0, 12366);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, hr);
    			append_dev(div1, t2);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*$lang*/ 8) && t0_value !== (t0_value = ({ "fr": "Mes Commandes", "en": "My Orders" })[/*$lang*/ ctx[3]] + "")) set_data_dev(t0, t0_value);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(3, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Orders", slots, []);
    	let { params = {} } = $$props;
    	let loaded = false;

    	let displayProducts = [
    		{
    			"id": "RQGHN7",
    			"img": "../img/hoodie.png",
    			"creator": "ti3leh",
    			"name": "hoodie 7amra",
    			"color": "0e80f6",
    			"size": "S",
    			"qty": "1",
    			"price": "69.99",
    			"date": "27/01/2021",
    			"status": "in delivery",
    			"statusColor": "ffb100"
    		},
    		{
    			"id": "GJYS78",
    			"img": "../img/tshirt.png",
    			"creator": "beki",
    			"name": "tshirt unique feras",
    			"color": "d40019",
    			"size": "S",
    			"qty": "2",
    			"price": "98.50",
    			"date": "22/01/2021",
    			"status": "Delivered",
    			"statusColor": "34bf65"
    		},
    		{
    			"id": "GJYS78",
    			"img": "../img/tshirt.png",
    			"creator": "beki",
    			"name": "tshirt unique feras",
    			"color": "d40019",
    			"size": "S",
    			"qty": "2",
    			"price": "98.50",
    			"date": "22/01/2021",
    			"status": "Printing",
    			"statusColor": "2985d4"
    		},
    		{
    			"id": "GJYS78",
    			"img": "../img/tshirt.png",
    			"creator": "beki",
    			"name": "tshirt unique feras",
    			"color": "d40019",
    			"size": "S",
    			"qty": "2",
    			"price": "98.50",
    			"date": "22/01/2021",
    			"status": "Delivered",
    			"statusColor": "34bf65"
    		}
    	];

    	const statusColors = {
    		"Delivered": "34bf65",
    		"Printing": "2985d4",
    		"Delivering": "ffb100",
    		"In Progress": "34bf65"
    	};

    	displayProducts = [];
    	let name = "";

    	/* dbWrapper.get("/creators/omg3r/merch/all").then((data) => {
         console.log(data);
         if (data == undefined) {
             displayProducts = [];
             loaded = true;
             return;
         }

         displayProducts = Object.entries(data).map(([key, value]) => {
             value.id = key;
             for (let x of ["front", "back"]) {
                 value.imgs[x] = uuidToImageLink(
                     value.imgs[x],
                     "creators/omg3r/merch/" + key + "/" + x
                 );
             }
             return value;
         });
         console.log(displayProducts);
         let loaded = true;
     });*/
    	let orders = {};

    	let initialized = false;

    	let unsubscribeUser = user.subscribe(async v => {
    		if (v == 0) {
    			return;
    		}

    		if (v == undefined) ; else {
    			console.log(v.uid);
    			let path = "users/" + v.uid;
    			console.log(path);
    			let data = await dbWrapper.get(path, true);
    			orders = data.orders || {};
    			console.log("eorders");
    			console.log(data);
    			console.log("orders");

    			if (Object.keys(orders).length == 0) {
    				$$invalidate(2, initialized = true);
    				return;
    			}

    			$$invalidate(1, displayProducts = []);

    			for (let [key, values] of Object.entries(orders)) {
    				for (let [lkey, iteminfo] of Object.entries(values.items)) {
    					console.log(iteminfo.creator);
    					let path = "creators/" + iteminfo.creator + "/merch/all";
    					let data = await dbWrapper.get(path, true);
    					console.log("d");
    					console.log(data);
    					console.log("iteminfo");
    					console.log(iteminfo);
    					console.log(data[iteminfo.id]);
    					iteminfo.img = uuidToImageLink(data[iteminfo.id].imgs[iteminfo.color][data[iteminfo.id].featuredFace], "creators/" + iteminfo.creator + "/merch/" + iteminfo.id + "/" + data[iteminfo.id].featuredFace + "-" + iteminfo.color);
    					iteminfo.price = data[iteminfo.id].price;
    					iteminfo.name = data[iteminfo.id].name;
    					iteminfo.cartID = key;
    					console.log(values);
    					iteminfo.timestamp = values.timestamp?.seconds || 1610233362;

    					if (iteminfo.status == undefined) {
    						iteminfo.status = "In Progress";
    					}

    					displayProducts.push(iteminfo);
    				}
    			}

    			displayProducts.sort((a, b) => parseFloat(b.timestamp) - parseFloat(a.timestamp));
    			$$invalidate(1, displayProducts);
    			console.log("finished");
    			console.log(orders);
    			console.log(displayProducts);
    			$$invalidate(2, initialized = true);
    		}
    	});

    	const formatTimestampToDate = t => {
    		const a = new Date(t * 1000);
    		const year = a.getFullYear();
    		const month = a.getMonth() + 1;
    		const date = a.getDate() + 1;
    		return date + "/" + month + "/" + year;
    	};

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	const writable_props = ["params"];

    	Object_1$h.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$i.warn(`<Orders> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		dbWrapper,
    		user,
    		uuidToImageLink,
    		socialMedias,
    		colors,
    		link,
    		onDestroy,
    		MaterialSpinner,
    		lang,
    		params,
    		loaded,
    		displayProducts,
    		statusColors,
    		name,
    		orders,
    		initialized,
    		unsubscribeUser,
    		formatTimestampToDate,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(0, params = $$props.params);
    		if ("loaded" in $$props) loaded = $$props.loaded;
    		if ("displayProducts" in $$props) $$invalidate(1, displayProducts = $$props.displayProducts);
    		if ("name" in $$props) name = $$props.name;
    		if ("orders" in $$props) orders = $$props.orders;
    		if ("initialized" in $$props) $$invalidate(2, initialized = $$props.initialized);
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		params,
    		displayProducts,
    		initialized,
    		$lang,
    		statusColors,
    		formatTimestampToDate
    	];
    }

    class Orders extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, { params: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Orders",
    			options,
    			id: create_fragment$L.name
    		});
    	}

    	get params() {
    		throw new Error("<Orders>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Orders>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\UserProfile\Layout.svelte generated by Svelte v3.32.3 */
    const file$F = "src\\components\\UserProfile\\Layout.svelte";

    // (155:42) 
    function create_if_block_2$9(ctx) {
    	let orders;
    	let current;
    	orders = new Orders({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(orders.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(orders, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(orders.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(orders.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(orders, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(155:42) ",
    		ctx
    	});

    	return block;
    }

    // (153:44) 
    function create_if_block_1$g(ctx) {
    	let wishlist;
    	let current;
    	wishlist = new Wishlist({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wishlist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wishlist, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wishlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wishlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wishlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(153:44) ",
    		ctx
    	});

    	return block;
    }

    // (151:8) {#if currentPage == 'profile'}
    function create_if_block$p(ctx) {
    	let profile;
    	let current;
    	profile = new Profile({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(profile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(profile, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(profile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(profile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(profile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(151:8) {#if currentPage == 'profile'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let div4;
    	let div2;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let t2;
    	let div1;
    	let a0;
    	let t3;
    	let a0_class_value;
    	let t4;
    	let a1;
    	let t5;
    	let a1_class_value;
    	let t6;
    	let a2;
    	let t7;
    	let a2_class_value;
    	let t8;
    	let hr;
    	let t9;
    	let div3;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$p, create_if_block_1$g, create_if_block_2$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*currentPage*/ ctx[0] == "profile") return 0;
    		if (/*currentPage*/ ctx[0] == "wishlist") return 1;
    		if (/*currentPage*/ ctx[0] == "orders") return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			div0.textContent = "Ahmed Ben Mahmoud";
    			t2 = space();
    			div1 = element("div");
    			a0 = element("a");
    			t3 = text("Profile");
    			t4 = space();
    			a1 = element("a");
    			t5 = text("My Wishlist");
    			t6 = space();
    			a2 = element("a");
    			t7 = text("My Orders");
    			t8 = space();
    			hr = element("hr");
    			t9 = space();
    			div3 = element("div");
    			if (if_block) if_block.c();
    			if (img.src !== (img_src_value = "../img/ti3leh.jpg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "profilepic");
    			attr_dev(img, "class", "svelte-jftptn");
    			add_location(img, file$F, 122, 8, 2785);
    			attr_dev(div0, "class", "u_name svelte-jftptn");
    			add_location(div0, file$F, 123, 8, 2843);
    			attr_dev(a0, "href", "/myaccount/profile");
    			attr_dev(a0, "class", a0_class_value = "" + (null_to_empty(/*currentPage*/ ctx[0] == "profile" ? "active" : "") + " svelte-jftptn"));
    			add_location(a0, file$F, 125, 12, 2927);
    			attr_dev(a1, "href", "/myaccount/wishlist");
    			attr_dev(a1, "class", a1_class_value = "" + (null_to_empty(/*currentPage*/ ctx[0] == "wishlist" ? "active" : "") + " svelte-jftptn"));
    			add_location(a1, file$F, 132, 12, 3189);
    			attr_dev(a2, "href", "/myaccount/orders");
    			attr_dev(a2, "class", a2_class_value = "" + (null_to_empty(/*currentPage*/ ctx[0] == "orders" ? "active" : "") + " svelte-jftptn"));
    			add_location(a2, file$F, 139, 12, 3458);
    			attr_dev(div1, "class", "nav svelte-jftptn");
    			add_location(div1, file$F, 124, 8, 2896);
    			attr_dev(hr, "class", "mobilehr svelte-jftptn");
    			add_location(hr, file$F, 147, 8, 3731);
    			attr_dev(div2, "class", "profile_pic svelte-jftptn");
    			add_location(div2, file$F, 121, 4, 2750);
    			attr_dev(div3, "class", "profile_nav svelte-jftptn");
    			add_location(div3, file$F, 149, 4, 3772);
    			attr_dev(div4, "class", "layout svelte-jftptn");
    			add_location(div4, file$F, 120, 0, 2724);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, img);
    			append_dev(div2, t0);
    			append_dev(div2, div0);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, a0);
    			append_dev(a0, t3);
    			append_dev(div1, t4);
    			append_dev(div1, a1);
    			append_dev(a1, t5);
    			append_dev(div1, t6);
    			append_dev(div1, a2);
    			append_dev(a2, t7);
    			append_dev(div2, t8);
    			append_dev(div2, hr);
    			append_dev(div4, t9);
    			append_dev(div4, div3);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div3, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					listen_dev(a0, "click", /*click_handler*/ ctx[3], false, false, false),
    					action_destroyer(link.call(null, a1)),
    					listen_dev(a1, "click", /*click_handler_1*/ ctx[4], false, false, false),
    					action_destroyer(link.call(null, a2)),
    					listen_dev(a2, "click", /*click_handler_2*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*currentPage*/ 1 && a0_class_value !== (a0_class_value = "" + (null_to_empty(/*currentPage*/ ctx[0] == "profile" ? "active" : "") + " svelte-jftptn"))) {
    				attr_dev(a0, "class", a0_class_value);
    			}

    			if (!current || dirty & /*currentPage*/ 1 && a1_class_value !== (a1_class_value = "" + (null_to_empty(/*currentPage*/ ctx[0] == "wishlist" ? "active" : "") + " svelte-jftptn"))) {
    				attr_dev(a1, "class", a1_class_value);
    			}

    			if (!current || dirty & /*currentPage*/ 1 && a2_class_value !== (a2_class_value = "" + (null_to_empty(/*currentPage*/ ctx[0] == "orders" ? "active" : "") + " svelte-jftptn"))) {
    				attr_dev(a2, "class", a2_class_value);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(div3, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let currentPage;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Layout", slots, []);

    	let unsubscribeUser = () => {
    		
    	};

    	let { params = {} } = $$props;

    	onMount(async () => {
    		$$invalidate(0, currentPage = params.type);

    		unsubscribeUser = user.subscribe(v => {
    			if (v == undefined) {
    				navigate("/");
    			}
    		});
    	});

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	let handlepage = page => {
    		$$invalidate(0, currentPage = page);
    	};

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Layout> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		handlepage("profile");
    	};

    	const click_handler_1 = () => {
    		handlepage("wishlist");
    	};

    	const click_handler_2 = () => {
    		handlepage("orders");
    	};

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(2, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		Profile,
    		Wishlist,
    		Orders,
    		link,
    		navigate,
    		user,
    		onMount,
    		onDestroy,
    		unsubscribeUser,
    		params,
    		handlepage,
    		currentPage
    	});

    	$$self.$inject_state = $$props => {
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    		if ("params" in $$props) $$invalidate(2, params = $$props.params);
    		if ("handlepage" in $$props) $$invalidate(1, handlepage = $$props.handlepage);
    		if ("currentPage" in $$props) $$invalidate(0, currentPage = $$props.currentPage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*params*/ 4) {
    			$$invalidate(0, currentPage = params.type);
    		}
    	};

    	return [
    		currentPage,
    		handlepage,
    		params,
    		click_handler,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Layout extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { params: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Layout",
    			options,
    			id: create_fragment$M.name
    		});
    	}

    	get params() {
    		throw new Error("<Layout>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<Layout>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Footer.svelte generated by Svelte v3.32.3 */
    const file$G = "src\\components\\Footer.svelte";

    function create_fragment$N(ctx) {
    	let footer;
    	let div13;
    	let div2;
    	let div0;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let t1;
    	let div1;

    	let t2_value = ({
    		en: "Unify is the first platform dedicated to content creation in Tunisia that connects content creators and their supporters.",
    		fr: "Unify est la première plateforme dédiée à la création de contenu en Tunisie qui met en relation les créateurs de contenu et leurs fans."
    	})[/*$lang*/ ctx[0]] + "";

    	let t2;
    	let t3;
    	let div12;
    	let div5;
    	let div3;

    	let t4_value = ({
    		en: "Creators’ Hub",
    		fr: "Hub des créateurs"
    	})[/*$lang*/ ctx[0]] + "";

    	let t4;
    	let t5;
    	let div4;
    	let a0;
    	let t6_value = ({ en: "Merch", fr: "Marchandise" })[/*$lang*/ ctx[0]] + "";
    	let t6;
    	let t7;
    	let a1;

    	let t8_value = ({
    		en: "Custom Design",
    		fr: "Design Personnalisé"
    	})[/*$lang*/ ctx[0]] + "";

    	let t8;
    	let t9;
    	let a2;
    	let t10_value = ({ en: "Donation", fr: "Don" })[/*$lang*/ ctx[0]] + "";
    	let t10;
    	let t11;
    	let a3;
    	let t12_value = ({ en: "Subscription", fr: "Abonnements" })[/*$lang*/ ctx[0]] + "";
    	let t12;
    	let t13;
    	let div8;
    	let div6;
    	let t14_value = ({ en: "Unify", fr: "Unify" })[/*$lang*/ ctx[0]] + "";
    	let t14;
    	let t15;
    	let div7;
    	let a4;
    	let t16_value = ({ en: "About", fr: "À propos" })[/*$lang*/ ctx[0]] + "";
    	let t16;
    	let t17;
    	let a5;
    	let t18_value = ({ en: "Brand", fr: "Brand" })[/*$lang*/ ctx[0]] + "";
    	let t18;
    	let t19;
    	let a6;
    	let t20_value = ({ en: "Contact us", fr: "Contactez-nous" })[/*$lang*/ ctx[0]] + "";
    	let t20;
    	let t21;
    	let a7;

    	let t22_value = ({
    		en: "Methods of Payment",
    		fr: "Modes de paiement"
    	})[/*$lang*/ ctx[0]] + "";

    	let t22;
    	let t23;
    	let a8;
    	let t24_value = ({ en: "Terms", fr: "Termes" })[/*$lang*/ ctx[0]] + "";
    	let t24;
    	let t25;
    	let a9;
    	let t26_value = ({ en: "Policies", fr: "Politiques" })[/*$lang*/ ctx[0]] + "";
    	let t26;
    	let t27;
    	let a10;

    	let t28_value = ({
    		en: "Shipping & Delivery",
    		fr: "Expédition & Livraison"
    	})[/*$lang*/ ctx[0]] + "";

    	let t28;
    	let t29;
    	let div11;
    	let div9;

    	let t30_value = ({
    		en: "Social Media",
    		fr: "Réseaux sociaux"
    	})[/*$lang*/ ctx[0]] + "";

    	let t30;
    	let t31;
    	let div10;
    	let a11;
    	let img1;
    	let img1_src_value;
    	let t32;
    	let a12;
    	let img2;
    	let img2_src_value;
    	let t33;
    	let div14;
    	let span0;
    	let t34_value = ({ en: "Crafted With", fr: "Réalisé avec" })[/*$lang*/ ctx[0]] + "";
    	let t34;
    	let t35;
    	let img3;
    	let img3_src_value;
    	let t36;
    	let t37_value = ({ en: "By", fr: "Par " })[/*$lang*/ ctx[0]] + "";
    	let t37;
    	let t38;
    	let span1;
    	let t40;
    	let span2;

    	let t41_value = ({
    		en: "@ All rights reserved",
    		fr: "@ Tous Droits réservés "
    	})[/*$lang*/ ctx[0]] + "";

    	let t41;
    	let t42;
    	let div15;
    	let t43;
    	let div16;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			footer = element("footer");
    			div13 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			img0 = element("img");
    			t0 = text("\r\n                Unify");
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div12 = element("div");
    			div5 = element("div");
    			div3 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div4 = element("div");
    			a0 = element("a");
    			t6 = text(t6_value);
    			t7 = space();
    			a1 = element("a");
    			t8 = text(t8_value);
    			t9 = space();
    			a2 = element("a");
    			t10 = text(t10_value);
    			t11 = space();
    			a3 = element("a");
    			t12 = text(t12_value);
    			t13 = space();
    			div8 = element("div");
    			div6 = element("div");
    			t14 = text(t14_value);
    			t15 = space();
    			div7 = element("div");
    			a4 = element("a");
    			t16 = text(t16_value);
    			t17 = space();
    			a5 = element("a");
    			t18 = text(t18_value);
    			t19 = space();
    			a6 = element("a");
    			t20 = text(t20_value);
    			t21 = space();
    			a7 = element("a");
    			t22 = text(t22_value);
    			t23 = space();
    			a8 = element("a");
    			t24 = text(t24_value);
    			t25 = space();
    			a9 = element("a");
    			t26 = text(t26_value);
    			t27 = space();
    			a10 = element("a");
    			t28 = text(t28_value);
    			t29 = space();
    			div11 = element("div");
    			div9 = element("div");
    			t30 = text(t30_value);
    			t31 = space();
    			div10 = element("div");
    			a11 = element("a");
    			img1 = element("img");
    			t32 = space();
    			a12 = element("a");
    			img2 = element("img");
    			t33 = space();
    			div14 = element("div");
    			span0 = element("span");
    			t34 = text(t34_value);
    			t35 = space();
    			img3 = element("img");
    			t36 = space();
    			t37 = text(t37_value);
    			t38 = space();
    			span1 = element("span");
    			span1.textContent = "UNIFY";
    			t40 = space();
    			span2 = element("span");
    			t41 = text(t41_value);
    			t42 = space();
    			div15 = element("div");
    			t43 = space();
    			div16 = element("div");
    			if (img0.src !== (img0_src_value = "/img/logo_transaprent.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "logo");
    			attr_dev(img0, "class", "svelte-11x29hc");
    			add_location(img0, file$G, 209, 16, 4580);
    			attr_dev(div0, "class", "logo svelte-11x29hc");
    			add_location(div0, file$G, 208, 12, 4544);
    			attr_dev(div1, "class", "sub_text svelte-11x29hc");
    			add_location(div1, file$G, 213, 12, 4687);
    			attr_dev(div2, "class", "left_part svelte-11x29hc");
    			add_location(div2, file$G, 206, 8, 4505);
    			attr_dev(div3, "class", "title svelte-11x29hc");
    			add_location(div3, file$G, 223, 16, 5194);
    			attr_dev(a0, "target", "_blank");
    			attr_dev(a0, "href", "https://creator.unify.tn");
    			attr_dev(a0, "class", "item svelte-11x29hc");
    			add_location(a0, file$G, 225, 20, 5334);
    			attr_dev(a1, "href", "/inprogress");
    			attr_dev(a1, "class", "item svelte-11x29hc");
    			add_location(a1, file$G, 226, 20, 5466);
    			attr_dev(a2, "href", "/inprogress");
    			attr_dev(a2, "class", "item svelte-11x29hc");
    			add_location(a2, file$G, 227, 20, 5594);
    			attr_dev(a3, "href", "/inprogress");
    			attr_dev(a3, "class", "item svelte-11x29hc");
    			add_location(a3, file$G, 228, 20, 5701);
    			attr_dev(div4, "class", "items svelte-11x29hc");
    			add_location(div4, file$G, 224, 16, 5293);
    			attr_dev(div5, "class", "using svelte-11x29hc");
    			add_location(div5, file$G, 222, 12, 5157);
    			attr_dev(div6, "class", "title svelte-11x29hc");
    			add_location(div6, file$G, 232, 16, 5893);
    			attr_dev(a4, "href", "/inprogress");
    			attr_dev(a4, "class", "item svelte-11x29hc");
    			add_location(a4, file$G, 234, 20, 6013);
    			attr_dev(a5, "href", "/inprogress");
    			attr_dev(a5, "class", "item svelte-11x29hc");
    			add_location(a5, file$G, 235, 20, 6122);
    			attr_dev(a6, "href", "/contactus");
    			attr_dev(a6, "class", "item svelte-11x29hc");
    			add_location(a6, file$G, 236, 20, 6228);
    			attr_dev(a7, "href", "/payment");
    			attr_dev(a7, "class", "item svelte-11x29hc");
    			add_location(a7, file$G, 237, 20, 6347);
    			attr_dev(a8, "href", "/terms");
    			attr_dev(a8, "class", "item svelte-11x29hc");
    			add_location(a8, file$G, 238, 20, 6475);
    			attr_dev(a9, "href", "/policy");
    			attr_dev(a9, "class", "item svelte-11x29hc");
    			add_location(a9, file$G, 239, 20, 6577);
    			attr_dev(a10, "href", "/shipping&delivery");
    			attr_dev(a10, "class", "item svelte-11x29hc");
    			add_location(a10, file$G, 240, 20, 6687);
    			attr_dev(div7, "class", "items svelte-11x29hc");
    			add_location(div7, file$G, 233, 16, 5972);
    			attr_dev(div8, "class", "about svelte-11x29hc");
    			add_location(div8, file$G, 231, 12, 5856);
    			attr_dev(div9, "class", "title svelte-11x29hc");
    			add_location(div9, file$G, 245, 16, 6907);
    			if (img1.src !== (img1_src_value = "/img/misc/fb.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "fb");
    			attr_dev(img1, "class", "svelte-11x29hc");
    			add_location(img1, file$G, 247, 96, 7120);
    			attr_dev(a11, "target", "_blank");
    			attr_dev(a11, "href", "https://www.facebook.com/Unifytn-109100961216305");
    			attr_dev(a11, "class", "svelte-11x29hc");
    			add_location(a11, file$G, 247, 20, 7044);
    			if (img2.src !== (img2_src_value = "/img/misc/instagram.png")) attr_dev(img2, "src", img2_src_value);
    			attr_dev(img2, "alt", "fb");
    			attr_dev(img2, "class", "svelte-11x29hc");
    			add_location(img2, file$G, 248, 82, 7245);
    			attr_dev(a12, "target", "_blank");
    			attr_dev(a12, "href", "https://www.instagram.com/unify.tn");
    			attr_dev(a12, "class", "svelte-11x29hc");
    			add_location(a12, file$G, 248, 20, 7183);
    			attr_dev(div10, "class", "items svelte-11x29hc");
    			add_location(div10, file$G, 246, 16, 7003);
    			attr_dev(div11, "class", "follow svelte-11x29hc");
    			add_location(div11, file$G, 244, 12, 6869);
    			attr_dev(div12, "class", "right_part svelte-11x29hc");
    			add_location(div12, file$G, 220, 8, 5117);
    			attr_dev(div13, "class", "top svelte-11x29hc");
    			add_location(div13, file$G, 205, 4, 4478);
    			if (img3.src !== (img3_src_value = "/img/misc/heart2.png")) attr_dev(img3, "src", img3_src_value);
    			attr_dev(img3, "alt", "heart");
    			attr_dev(img3, "class", "svelte-11x29hc");
    			add_location(img3, file$G, 272, 12, 8123);
    			attr_dev(span0, "class", "credits svelte-11x29hc");
    			add_location(span0, file$G, 267, 8, 7973);
    			attr_dev(span1, "class", "brand svelte-11x29hc");
    			add_location(span1, file$G, 281, 9, 8314);
    			attr_dev(span2, "class", "svelte-11x29hc");
    			add_location(span2, file$G, 282, 9, 8357);
    			attr_dev(div14, "class", "copyright svelte-11x29hc");
    			add_location(div14, file$G, 266, 4, 7940);
    			attr_dev(div15, "class", "right_top_shape svelte-11x29hc");
    			add_location(div15, file$G, 288, 4, 8500);
    			attr_dev(div16, "class", "left_bottom_shape svelte-11x29hc");
    			add_location(div16, file$G, 289, 4, 8541);
    			attr_dev(footer, "class", "svelte-11x29hc");
    			add_location(footer, file$G, 204, 0, 4464);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, footer, anchor);
    			append_dev(footer, div13);
    			append_dev(div13, div2);
    			append_dev(div2, div0);
    			append_dev(div0, img0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div13, t3);
    			append_dev(div13, div12);
    			append_dev(div12, div5);
    			append_dev(div5, div3);
    			append_dev(div3, t4);
    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			append_dev(div4, a0);
    			append_dev(a0, t6);
    			append_dev(div4, t7);
    			append_dev(div4, a1);
    			append_dev(a1, t8);
    			append_dev(div4, t9);
    			append_dev(div4, a2);
    			append_dev(a2, t10);
    			append_dev(div4, t11);
    			append_dev(div4, a3);
    			append_dev(a3, t12);
    			append_dev(div12, t13);
    			append_dev(div12, div8);
    			append_dev(div8, div6);
    			append_dev(div6, t14);
    			append_dev(div8, t15);
    			append_dev(div8, div7);
    			append_dev(div7, a4);
    			append_dev(a4, t16);
    			append_dev(div7, t17);
    			append_dev(div7, a5);
    			append_dev(a5, t18);
    			append_dev(div7, t19);
    			append_dev(div7, a6);
    			append_dev(a6, t20);
    			append_dev(div7, t21);
    			append_dev(div7, a7);
    			append_dev(a7, t22);
    			append_dev(div7, t23);
    			append_dev(div7, a8);
    			append_dev(a8, t24);
    			append_dev(div7, t25);
    			append_dev(div7, a9);
    			append_dev(a9, t26);
    			append_dev(div7, t27);
    			append_dev(div7, a10);
    			append_dev(a10, t28);
    			append_dev(div12, t29);
    			append_dev(div12, div11);
    			append_dev(div11, div9);
    			append_dev(div9, t30);
    			append_dev(div11, t31);
    			append_dev(div11, div10);
    			append_dev(div10, a11);
    			append_dev(a11, img1);
    			append_dev(div10, t32);
    			append_dev(div10, a12);
    			append_dev(a12, img2);
    			append_dev(footer, t33);
    			append_dev(footer, div14);
    			append_dev(div14, span0);
    			append_dev(span0, t34);
    			append_dev(span0, t35);
    			append_dev(span0, img3);
    			append_dev(span0, t36);
    			append_dev(span0, t37);
    			append_dev(div14, t38);
    			append_dev(div14, span1);
    			append_dev(div14, t40);
    			append_dev(div14, span2);
    			append_dev(span2, t41);
    			append_dev(footer, t42);
    			append_dev(footer, div15);
    			append_dev(footer, t43);
    			append_dev(footer, div16);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a1)),
    					action_destroyer(link.call(null, a2)),
    					action_destroyer(link.call(null, a3)),
    					action_destroyer(link.call(null, a4)),
    					action_destroyer(link.call(null, a5)),
    					action_destroyer(link.call(null, a6)),
    					action_destroyer(link.call(null, a7)),
    					action_destroyer(link.call(null, a8)),
    					action_destroyer(link.call(null, a9)),
    					action_destroyer(link.call(null, a10))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$lang*/ 1 && t2_value !== (t2_value = ({
    				en: "Unify is the first platform dedicated to content creation in Tunisia that connects content creators and their supporters.",
    				fr: "Unify est la première plateforme dédiée à la création de contenu en Tunisie qui met en relation les créateurs de contenu et leurs fans."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*$lang*/ 1 && t4_value !== (t4_value = ({
    				en: "Creators’ Hub",
    				fr: "Hub des créateurs"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*$lang*/ 1 && t6_value !== (t6_value = ({ en: "Merch", fr: "Marchandise" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*$lang*/ 1 && t8_value !== (t8_value = ({
    				en: "Custom Design",
    				fr: "Design Personnalisé"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*$lang*/ 1 && t10_value !== (t10_value = ({ en: "Donation", fr: "Don" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*$lang*/ 1 && t12_value !== (t12_value = ({ en: "Subscription", fr: "Abonnements" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*$lang*/ 1 && t14_value !== (t14_value = ({ en: "Unify", fr: "Unify" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*$lang*/ 1 && t16_value !== (t16_value = ({ en: "About", fr: "À propos" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t16, t16_value);
    			if (dirty & /*$lang*/ 1 && t18_value !== (t18_value = ({ en: "Brand", fr: "Brand" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t18, t18_value);
    			if (dirty & /*$lang*/ 1 && t20_value !== (t20_value = ({ en: "Contact us", fr: "Contactez-nous" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t20, t20_value);

    			if (dirty & /*$lang*/ 1 && t22_value !== (t22_value = ({
    				en: "Methods of Payment",
    				fr: "Modes de paiement"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t22, t22_value);

    			if (dirty & /*$lang*/ 1 && t24_value !== (t24_value = ({ en: "Terms", fr: "Termes" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t24, t24_value);
    			if (dirty & /*$lang*/ 1 && t26_value !== (t26_value = ({ en: "Policies", fr: "Politiques" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t26, t26_value);

    			if (dirty & /*$lang*/ 1 && t28_value !== (t28_value = ({
    				en: "Shipping & Delivery",
    				fr: "Expédition & Livraison"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t28, t28_value);

    			if (dirty & /*$lang*/ 1 && t30_value !== (t30_value = ({
    				en: "Social Media",
    				fr: "Réseaux sociaux"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t30, t30_value);

    			if (dirty & /*$lang*/ 1 && t34_value !== (t34_value = ({ en: "Crafted With", fr: "Réalisé avec" })[/*$lang*/ ctx[0]] + "")) set_data_dev(t34, t34_value);
    			if (dirty & /*$lang*/ 1 && t37_value !== (t37_value = ({ en: "By", fr: "Par " })[/*$lang*/ ctx[0]] + "")) set_data_dev(t37, t37_value);

    			if (dirty & /*$lang*/ 1 && t41_value !== (t41_value = ({
    				en: "@ All rights reserved",
    				fr: "@ Tous Droits réservés "
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t41, t41_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(footer);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(0, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Footer", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Footer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ lang, link, $lang });
    	return [$lang];
    }

    class Footer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Footer",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src\routes\UserProfile.svelte generated by Svelte v3.32.3 */

    const { console: console_1$j } = globals;
    const file$H = "src\\routes\\UserProfile.svelte";

    // (134:0) {#if allowed}
    function create_if_block$q(ctx) {
    	let navbarunify;
    	let t0;
    	let router;
    	let t1;
    	let footer;
    	let current;
    	navbarunify = new NavbarUnify({ $$inline: true });

    	router = new Router({
    			props: {
    				url: /*url*/ ctx[0],
    				$$slots: { default: [create_default_slot$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarunify.$$.fragment);
    			t0 = space();
    			create_component(router.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarunify, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(router, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const router_changes = {};
    			if (dirty & /*url*/ 1) router_changes.url = /*url*/ ctx[0];

    			if (dirty & /*$$scope, currentPage, $lang, $user*/ 156) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarunify.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarunify.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarunify, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(router, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(134:0) {#if allowed}",
    		ctx
    	});

    	return block;
    }

    // (164:16) <Route  path="/">
    function create_default_slot_4$1(ctx) {
    	let redirector;
    	let current;

    	redirector = new Redirector({
    			props: { path: "/myaccount/profile" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(redirector.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(redirector, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(redirector.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(redirector.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(redirector, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(164:16) <Route  path=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (168:16) <Route  path="/profile">
    function create_default_slot_3$1(ctx) {
    	let profile;
    	let current;
    	profile = new Profile({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(profile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(profile, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(profile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(profile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(profile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(168:16) <Route  path=\\\"/profile\\\">",
    		ctx
    	});

    	return block;
    }

    // (171:16) <Route  path="/wishlist">
    function create_default_slot_2$1(ctx) {
    	let wishlist;
    	let current;
    	wishlist = new Wishlist({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wishlist.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wishlist, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wishlist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wishlist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wishlist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(171:16) <Route  path=\\\"/wishlist\\\">",
    		ctx
    	});

    	return block;
    }

    // (174:16) <Route  path="/orders">
    function create_default_slot_1$1(ctx) {
    	let orders;
    	let current;
    	orders = new Orders({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(orders.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(orders, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(orders.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(orders.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(orders, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(174:16) <Route  path=\\\"/orders\\\">",
    		ctx
    	});

    	return block;
    }

    // (136:0) <Router url="{url}">
    function create_default_slot$2(ctx) {
    	let div4;
    	let div2;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;

    	let t1_value = (/*$user*/ ctx[3].displayName
    	? /*$user*/ ctx[3].displayName
    	: "User") + "";

    	let t1;
    	let t2;
    	let div1;
    	let a0;
    	let t3_value = ({ en: "Profile", fr: "Profile" })[/*$lang*/ ctx[4]] + "";
    	let t3;
    	let a0_class_value;
    	let t4;
    	let a1;
    	let t5_value = ({ en: "Wishlist", fr: "Liste d'envies" })[/*$lang*/ ctx[4]] + "";
    	let t5;
    	let a1_class_value;
    	let t6;
    	let a2;
    	let t7_value = ({ en: "Orders", fr: "Commandes" })[/*$lang*/ ctx[4]] + "";
    	let t7;
    	let a2_class_value;
    	let t8;
    	let hr;
    	let t9;
    	let div3;
    	let route0;
    	let t10;
    	let route1;
    	let t11;
    	let route2;
    	let t12;
    	let route3;
    	let current;
    	let mounted;
    	let dispose;

    	route0 = new Route({
    			props: {
    				path: "/",
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route1 = new Route({
    			props: {
    				path: "/profile",
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route2 = new Route({
    			props: {
    				path: "/wishlist",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route3 = new Route({
    			props: {
    				path: "/orders",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div2 = element("div");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div1 = element("div");
    			a0 = element("a");
    			t3 = text(t3_value);
    			t4 = space();
    			a1 = element("a");
    			t5 = text(t5_value);
    			t6 = space();
    			a2 = element("a");
    			t7 = text(t7_value);
    			t8 = space();
    			hr = element("hr");
    			t9 = space();
    			div3 = element("div");
    			create_component(route0.$$.fragment);
    			t10 = space();
    			create_component(route1.$$.fragment);
    			t11 = space();
    			create_component(route2.$$.fragment);
    			t12 = space();
    			create_component(route3.$$.fragment);
    			if (img.src !== (img_src_value = "/img/misc/user.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "profilepic");
    			attr_dev(img, "class", "svelte-1tjqpy2");
    			add_location(img, file$H, 138, 12, 3409);
    			attr_dev(div0, "class", "u_name svelte-1tjqpy2");
    			add_location(div0, file$H, 139, 12, 3472);
    			attr_dev(a0, "class", a0_class_value = "" + (null_to_empty(/*currentPage*/ ctx[2] == "profile" ? "active" : "") + " svelte-1tjqpy2"));
    			attr_dev(a0, "href", "/myaccount/profile");
    			add_location(a0, file$H, 141, 16, 3595);
    			attr_dev(a1, "class", a1_class_value = "" + (null_to_empty(/*currentPage*/ ctx[2] == "wishlist" ? "active" : "") + " svelte-1tjqpy2"));
    			attr_dev(a1, "href", "/myaccount/wishlist");
    			add_location(a1, file$H, 147, 16, 3846);
    			attr_dev(a2, "class", a2_class_value = "" + (null_to_empty(/*currentPage*/ ctx[2] == "orders" ? "active" : "") + " svelte-1tjqpy2"));
    			attr_dev(a2, "href", "/myaccount/orders");
    			add_location(a2, file$H, 153, 16, 4110);
    			attr_dev(div1, "class", "nav svelte-1tjqpy2");
    			add_location(div1, file$H, 140, 12, 3560);
    			attr_dev(hr, "class", "mobilehr svelte-1tjqpy2");
    			add_location(hr, file$H, 160, 12, 4379);
    			attr_dev(div2, "class", "profile_pic svelte-1tjqpy2");
    			add_location(div2, file$H, 137, 8, 3370);
    			attr_dev(div3, "class", "profile_nav svelte-1tjqpy2");
    			add_location(div3, file$H, 162, 8, 4428);
    			attr_dev(div4, "class", "layout User_profile svelte-1tjqpy2");
    			add_location(div4, file$H, 136, 4, 3327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div2);
    			append_dev(div2, img);
    			append_dev(div2, t0);
    			append_dev(div2, div0);
    			append_dev(div0, t1);
    			append_dev(div2, t2);
    			append_dev(div2, div1);
    			append_dev(div1, a0);
    			append_dev(a0, t3);
    			append_dev(div1, t4);
    			append_dev(div1, a1);
    			append_dev(a1, t5);
    			append_dev(div1, t6);
    			append_dev(div1, a2);
    			append_dev(a2, t7);
    			append_dev(div2, t8);
    			append_dev(div2, hr);
    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			mount_component(route0, div3, null);
    			append_dev(div3, t10);
    			mount_component(route1, div3, null);
    			append_dev(div3, t11);
    			mount_component(route2, div3, null);
    			append_dev(div3, t12);
    			mount_component(route3, div3, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a0)),
    					action_destroyer(link.call(null, a1)),
    					action_destroyer(link.call(null, a2))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$user*/ 8) && t1_value !== (t1_value = (/*$user*/ ctx[3].displayName
    			? /*$user*/ ctx[3].displayName
    			: "User") + "")) set_data_dev(t1, t1_value);

    			if ((!current || dirty & /*$lang*/ 16) && t3_value !== (t3_value = ({ en: "Profile", fr: "Profile" })[/*$lang*/ ctx[4]] + "")) set_data_dev(t3, t3_value);

    			if (!current || dirty & /*currentPage*/ 4 && a0_class_value !== (a0_class_value = "" + (null_to_empty(/*currentPage*/ ctx[2] == "profile" ? "active" : "") + " svelte-1tjqpy2"))) {
    				attr_dev(a0, "class", a0_class_value);
    			}

    			if ((!current || dirty & /*$lang*/ 16) && t5_value !== (t5_value = ({ en: "Wishlist", fr: "Liste d'envies" })[/*$lang*/ ctx[4]] + "")) set_data_dev(t5, t5_value);

    			if (!current || dirty & /*currentPage*/ 4 && a1_class_value !== (a1_class_value = "" + (null_to_empty(/*currentPage*/ ctx[2] == "wishlist" ? "active" : "") + " svelte-1tjqpy2"))) {
    				attr_dev(a1, "class", a1_class_value);
    			}

    			if ((!current || dirty & /*$lang*/ 16) && t7_value !== (t7_value = ({ en: "Orders", fr: "Commandes" })[/*$lang*/ ctx[4]] + "")) set_data_dev(t7, t7_value);

    			if (!current || dirty & /*currentPage*/ 4 && a2_class_value !== (a2_class_value = "" + (null_to_empty(/*currentPage*/ ctx[2] == "orders" ? "active" : "") + " svelte-1tjqpy2"))) {
    				attr_dev(a2, "class", a2_class_value);
    			}

    			const route0_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				route0_changes.$$scope = { dirty, ctx };
    			}

    			route0.$set(route0_changes);
    			const route1_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				route1_changes.$$scope = { dirty, ctx };
    			}

    			route1.$set(route1_changes);
    			const route2_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				route2_changes.$$scope = { dirty, ctx };
    			}

    			route2.$set(route2_changes);
    			const route3_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				route3_changes.$$scope = { dirty, ctx };
    			}

    			route3.$set(route3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			destroy_component(route0);
    			destroy_component(route1);
    			destroy_component(route2);
    			destroy_component(route3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(136:0) <Router url=\\\"{url}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*allowed*/ ctx[1] && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*allowed*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*allowed*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let currentPage;
    	let $user;
    	let $lang;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(3, $user = $$value));
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(4, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("UserProfile", slots, []);
    	let { params = {} } = $$props;
    	console.log(params);
    	let { url } = $$props;

    	let unsubscribeUser = () => {
    		
    	};

    	let allowed = false;

    	onMount(() => {
    		unsubscribeUser = user.subscribe(v => {
    			if (v == undefined) {
    				navigate("/");
    			} else if (v == 0) ; else {
    				$$invalidate(1, allowed = true);
    				document.title = "Unify - Profile";
    			}
    		});
    	});

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	const writable_props = ["params", "url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$j.warn(`<UserProfile> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("params" in $$props) $$invalidate(5, params = $$props.params);
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    	};

    	$$self.$capture_state = () => ({
    		Layout,
    		onMount,
    		onDestroy,
    		navigate,
    		Router,
    		Link,
    		Route,
    		link,
    		user,
    		Profile,
    		Orders,
    		Wishlist,
    		Redirector,
    		Footer,
    		NavbarUnify,
    		lang,
    		params,
    		url,
    		unsubscribeUser,
    		allowed,
    		currentPage,
    		$user,
    		$lang
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(5, params = $$props.params);
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    		if ("allowed" in $$props) $$invalidate(1, allowed = $$props.allowed);
    		if ("currentPage" in $$props) $$invalidate(2, currentPage = $$props.currentPage);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*params*/ 32) {
    			$$invalidate(2, currentPage = params["*"]);
    		}
    	};

    	return [url, allowed, currentPage, $user, $lang, params];
    }

    class UserProfile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, { params: 5, url: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UserProfile",
    			options,
    			id: create_fragment$O.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*url*/ ctx[0] === undefined && !("url" in props)) {
    			console_1$j.warn("<UserProfile> was created without expected prop 'url'");
    		}
    	}

    	get params() {
    		throw new Error("<UserProfile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<UserProfile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get url() {
    		throw new Error("<UserProfile>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<UserProfile>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\routes\ForgotPassword.svelte generated by Svelte v3.32.3 */
    const file$I = "src\\routes\\ForgotPassword.svelte";

    // (167:4) {#if errorMessage}
    function create_if_block_1$h(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*errorMessage*/ ctx[0]);
    			attr_dev(div, "class", "error-container svelte-1v66tch");
    			add_location(div, file$I, 167, 8, 4021);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errorMessage*/ 1) set_data_dev(t, /*errorMessage*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(167:4) {#if errorMessage}",
    		ctx
    	});

    	return block;
    }

    // (172:4) {#if sent}
    function create_if_block$r(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Email Sent";
    			attr_dev(div, "class", "success-container svelte-1v66tch");
    			add_location(div, file$I, 172, 8, 4131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(172:4) {#if sent}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let div7;
    	let a;
    	let img;
    	let img_src_value;
    	let t0;
    	let t1;
    	let div0;
    	let t3;
    	let t4;
    	let t5;
    	let div2;
    	let div1;
    	let i;
    	let t6;
    	let input;
    	let t7;
    	let div4;
    	let div3;
    	let button;
    	let t9;
    	let div5;
    	let t10;
    	let div6;
    	let mounted;
    	let dispose;
    	let if_block0 = /*errorMessage*/ ctx[0] && create_if_block_1$h(ctx);
    	let if_block1 = /*sent*/ ctx[2] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			a = element("a");
    			img = element("img");
    			t0 = text("Unify");
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Write your email";
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			div2 = element("div");
    			div1 = element("div");
    			i = element("i");
    			t6 = space();
    			input = element("input");
    			t7 = space();
    			div4 = element("div");
    			div3 = element("div");
    			button = element("button");
    			button.textContent = "Send";
    			t9 = space();
    			div5 = element("div");
    			t10 = space();
    			div6 = element("div");
    			if (img.src !== (img_src_value = "./img/logo.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "svelte-1v66tch");
    			add_location(img, file$I, 161, 8, 3870);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "u_logo svelte-1v66tch");
    			add_location(a, file$I, 160, 4, 3824);
    			attr_dev(div0, "class", "title svelte-1v66tch");
    			add_location(div0, file$I, 163, 4, 3930);
    			attr_dev(i, "class", "far fa-envelope svelte-1v66tch");
    			add_location(i, file$I, 178, 12, 4330);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "class", "verification svelte-1v66tch");
    			attr_dev(input, "placeholder", "Email");
    			add_location(input, file$I, 179, 12, 4373);
    			attr_dev(div1, "class", "input");
    			add_location(div1, file$I, 177, 8, 4257);
    			attr_dev(div2, "class", "inputContainer svelte-1v66tch");
    			add_location(div2, file$I, 176, 4, 4219);
    			attr_dev(button, "class", "send_btn svelte-1v66tch");
    			add_location(button, file$I, 189, 26, 4629);
    			attr_dev(div3, "class", "send");
    			add_location(div3, file$I, 189, 8, 4611);
    			attr_dev(div4, "class", "verification_btns svelte-1v66tch");
    			add_location(div4, file$I, 187, 4, 4568);
    			attr_dev(div5, "class", "circle_top svelte-1v66tch");
    			add_location(div5, file$I, 194, 4, 4730);
    			attr_dev(div6, "class", "circle_bottom svelte-1v66tch");
    			add_location(div6, file$I, 195, 4, 4762);
    			attr_dev(div7, "class", "left_side svelte-1v66tch");
    			add_location(div7, file$I, 159, 0, 3795);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, a);
    			append_dev(a, img);
    			append_dev(a, t0);
    			append_dev(div7, t1);
    			append_dev(div7, div0);
    			append_dev(div7, t3);
    			if (if_block0) if_block0.m(div7, null);
    			append_dev(div7, t4);
    			if (if_block1) if_block1.m(div7, null);
    			append_dev(div7, t5);
    			append_dev(div7, div2);
    			append_dev(div2, div1);
    			append_dev(div1, i);
    			append_dev(div1, t6);
    			append_dev(div1, input);
    			/*input_binding*/ ctx[4](input);
    			append_dev(div7, t7);
    			append_dev(div7, div4);
    			append_dev(div4, div3);
    			append_dev(div3, button);
    			append_dev(div7, t9);
    			append_dev(div7, div5);
    			append_dev(div7, t10);
    			append_dev(div7, div6);

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a)),
    					listen_dev(div1, "submit", prevent_default(/*sendRecovery*/ ctx[3]), false, true, false),
    					listen_dev(button, "click", /*sendRecovery*/ ctx[3], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*errorMessage*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$h(ctx);
    					if_block0.c();
    					if_block0.m(div7, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*sent*/ ctx[2]) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block$r(ctx);
    					if_block1.c();
    					if_block1.m(div7, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			/*input_binding*/ ctx[4](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ForgotPassword", slots, []);
    	let errorMessage;
    	let email;
    	let sent = false;

    	onMount(() => {
    		document.title = "Unify - Password Reset";
    	});

    	const sendRecovery = async () => {
    		$$invalidate(2, sent = false);

    		await auth.sendPasswordResetEmail(email.value).then(() => {
    			$$invalidate(2, sent = true);
    		}).catch(error => {
    			$$invalidate(0, errorMessage = error.message);
    			$$invalidate(2, sent = false);
    		});
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ForgotPassword> was created with unknown prop '${key}'`);
    	});

    	function input_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			email = $$value;
    			$$invalidate(1, email);
    		});
    	}

    	$$self.$capture_state = () => ({
    		auth,
    		link,
    		onMount,
    		errorMessage,
    		email,
    		sent,
    		sendRecovery
    	});

    	$$self.$inject_state = $$props => {
    		if ("errorMessage" in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
    		if ("email" in $$props) $$invalidate(1, email = $$props.email);
    		if ("sent" in $$props) $$invalidate(2, sent = $$props.sent);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [errorMessage, email, sent, sendRecovery, input_binding];
    }

    class ForgotPassword extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ForgotPassword",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* src\routes\EmailVerification.svelte generated by Svelte v3.32.3 */

    const { console: console_1$k } = globals;
    const file$J = "src\\routes\\EmailVerification.svelte";

    // (195:48) 
    function create_if_block_1$i(ctx) {
    	let div5;
    	let a;
    	let img;
    	let img_src_value;
    	let t0;
    	let t1;
    	let div0;
    	let t3;
    	let t4;
    	let t5;
    	let div2;
    	let div1;
    	let button;
    	let current_block_type_index;
    	let if_block2;
    	let t6;
    	let div3;
    	let t7;
    	let div4;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*errorMessage*/ ctx[0] && create_if_block_4$5(ctx);
    	let if_block1 = /*sent*/ ctx[1] && create_if_block_3$8(ctx);
    	const if_block_creators = [create_if_block_2$a, create_else_block$j];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*submitting*/ ctx[2]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			a = element("a");
    			img = element("img");
    			t0 = text("Unify");
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Send email verification link.";
    			t3 = space();
    			if (if_block0) if_block0.c();
    			t4 = space();
    			if (if_block1) if_block1.c();
    			t5 = space();
    			div2 = element("div");
    			div1 = element("div");
    			button = element("button");
    			if_block2.c();
    			t6 = space();
    			div3 = element("div");
    			t7 = space();
    			div4 = element("div");
    			if (img.src !== (img_src_value = "./img/logo.png")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "svelte-1peyous");
    			add_location(img, file$J, 197, 8, 4926);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "u_logo svelte-1peyous");
    			add_location(a, file$J, 196, 4, 4880);
    			attr_dev(div0, "class", "title svelte-1peyous");
    			add_location(div0, file$J, 199, 4, 4986);
    			attr_dev(button, "class", "send_btn svelte-1peyous");
    			add_location(button, file$J, 218, 12, 5494);
    			attr_dev(div1, "class", "send");
    			add_location(div1, file$J, 217, 8, 5462);
    			attr_dev(div2, "class", "verification_btns svelte-1peyous");
    			add_location(div2, file$J, 215, 4, 5419);
    			attr_dev(div3, "class", "circle_top svelte-1peyous");
    			add_location(div3, file$J, 230, 4, 5761);
    			attr_dev(div4, "class", "circle_bottom svelte-1peyous");
    			add_location(div4, file$J, 231, 4, 5793);
    			attr_dev(div5, "class", "left_side svelte-1peyous");
    			add_location(div5, file$J, 195, 0, 4851);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, a);
    			append_dev(a, img);
    			append_dev(a, t0);
    			append_dev(div5, t1);
    			append_dev(div5, div0);
    			append_dev(div5, t3);
    			if (if_block0) if_block0.m(div5, null);
    			append_dev(div5, t4);
    			if (if_block1) if_block1.m(div5, null);
    			append_dev(div5, t5);
    			append_dev(div5, div2);
    			append_dev(div2, div1);
    			append_dev(div1, button);
    			if_blocks[current_block_type_index].m(button, null);
    			append_dev(div5, t6);
    			append_dev(div5, div3);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					action_destroyer(link.call(null, a)),
    					listen_dev(button, "click", /*sendEmail*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*errorMessage*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$5(ctx);
    					if_block0.c();
    					if_block0.m(div5, t4);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*sent*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_3$8(ctx);
    					if_block1.c();
    					if_block1.m(div5, t5);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block2 = if_blocks[current_block_type_index];

    				if (!if_block2) {
    					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block2.c();
    				}

    				transition_in(if_block2, 1);
    				if_block2.m(button, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(195:48) ",
    		ctx
    	});

    	return block;
    }

    // (188:0) {#if $user === 0 || $user ===undefined}
    function create_if_block$s(ctx) {
    	let div;
    	let materialspinner;
    	let current;

    	materialspinner = new MaterialSpinner({
    			props: { width: "75px", height: "75px" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(materialspinner.$$.fragment);
    			attr_dev(div, "class", "u-center-area svelte-1peyous");
    			add_location(div, file$J, 189, 4, 4700);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(materialspinner, div, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(materialspinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(188:0) {#if $user === 0 || $user ===undefined}",
    		ctx
    	});

    	return block;
    }

    // (203:4) {#if errorMessage}
    function create_if_block_4$5(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*errorMessage*/ ctx[0]);
    			attr_dev(div, "class", "error-container svelte-1peyous");
    			add_location(div, file$J, 203, 8, 5090);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*errorMessage*/ 1) set_data_dev(t, /*errorMessage*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(203:4) {#if errorMessage}",
    		ctx
    	});

    	return block;
    }

    // (208:4) {#if sent}
    function create_if_block_3$8(ctx) {
    	let div;
    	let p0;
    	let t0;
    	let t1_value = /*$user*/ ctx[3].email + "";
    	let t1;
    	let t2;
    	let t3;
    	let p1;
    	let b;
    	let t5;
    	let p2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			t0 = text("Check your email: ");
    			t1 = text(t1_value);
    			t2 = text(".");
    			t3 = space();
    			p1 = element("p");
    			b = element("b");
    			b.textContent = "Check your junk emails";
    			t5 = space();
    			p2 = element("p");
    			p2.textContent = "You can safely close this tab";
    			attr_dev(p0, "class", "svelte-1peyous");
    			add_location(p0, file$J, 209, 12, 5245);
    			add_location(b, file$J, 210, 15, 5301);
    			attr_dev(p1, "class", "svelte-1peyous");
    			add_location(p1, file$J, 210, 12, 5298);
    			attr_dev(p2, "class", "svelte-1peyous");
    			add_location(p2, file$J, 211, 12, 5348);
    			attr_dev(div, "class", "success-container svelte-1peyous");
    			add_location(div, file$J, 208, 8, 5200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(p0, t0);
    			append_dev(p0, t1);
    			append_dev(p0, t2);
    			append_dev(div, t3);
    			append_dev(div, p1);
    			append_dev(p1, b);
    			append_dev(div, t5);
    			append_dev(div, p2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$user*/ 8 && t1_value !== (t1_value = /*$user*/ ctx[3].email + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(208:4) {#if sent}",
    		ctx
    	});

    	return block;
    }

    // (222:16) {:else}
    function create_else_block$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Send");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$j.name,
    		type: "else",
    		source: "(222:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (220:16) {#if submitting}
    function create_if_block_2$a(ctx) {
    	let materialspinner;
    	let current;
    	materialspinner = new MaterialSpinner({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(materialspinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(materialspinner, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(materialspinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(materialspinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(materialspinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(220:16) {#if submitting}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$s, create_if_block_1$i];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$user*/ ctx[3] === 0 || /*$user*/ ctx[3] === undefined) return 0;
    		if (/*$user*/ ctx[3] && /*$user*/ ctx[3].emailVerified == false) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let $user;
    	validate_store(user, "user");
    	component_subscribe($$self, user, $$value => $$invalidate(3, $user = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EmailVerification", slots, []);

    	let unsubscribeUser = () => {
    		
    	};

    	onMount(() => {
    		document.title = "Unify - Email Verification";

    		unsubscribeUser = user.subscribe(v => {
    			if (v === 0) {
    				return;
    			} else if (v === undefined) {
    				navigate("/signin");
    			} else if ($user.emailVerified) {
    				let params = new URLSearchParams(location.search);

    				if (params.get("backurl") != null) {
    					navigate(params.get("backurl"));
    				} else {
    					navigate("/");
    				}
    			}
    		});
    	});

    	onDestroy(() => {
    		unsubscribeUser();
    	});

    	let errorMessage;
    	let sent = false;
    	let submitting = false;

    	const sendEmail = async () => {
    		if (submitting) {
    			return;
    		}

    		$$invalidate(2, submitting = true);
    		$$invalidate(0, errorMessage = "");

    		if ($user) {
    			new URLSearchParams(location.search);
    			let obj = { url: "https://unify.tn" + getBackurl() };
    			console.log("sending email");

    			await $user.sendEmailVerification(obj).then(function () {
    				$$invalidate(1, sent = true);
    				console.log("sent");
    			}).catch(function (error) {
    				$$invalidate(1, sent = false);
    				$$invalidate(0, errorMessage = error.message);
    				console.log(error);
    				console.log("failed");
    			}); // An error happened.
    		}

    		$$invalidate(2, submitting = false);
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$k.warn(`<EmailVerification> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		auth,
    		user,
    		onMount,
    		onDestroy,
    		navigate,
    		link,
    		MaterialSpinner,
    		getBackurl,
    		unsubscribeUser,
    		errorMessage,
    		sent,
    		submitting,
    		sendEmail,
    		$user
    	});

    	$$self.$inject_state = $$props => {
    		if ("unsubscribeUser" in $$props) unsubscribeUser = $$props.unsubscribeUser;
    		if ("errorMessage" in $$props) $$invalidate(0, errorMessage = $$props.errorMessage);
    		if ("sent" in $$props) $$invalidate(1, sent = $$props.sent);
    		if ("submitting" in $$props) $$invalidate(2, submitting = $$props.submitting);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [errorMessage, sent, submitting, $user, sendEmail];
    }

    class EmailVerification extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EmailVerification",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src\routes\InProgress.svelte generated by Svelte v3.32.3 */
    const file$K = "src\\routes\\InProgress.svelte";

    function create_fragment$R(ctx) {
    	let div3;
    	let a;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let t1;
    	let div0;
    	let t3;
    	let div2;
    	let div1;
    	let t4;
    	let img1;
    	let img1_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			a = element("a");
    			img0 = element("img");
    			t0 = text("Unify");
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Under construction";
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");
    			t4 = space();
    			img1 = element("img");
    			if (img0.src !== (img0_src_value = "./img/logo.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "logo");
    			attr_dev(img0, "class", "svelte-1otatbo");
    			add_location(img0, file$K, 97, 8, 2208);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "u_logo svelte-1otatbo");
    			add_location(a, file$K, 96, 4, 2162);
    			attr_dev(div0, "class", "title svelte-1otatbo");
    			add_location(div0, file$K, 99, 4, 2268);
    			attr_dev(div1, "class", "shadow svelte-1otatbo");
    			add_location(div1, file$K, 103, 8, 2400);
    			attr_dev(img1, "class", "under svelte-1otatbo");
    			if (img1.src !== (img1_src_value = "/img/under.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "cloud");
    			add_location(img1, file$K, 104, 8, 2431);
    			set_style(div2, "position", "relative");
    			set_style(div2, "width", "300px");
    			set_style(div2, "height", "300px");
    			add_location(div2, file$K, 102, 4, 2333);
    			attr_dev(div3, "class", "left_side svelte-1otatbo");
    			add_location(div3, file$K, 95, 0, 2133);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, a);
    			append_dev(a, img0);
    			append_dev(a, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div2, t4);
    			append_dev(div2, img1);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InProgress", slots, []);
    	document.title = "Unify - Under Construction";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InProgress> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link });
    	return [];
    }

    class InProgress extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InProgress",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* src\routes\ContactUs.svelte generated by Svelte v3.32.3 */
    const file$L = "src\\routes\\ContactUs.svelte";

    function create_fragment$S(ctx) {
    	let div3;
    	let a;
    	let img0;
    	let img0_src_value;
    	let t0;
    	let t1;
    	let div0;
    	let t3;
    	let div2;
    	let div1;
    	let t4;
    	let img1;
    	let img1_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			a = element("a");
    			img0 = element("img");
    			t0 = text("Unify");
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Contact us at contact@unify.tn";
    			t3 = space();
    			div2 = element("div");
    			div1 = element("div");
    			t4 = space();
    			img1 = element("img");
    			if (img0.src !== (img0_src_value = "./img/logo.png")) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "logo");
    			attr_dev(img0, "class", "svelte-p1tdll");
    			add_location(img0, file$L, 101, 8, 2270);
    			attr_dev(a, "href", "/");
    			attr_dev(a, "class", "u_logo svelte-p1tdll");
    			add_location(a, file$L, 100, 4, 2224);
    			attr_dev(div0, "class", "title svelte-p1tdll");
    			add_location(div0, file$L, 103, 4, 2330);
    			attr_dev(div1, "class", "shadow svelte-p1tdll");
    			add_location(div1, file$L, 107, 8, 2474);
    			attr_dev(img1, "class", "under svelte-p1tdll");
    			if (img1.src !== (img1_src_value = "/img/contact.png")) attr_dev(img1, "src", img1_src_value);
    			attr_dev(img1, "alt", "cloud");
    			add_location(img1, file$L, 108, 8, 2505);
    			set_style(div2, "position", "relative");
    			set_style(div2, "width", "300px");
    			set_style(div2, "height", "300px");
    			add_location(div2, file$L, 106, 4, 2407);
    			attr_dev(div3, "class", "left_side svelte-p1tdll");
    			add_location(div3, file$L, 99, 0, 2195);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, a);
    			append_dev(a, img0);
    			append_dev(a, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div0);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			append_dev(div2, t4);
    			append_dev(div2, img1);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ContactUs", slots, []);

    	onMount(() => {
    		document.title = "Unify - Contact Us";
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ContactUs> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ link, onMount });
    	return [];
    }

    class ContactUs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContactUs",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }

    /* src\components\Notifications.svelte generated by Svelte v3.32.3 */

    const { console: console_1$l } = globals;
    const file$M = "src\\components\\Notifications.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (161:16) {#if toast?.data?.uniqueActions}
    function create_if_block$t(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*toast*/ ctx[8].data.uniqueActions;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*toasts, deleteToast*/ 3) {
    				each_value_1 = /*toast*/ ctx[8].data.uniqueActions;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$6(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(161:16) {#if toast?.data?.uniqueActions}",
    		ctx
    	});

    	return block;
    }

    // (162:20) {#each toast.data.uniqueActions as action}
    function create_each_block_1$6(ctx) {
    	let div;
    	let t0_value = /*action*/ ctx[11].text + "";
    	let t0;
    	let t1;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*action*/ ctx[11], /*toast*/ ctx[8]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			attr_dev(div, "class", "u-t-action svelte-5uudmr");
    			add_location(div, file$M, 162, 24, 3896);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);

    			if (!mounted) {
    				dispose = listen_dev(div, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*toasts*/ 1 && t0_value !== (t0_value = /*action*/ ctx[11].text + "")) set_data_dev(t0, t0_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(162:20) {#each toast.data.uniqueActions as action}",
    		ctx
    	});

    	return block;
    }

    // (146:4) {#each toasts as toast (toast.num)}
    function create_each_block$f(key_1, ctx) {
    	let div6;
    	let div0;
    	let div0_style_value;
    	let t0;
    	let div3;
    	let div1;
    	let t1_value = /*toast*/ ctx[8].data.title + "";
    	let t1;
    	let t2;
    	let div2;
    	let t3_value = /*toast*/ ctx[8].data.content + "";
    	let t3;
    	let t4;
    	let div5;
    	let t5;
    	let div4;
    	let t7;
    	let div6_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*toast*/ ctx[8]?.data?.uniqueActions && create_if_block$t(ctx);

    	function click_handler_1() {
    		return /*click_handler_1*/ ctx[3](/*toast*/ ctx[8]);
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			div6 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			t1 = text(t1_value);
    			t2 = space();
    			div2 = element("div");
    			t3 = text(t3_value);
    			t4 = space();
    			div5 = element("div");
    			if (if_block) if_block.c();
    			t5 = space();
    			div4 = element("div");
    			div4.textContent = "Dismiss";
    			t7 = space();
    			attr_dev(div0, "class", "u-t-band svelte-5uudmr");
    			attr_dev(div0, "style", div0_style_value = "background: " + /*toast*/ ctx[8].data.accentColor + ";");
    			add_location(div0, file$M, 147, 12, 3335);
    			attr_dev(div1, "class", "u-t-title svelte-5uudmr");
    			add_location(div1, file$M, 152, 16, 3506);
    			attr_dev(div2, "class", "u-t-text svelte-5uudmr");
    			add_location(div2, file$M, 155, 16, 3611);
    			attr_dev(div3, "class", "u-t-content svelte-5uudmr");
    			add_location(div3, file$M, 151, 12, 3462);
    			attr_dev(div4, "class", "u-t-action svelte-5uudmr");
    			add_location(div4, file$M, 167, 16, 4120);
    			attr_dev(div5, "class", "u-actions svelte-5uudmr");
    			add_location(div5, file$M, 159, 12, 3733);
    			attr_dev(div6, "class", "u-toast shadow-6 svelte-5uudmr");
    			add_location(div6, file$M, 146, 8, 3246);
    			this.first = div6;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div6, anchor);
    			append_dev(div6, div0);
    			append_dev(div6, t0);
    			append_dev(div6, div3);
    			append_dev(div3, div1);
    			append_dev(div1, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, t3);
    			append_dev(div6, t4);
    			append_dev(div6, div5);
    			if (if_block) if_block.m(div5, null);
    			append_dev(div5, t5);
    			append_dev(div5, div4);
    			append_dev(div6, t7);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div4, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (!current || dirty & /*toasts*/ 1 && div0_style_value !== (div0_style_value = "background: " + /*toast*/ ctx[8].data.accentColor + ";")) {
    				attr_dev(div0, "style", div0_style_value);
    			}

    			if ((!current || dirty & /*toasts*/ 1) && t1_value !== (t1_value = /*toast*/ ctx[8].data.title + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*toasts*/ 1) && t3_value !== (t3_value = /*toast*/ ctx[8].data.content + "")) set_data_dev(t3, t3_value);

    			if (/*toast*/ ctx[8]?.data?.uniqueActions) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					if_block.m(div5, t5);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!div6_transition) div6_transition = create_bidirectional_transition(div6, fly, { x: 200, duration: 300 }, true);
    				div6_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div6_transition) div6_transition = create_bidirectional_transition(div6, fly, { x: 200, duration: 300 }, false);
    			div6_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div6);
    			if (if_block) if_block.d();
    			if (detaching && div6_transition) div6_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(146:4) {#each toasts as toast (toast.num)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*toasts*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*toast*/ ctx[8].num;
    	validate_each_keys(ctx, each_value, get_each_context$f, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$f(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$f(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "u-notifications svelte-5uudmr");
    			add_location(div, file$M, 144, 0, 3166);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*deleteToast, toasts*/ 3) {
    				each_value = /*toasts*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$f, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$f, null, get_each_context$f);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Notifications", slots, []);
    	let toasts = [];
    	let createdToasts = 0;
    	let toastDuration = 15000;

    	let template = {
    		accentColor: "#F0A92E;",
    		title: "Delete",
    		content: "an error happend",
    		uniqueActions: [
    			{
    				text: "Checkout",
    				func: () => {
    					console.log("doing func");
    				}
    			}
    		]
    	};

    	const notifcolors = {
    		"alert": "#f5b353",
    		"error": "#e26d8e",
    		"success": "#4aba73"
    	};

    	notification.subscribe(value => {
    		if (value == 0) {
    			return;
    		}

    		createdToasts++;

    		if (notifcolors[value.accentColor]) {
    			value.accentColor = notifcolors[value.accentColor];
    		}

    		let newToast = { num: createdToasts, data: value };

    		let timeOutFn = setTimeout(
    			() => {
    				deleteToast(newToast);
    			},
    			toastDuration
    		);

    		newToast.timer = timeOutFn;
    		$$invalidate(0, toasts = [newToast, ...toasts]);
    	});

    	let deleteToast = t => {
    		clearTimeout(t.timer);
    		$$invalidate(0, toasts = toasts.filter(i => i.num != t.num));
    	};

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$l.warn(`<Notifications> was created with unknown prop '${key}'`);
    	});

    	const click_handler = (action, toast) => {
    		action.func();
    		deleteToast(toast);
    	};

    	const click_handler_1 = toast => {
    		deleteToast(toast);
    	};

    	$$self.$capture_state = () => ({
    		notification,
    		fly,
    		toasts,
    		createdToasts,
    		toastDuration,
    		template,
    		notifcolors,
    		deleteToast
    	});

    	$$self.$inject_state = $$props => {
    		if ("toasts" in $$props) $$invalidate(0, toasts = $$props.toasts);
    		if ("createdToasts" in $$props) createdToasts = $$props.createdToasts;
    		if ("toastDuration" in $$props) toastDuration = $$props.toastDuration;
    		if ("template" in $$props) template = $$props.template;
    		if ("deleteToast" in $$props) $$invalidate(1, deleteToast = $$props.deleteToast);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [toasts, deleteToast, click_handler, click_handler_1];
    }

    class Notifications extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Notifications",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    /* src\components\CheckoutPage\OrderCompleted.svelte generated by Svelte v3.32.3 */
    const file$N = "src\\components\\CheckoutPage\\OrderCompleted.svelte";

    function create_fragment$U(ctx) {
    	let div5;
    	let div4;
    	let div1;
    	let div0;
    	let t0;
    	let svg;
    	let path;
    	let polyline;
    	let t1;
    	let div3;
    	let t2;
    	let div2;
    	let t3;
    	let t4;
    	let t5;
    	let a;
    	let t6;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			svg = svg_element("svg");
    			path = svg_element("path");
    			polyline = svg_element("polyline");
    			t1 = space();
    			div3 = element("div");
    			t2 = text("Your order has been registred.\r\n        ");
    			div2 = element("div");
    			t3 = text("Order Number : ");
    			t4 = text(/*orderID*/ ctx[0]);
    			t5 = space();
    			a = element("a");
    			t6 = text("Go back");
    			attr_dev(div0, "class", "trigger");
    			toggle_class(div0, "drawn", /*drawn*/ ctx[1]);
    			add_location(div0, file$N, 95, 8, 2314);
    			attr_dev(path, "class", "circ path svelte-1tbtryo");
    			set_style(path, "fill", "#ffffff");
    			set_style(path, "stroke-linejoin", "round");
    			set_style(path, "stroke-miterlimit", "10");
    			attr_dev(path, "d", "\r\n            M30.5,6.5L30.5,6.5c6.6,6.6,6.6,17.4,0,24l0,0c-6.6,6.6-17.4,6.6-24,0l0,0c-6.6-6.6-6.6-17.4,0-24l0,0C13.1-0.2,23.9-0.2,30.5,6.5z");
    			add_location(path, file$N, 98, 8, 2591);
    			attr_dev(polyline, "class", "tick path svelte-1tbtryo");
    			set_style(polyline, "fill", "none");
    			set_style(polyline, "stroke", "#46B978");
    			set_style(polyline, "stroke-width", "3");
    			set_style(polyline, "stroke-linejoin", "round");
    			set_style(polyline, "stroke-miterlimit", "10");
    			attr_dev(polyline, "points", "\r\n            11.6,20 15.9,24.2 26.4,13.8 ");
    			add_location(polyline, file$N, 101, 8, 2850);
    			attr_dev(svg, "version", "1.1");
    			attr_dev(svg, "id", "tick");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg, "x", "0px");
    			attr_dev(svg, "y", "0px");
    			attr_dev(svg, "viewBox", "0 0 37 37");
    			set_style(svg, "enable-background", "new 0 0 37 37");
    			attr_dev(svg, "xml:space", "preserve");
    			attr_dev(svg, "class", "svelte-1tbtryo");
    			add_location(svg, file$N, 96, 8, 2363);
    			attr_dev(div1, "class", "tickAnimation");
    			add_location(div1, file$N, 93, 8, 2275);
    			attr_dev(div2, "class", "orderID svelte-1tbtryo");
    			add_location(div2, file$N, 109, 8, 3138);
    			attr_dev(a, "class", "u-button svelte-1tbtryo");
    			attr_dev(a, "href", /*backurl*/ ctx[2]);
    			add_location(a, file$N, 112, 8, 3223);
    			attr_dev(div3, "class", "orderInfo svelte-1tbtryo");
    			add_location(div3, file$N, 107, 4, 3065);
    			attr_dev(div4, "class", "opacity svelte-1tbtryo");
    			add_location(div4, file$N, 91, 4, 2242);
    			attr_dev(div5, "class", "container svelte-1tbtryo");
    			add_location(div5, file$N, 89, 0, 2207);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div4);
    			append_dev(div4, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t0);
    			append_dev(div1, svg);
    			append_dev(svg, path);
    			append_dev(svg, polyline);
    			append_dev(div4, t1);
    			append_dev(div4, div3);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, t3);
    			append_dev(div2, t4);
    			append_dev(div3, t5);
    			append_dev(div3, a);
    			append_dev(a, t6);

    			if (!mounted) {
    				dispose = action_destroyer(link.call(null, a));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*drawn*/ 2) {
    				toggle_class(div0, "drawn", /*drawn*/ ctx[1]);
    			}

    			if (dirty & /*orderID*/ 1) set_data_dev(t4, /*orderID*/ ctx[0]);

    			if (dirty & /*backurl*/ 4) {
    				attr_dev(a, "href", /*backurl*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("OrderCompleted", slots, []);
    	let orderID = "-";
    	let drawn = false;
    	let backurl = "/";

    	onMount(() => {
    		setTimeout(
    			() => {
    				$$invalidate(1, drawn = true);
    			},
    			400
    		);

    		document.title = "Unify - Order Completed";
    		let params = new URLSearchParams(location.search);
    		$$invalidate(0, orderID = params.get("orderid") || "-");
    		$$invalidate(2, backurl = params.get("backurl") || "/");
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OrderCompleted> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ onMount, link, orderID, drawn, backurl });

    	$$self.$inject_state = $$props => {
    		if ("orderID" in $$props) $$invalidate(0, orderID = $$props.orderID);
    		if ("drawn" in $$props) $$invalidate(1, drawn = $$props.drawn);
    		if ("backurl" in $$props) $$invalidate(2, backurl = $$props.backurl);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [orderID, drawn, backurl];
    }

    class OrderCompleted extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OrderCompleted",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    /* src\routes\Terms.svelte generated by Svelte v3.32.3 */
    const file$O = "src\\routes\\Terms.svelte";

    function create_fragment$V(ctx) {
    	let div20;
    	let h1;
    	let t1;
    	let h4;
    	let t3;
    	let div19;
    	let div0;
    	let t5;
    	let div1;
    	let t7;
    	let div2;
    	let t9;
    	let div3;
    	let t11;
    	let div4;
    	let t13;
    	let div5;
    	let t15;
    	let div6;
    	let t17;
    	let div7;
    	let t19;
    	let div8;
    	let t21;
    	let div9;
    	let t23;
    	let div10;
    	let t25;
    	let div11;
    	let t27;
    	let div12;
    	let t29;
    	let div13;
    	let t31;
    	let div14;
    	let t33;
    	let div15;
    	let t35;
    	let div16;
    	let t37;
    	let div17;
    	let t39;
    	let div18;

    	const block = {
    		c: function create() {
    			div20 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Terms of Service";
    			t1 = space();
    			h4 = element("h4");
    			h4.textContent = "Last Updated on February 14, 2021";
    			t3 = space();
    			div19 = element("div");
    			div0 = element("div");
    			div0.textContent = "OVERVIEW";
    			t5 = space();
    			div1 = element("div");
    			div1.textContent = "This website (\"unify.tn\"), Creator Sites, Unify Merch, and Unify Mobile App is operated by Unify. Throughout the site, the terms “we”, “us”, and “our” refer to Unify. Unify offers this website, including all information, tools, and services available from this site to you, the user, conditioned upon your acceptance of all terms, conditions, policies, and notices stated here.\r\n            By visiting our site and/or using our service, you engage in our “Service” and agree to be bound by the following terms and conditions (“Terms of Service”, “Terms”), including those additional terms and conditions and policies referenced herein and/or available by hyperlink. These Terms of Service apply to all users of the site, including without limitation users who are browsers, vendors, customers, tippers, merchants, and/or contributors of content.\r\n            Please read these Terms of Service carefully before accessing or using our website. By accessing or using any part of the site, you agree to be bound by these Terms of Service. If you do not agree to all the terms and conditions of this agreement, then you may not access the website or use any services. If these Terms of Service are considered an offer, acceptance is expressly limited to these Terms of Service.\r\n            Any new features or tools which are added to the service shall also be subject to the Terms of Service. You can review the most current version of the Terms of Service at any time on this page. We reserve the right to update, change or replace any part of these Terms of Service by posting updates and/or changes to our website. It is your responsibility to check this page periodically for changes. Your continued use of or access to the website following the posting of any changes constitutes acceptance of those changes.";
    			t7 = space();
    			div2 = element("div");
    			div2.textContent = "INTRODUCTION";
    			t9 = space();
    			div3 = element("div");
    			div3.textContent = "Unify is the #1 dedicated platform for Creators in Tunisia. Unify offerings span mobile application, Creator Sites, Merch, and offers services for the Creator to design and optimize their content creation. Unify is a service that allows viewers to send and receive money (\"tips\") through third-party payment processors. Our service also features a variety of widgets that can utilize various data from our services, and data from authorized third parties.";
    			t11 = space();
    			div4 = element("div");
    			div4.textContent = "USER TERMS";
    			t13 = space();
    			div5 = element("div");
    			div5.textContent = "The Unify Services are not available to persons under the age of 13. If you are between the ages of 13 and 18 (or between 13 and the age of legal majority in your jurisdiction of residence), you may only use the Unify Services under the supervision of a parent or legal guardian who agrees to be bound by these Terms of Service.\r\n            The Unify Services are also not available to any users previously removed from the Unify Services by Unify. Finally, the Unify Services are not available to any persons barred from receiving them under the laws of Tunisia or applicable laws in any other jurisdiction. You may not use our service for any illegal or unauthorized purpose nor may you, in the use of the Service, violate any laws in your jurisdiction (including but not limited to copyright laws). You must not transmit any worms or viruses or any code of a destructive nature. A breach or violation of any of the Terms will result in an immediate termination of your Services.\r\n            BY USING THE UNIFY SERVICES, YOU REPRESENT THAT YOU ARE AT LEAST 13 YEARS OF AGE, THAT YOUR PARENT OR LEGAL GUARDIAN AGREES TO BE BOUND BY THESE TERMS OF SERVICE IF YOU ARE BETWEEN 13 AND THE AGE OF LEGAL MAJORITY IN YOUR JURISDICTION OF RESIDENCE, AND THAT YOU HAVE NOT BEEN PREVIOUSLY REMOVED FROM OR PROHIBITED FROM RECEIVING THE UNIFY SERVICES.";
    			t15 = space();
    			div6 = element("div");
    			div6.textContent = "GENERAL CONDITIONS";
    			t17 = space();
    			div7 = element("div");
    			div7.textContent = "We reserve the right to refuse service to anyone for any reason at any time.\r\n            You agree not to reproduce, duplicate, copy, sell, resell, or exploit any portion of the Service, use of the Service, or access to the Service or any contact on the website through which the service is provided, without express written permission by us.\r\n            The headings used in this Agreement are included for convenience only and will not limit or otherwise affect these Terms.\r\n            ACCURACY, COMPLETENESS, AND TIMELINESS OF INFORMATION\r\n            We are not responsible if information made available on this site is not accurate, complete, or current. The material on this site is provided for general information only and should not be relied upon or used as the sole basis for making decisions without consulting primary, more accurate, more complete or timelier sources of information. Any reliance on the material on this site is at your own risk.\r\n            This site may contain certain historical information. Historical information, necessarily, is not current and is provided for your reference only. We reserve the right to modify the contents of this site at any time, but we have no obligation to update any information on our site. You agree that it is your responsibility to monitor changes to our site.\r\n            MODIFICATIONS TO THE SERVICE AND PRICES\r\n            Prices and/or fees for our Service are subject to change without notice.\r\n            We reserve the right at any time to modify or discontinue the Service (or any part or content thereof) without notice at any time.\r\n\r\n            We shall not be liable to you or to any third-party for any modification, price change, suspension, or discontinuance of the Service.";
    			t19 = space();
    			div8 = element("div");
    			div8.textContent = "THIRD PARTY SITE PROMOTIONS";
    			t21 = space();
    			div9 = element("div");
    			div9.textContent = "When using Unify, you may have the option to utilize a third party site to earn credits for the use of Unify as well as other promotional offers. You authorize Unify to share information with these third party sites if you choose to take part in the promotion. You additionally agree to the Terms of Service of these third party sites when utilizing them, as well as the Terms of Service of Unify when leaving the Unify site to take part in the third party site’s interface to earn these credits or promotions. Unify and the third party service reserve the right to withhold points earned for any reason. Unify reserves the right to remove your account credit balance if you are in breach of the Terms of Service, or suspected of a breach in the Terms of Service, on the third party site or on Unify.";
    			t23 = space();
    			div10 = element("div");
    			div10.textContent = "Registration";
    			t25 = space();
    			div11 = element("div");
    			div11.textContent = "To register your account to start receiving credit card tips, you must provide your personal information (which cannot be changed after registration) and bank account information. To enable withdrawals and transfers from your account, you must submit valid personal and bank information which will be sent for verification to our payment processor. This private information is never saved on Unify’ website. You will be required to submit valid government identification if requested by our payment processor for further verification. In consideration of use of the Service, you agree to maintain and update true, accurate, current and complete Registration Data. If you provide any information that is untrue, inaccurate, not current or incomplete, or if our payment processor has reasonable grounds to suspect that such information is untrue, inaccurate, not current or incomplete, our payment processor may suspend or terminate your account and refuse any and all current or future use of the Service or any portion thereof. Failure to submit required information may limit your ability to withdraw and/or transfer your pending balance.\r\n            To register your account to start receiving PayPal tips, you must provide your email associated with your Paypal account. Failure to submit the correct information may limit your ability to receive tips.";
    			t27 = space();
    			div12 = element("div");
    			div12.textContent = "Withdrawal/Transfers";
    			t29 = space();
    			div13 = element("div");
    			div13.textContent = "You may transfer funds from your available account balance once your bank account information is completely filled on your Unify account. Funds from credit card tips are only available for transfer through bank accounts. You agree to send any type of identification that is asked for in order to complete a withdrawal request. You agree to pay a fee for any withdrawal. If bank account information is incorrect, you are subject to a delay in your withdrawal and/or losing your funds and/or account deletion. You must contact Unify support immediately.";
    			t31 = space();
    			div14 = element("div");
    			div14.textContent = "UNIFY MERCH";
    			t33 = space();
    			div15 = element("div");
    			div15.textContent = "- USER CONTENT";
    			t35 = space();
    			div16 = element("div");
    			div16.textContent = "You grant Unify a license to use the User Content and materials you post to the Site. By posting, downloading, displaying, performing, transmitting, or otherwise distributing User Content to the Site, you are granting Unify, its affiliates, officers, directors, employees, consultants, agents, and representatives a license to use User Content in connection with the operation of the Internet business of Unify, its affiliates, officers, directors, employees, consultants, agents, and representatives, including without limitation, a right to copy, distribute, transmit, publicly display, publicly perform, reproduce, edit, translate, and reformat User Content. You agree that Unify may publish or otherwise disclose your name in connection with your User Content. By posting User Content on the Site, you warrant and represent that you own the rights to the User Content or are otherwise authorized to post, distribute, display, perform, transmit, or otherwise distribute User Content.";
    			t37 = space();
    			div17 = element("div");
    			div17.textContent = "- COMPLIANCE WITH INTELLECTUAL PROPERTY LAWS";
    			t39 = space();
    			div18 = element("div");
    			div18.textContent = "When accessing or using the Site, you agree to obey the law and to respect the intellectual property rights of others. Your use of the Site is at all times governed by and subject to laws regarding copyright, trademark, patent, and trade secret ownership and use of intellectual property. You agree not to upload, download, display, perform, transmit, or otherwise distribute any information or Content in violation of any party's copyrights, trademarks, patents, trade secrets, or other intellectual property or proprietary rights. You agree to abide by laws regarding copyright, trademark, patent, and trade secret ownership and use of intellectual property, and you shall be solely responsible for any violations of any laws and for any infringements of any intellectual property rights caused by any Content you provide, post, or transmit, or that is provided or transmitted using your user name or user ID. The burden of proving that any Content does not violate any laws or intellectual property rights rests solely with you.";
    			attr_dev(h1, "class", "svelte-1lgqx0m");
    			add_location(h1, file$O, 66, 4, 1256);
    			attr_dev(h4, "class", "lastUpdate svelte-1lgqx0m");
    			add_location(h4, file$O, 67, 4, 1287);
    			attr_dev(div0, "class", "head svelte-1lgqx0m");
    			add_location(div0, file$O, 70, 8, 1395);
    			attr_dev(div1, "class", "body svelte-1lgqx0m");
    			add_location(div1, file$O, 71, 8, 1438);
    			attr_dev(div2, "class", "head svelte-1lgqx0m");
    			add_location(div2, file$O, 81, 8, 3330);
    			attr_dev(div3, "class", "body svelte-1lgqx0m");
    			add_location(div3, file$O, 82, 8, 3377);
    			attr_dev(div4, "class", "head svelte-1lgqx0m");
    			add_location(div4, file$O, 85, 8, 3881);
    			attr_dev(div5, "class", "body svelte-1lgqx0m");
    			add_location(div5, file$O, 86, 8, 3926);
    			attr_dev(div6, "class", "head svelte-1lgqx0m");
    			add_location(div6, file$O, 93, 8, 5343);
    			attr_dev(div7, "class", "body svelte-1lgqx0m");
    			add_location(div7, file$O, 94, 8, 5396);
    			attr_dev(div8, "class", "head svelte-1lgqx0m");
    			add_location(div8, file$O, 109, 8, 7232);
    			attr_dev(div9, "class", "body svelte-1lgqx0m");
    			add_location(div9, file$O, 110, 8, 7294);
    			attr_dev(div10, "class", "head svelte-1lgqx0m");
    			add_location(div10, file$O, 131, 8, 11438);
    			attr_dev(div11, "class", "body svelte-1lgqx0m");
    			add_location(div11, file$O, 132, 8, 11485);
    			attr_dev(div12, "class", "head svelte-1lgqx0m");
    			add_location(div12, file$O, 138, 8, 12914);
    			attr_dev(div13, "class", "body svelte-1lgqx0m");
    			add_location(div13, file$O, 139, 8, 12969);
    			attr_dev(div14, "class", "head svelte-1lgqx0m");
    			add_location(div14, file$O, 143, 8, 13585);
    			attr_dev(div15, "class", "h3 svelte-1lgqx0m");
    			add_location(div15, file$O, 144, 8, 13631);
    			attr_dev(div16, "class", "body svelte-1lgqx0m");
    			add_location(div16, file$O, 145, 8, 13678);
    			attr_dev(div17, "class", "h3 svelte-1lgqx0m");
    			add_location(div17, file$O, 148, 8, 14724);
    			attr_dev(div18, "class", "body svelte-1lgqx0m");
    			add_location(div18, file$O, 149, 8, 14801);
    			attr_dev(div19, "class", "u-container svelte-1lgqx0m");
    			add_location(div19, file$O, 68, 4, 1354);
    			attr_dev(div20, "class", "u-view svelte-1lgqx0m");
    			add_location(div20, file$O, 65, 0, 1230);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div20, anchor);
    			append_dev(div20, h1);
    			append_dev(div20, t1);
    			append_dev(div20, h4);
    			append_dev(div20, t3);
    			append_dev(div20, div19);
    			append_dev(div19, div0);
    			append_dev(div19, t5);
    			append_dev(div19, div1);
    			append_dev(div19, t7);
    			append_dev(div19, div2);
    			append_dev(div19, t9);
    			append_dev(div19, div3);
    			append_dev(div19, t11);
    			append_dev(div19, div4);
    			append_dev(div19, t13);
    			append_dev(div19, div5);
    			append_dev(div19, t15);
    			append_dev(div19, div6);
    			append_dev(div19, t17);
    			append_dev(div19, div7);
    			append_dev(div19, t19);
    			append_dev(div19, div8);
    			append_dev(div19, t21);
    			append_dev(div19, div9);
    			append_dev(div19, t23);
    			append_dev(div19, div10);
    			append_dev(div19, t25);
    			append_dev(div19, div11);
    			append_dev(div19, t27);
    			append_dev(div19, div12);
    			append_dev(div19, t29);
    			append_dev(div19, div13);
    			append_dev(div19, t31);
    			append_dev(div19, div14);
    			append_dev(div19, t33);
    			append_dev(div19, div15);
    			append_dev(div19, t35);
    			append_dev(div19, div16);
    			append_dev(div19, t37);
    			append_dev(div19, div17);
    			append_dev(div19, t39);
    			append_dev(div19, div18);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div20);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Terms", slots, []);

    	onMount(() => {
    		window.scrollTo({ top: 0 });
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Terms> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ onMount });
    	return [];
    }

    class Terms extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Terms",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* src\routes\PaymentMethods.svelte generated by Svelte v3.32.3 */
    const file$P = "src\\routes\\PaymentMethods.svelte";

    function create_fragment$W(ctx) {
    	let div14;
    	let h1;

    	let t0_value = ({
    		en: "Methods of payment",
    		fr: "Méthodes de paiement"
    	})[/*$lang*/ ctx[0]] + "";

    	let t0;
    	let t1;
    	let div0;

    	let t2_value = ({
    		en: "Last Updated on February 14, 2021",
    		fr: "Dernière mise à jour le 14 février 2021"
    	})[/*$lang*/ ctx[0]] + "";

    	let t2;
    	let t3;
    	let div13;
    	let div1;

    	let t4_value = ({
    		en: "Methods of payment",
    		fr: "Méthodes de paiement"
    	})[/*$lang*/ ctx[0]] + "";

    	let t4;
    	let t5;
    	let div2;

    	let t6_value = ({
    		en: "When finalising the order, you can view the total amount of your order.",
    		fr: "Lors de la finalisation de la commande, vous pouvez visualiser le montant total de votre commande."
    	})[/*$lang*/ ctx[0]] + "";

    	let t6;
    	let t7;
    	let div3;

    	let t8_value = ({
    		en: "1) Payment in cash on delivery: ",
    		fr: "1) Paiement en espèces à la livraison:"
    	})[/*$lang*/ ctx[0]] + "";

    	let t8;
    	let t9;
    	let div4;

    	let t10_value = ({
    		en: "A- Make sure to prepare the exact amount of the order. The delivery people do not always have cash on hand to give you change",
    		fr: "A- Assurez-vous de préparer le montant exact de la commande. Les livreurs ne disposent pas toujours d'espèces pour vous rendre la monnaie."
    	})[/*$lang*/ ctx[0]] + "";

    	let t10;
    	let t11;
    	let div5;

    	let t12_value = ({
    		en: "B- We only accept payment in Tunisian Dinar.",
    		fr: "B- Nous acceptons uniquement le paiement en Dinar Tunisien."
    	})[/*$lang*/ ctx[0]] + "";

    	let t12;
    	let t13;
    	let div6;

    	let t14_value = ({
    		en: "2) Secure payment by national and international credit cards (coming soon): ",
    		fr: "2) Paiement sécurisé par carte bancaire nationales et internationales (prochainement):"
    	})[/*$lang*/ ctx[0]] + "";

    	let t14;
    	let t15;
    	let div7;

    	let t16_value = ({
    		en: "A- Once you have placed your order, simply select the online credit card payment option.",
    		fr: "A- Après avoir procédé à la passation de commande, sélectionnez simplement l'option de paiement par carte bancaire en ligne."
    	})[/*$lang*/ ctx[0]] + "";

    	let t16;
    	let t17;
    	let div8;

    	let t18_value = ({
    		en: "B- Enter your card details such as:",
    		fr: "B- Entrez les détails de votre carte tels que:"
    	})[/*$lang*/ ctx[0]] + "";

    	let t18;
    	let t19;
    	let div9;

    	let t20_value = ({
    		en: "- Card number",
    		fr: "- Numéro de carte"
    	})[/*$lang*/ ctx[0]] + "";

    	let t20;
    	let t21;
    	let div10;

    	let t22_value = ({
    		en: "- Expiry date",
    		fr: "- Date d'expiration"
    	})[/*$lang*/ ctx[0]] + "";

    	let t22;
    	let t23;
    	let div11;

    	let t24_value = ({
    		en: "- Security code",
    		fr: "- Code de sécurité"
    	})[/*$lang*/ ctx[0]] + "";

    	let t24;
    	let t25;
    	let div12;

    	let t26_value = ({
    		en: "Then complete your order. To secure your payment, some banks will ask you for a security code, sent to your phone.",
    		fr: "Ensuite, complétez votre commande. Pour sécuriser votre paiement, certaines banques vous demanderont un code de sécurité, envoyé à votre téléphone."
    	})[/*$lang*/ ctx[0]] + "";

    	let t26;

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div13 = element("div");
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			div3 = element("div");
    			t8 = text(t8_value);
    			t9 = space();
    			div4 = element("div");
    			t10 = text(t10_value);
    			t11 = space();
    			div5 = element("div");
    			t12 = text(t12_value);
    			t13 = space();
    			div6 = element("div");
    			t14 = text(t14_value);
    			t15 = space();
    			div7 = element("div");
    			t16 = text(t16_value);
    			t17 = space();
    			div8 = element("div");
    			t18 = text(t18_value);
    			t19 = space();
    			div9 = element("div");
    			t20 = text(t20_value);
    			t21 = space();
    			div10 = element("div");
    			t22 = text(t22_value);
    			t23 = space();
    			div11 = element("div");
    			t24 = text(t24_value);
    			t25 = space();
    			div12 = element("div");
    			t26 = text(t26_value);
    			attr_dev(h1, "class", "svelte-oe1dxf");
    			add_location(h1, file$P, 87, 4, 1719);
    			attr_dev(div0, "class", "lastUpdate svelte-oe1dxf");
    			add_location(div0, file$P, 88, 4, 1798);
    			attr_dev(div1, "class", "head svelte-oe1dxf");
    			add_location(div1, file$P, 92, 8, 1979);
    			attr_dev(div2, "class", "body svelte-oe1dxf");
    			add_location(div2, file$P, 93, 8, 2078);
    			attr_dev(div3, "class", "h4 svelte-oe1dxf");
    			add_location(div3, file$P, 98, 8, 2360);
    			attr_dev(div4, "class", "h5 svelte-oe1dxf");
    			add_location(div4, file$P, 99, 12, 2492);
    			attr_dev(div5, "class", "h5 svelte-oe1dxf");
    			add_location(div5, file$P, 104, 12, 2899);
    			attr_dev(div6, "class", "h4 svelte-oe1dxf");
    			add_location(div6, file$P, 111, 8, 3142);
    			attr_dev(div7, "class", "h4 svelte-oe1dxf");
    			add_location(div7, file$P, 112, 12, 3366);
    			attr_dev(div8, "class", "h5 svelte-oe1dxf");
    			add_location(div8, file$P, 117, 12, 3722);
    			attr_dev(div9, "class", "h6 svelte-oe1dxf");
    			add_location(div9, file$P, 122, 16, 3947);
    			attr_dev(div10, "class", "h6 svelte-oe1dxf");
    			add_location(div10, file$P, 127, 16, 4137);
    			attr_dev(div11, "class", "h6 svelte-oe1dxf");
    			add_location(div11, file$P, 132, 16, 4329);
    			attr_dev(div12, "class", "body svelte-oe1dxf");
    			add_location(div12, file$P, 137, 8, 4514);
    			attr_dev(div13, "class", "u-container svelte-oe1dxf");
    			add_location(div13, file$P, 89, 4, 1932);
    			attr_dev(div14, "class", "u-view svelte-oe1dxf");
    			add_location(div14, file$P, 86, 0, 1693);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, h1);
    			append_dev(h1, t0);
    			append_dev(div14, t1);
    			append_dev(div14, div0);
    			append_dev(div0, t2);
    			append_dev(div14, t3);
    			append_dev(div14, div13);
    			append_dev(div13, div1);
    			append_dev(div1, t4);
    			append_dev(div13, t5);
    			append_dev(div13, div2);
    			append_dev(div2, t6);
    			append_dev(div13, t7);
    			append_dev(div13, div3);
    			append_dev(div3, t8);
    			append_dev(div13, t9);
    			append_dev(div13, div4);
    			append_dev(div4, t10);
    			append_dev(div13, t11);
    			append_dev(div13, div5);
    			append_dev(div5, t12);
    			append_dev(div13, t13);
    			append_dev(div13, div6);
    			append_dev(div6, t14);
    			append_dev(div13, t15);
    			append_dev(div13, div7);
    			append_dev(div7, t16);
    			append_dev(div13, t17);
    			append_dev(div13, div8);
    			append_dev(div8, t18);
    			append_dev(div13, t19);
    			append_dev(div13, div9);
    			append_dev(div9, t20);
    			append_dev(div13, t21);
    			append_dev(div13, div10);
    			append_dev(div10, t22);
    			append_dev(div13, t23);
    			append_dev(div13, div11);
    			append_dev(div11, t24);
    			append_dev(div13, t25);
    			append_dev(div13, div12);
    			append_dev(div12, t26);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$lang*/ 1 && t0_value !== (t0_value = ({
    				en: "Methods of payment",
    				fr: "Méthodes de paiement"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$lang*/ 1 && t2_value !== (t2_value = ({
    				en: "Last Updated on February 14, 2021",
    				fr: "Dernière mise à jour le 14 février 2021"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*$lang*/ 1 && t4_value !== (t4_value = ({
    				en: "Methods of payment",
    				fr: "Méthodes de paiement"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*$lang*/ 1 && t6_value !== (t6_value = ({
    				en: "When finalising the order, you can view the total amount of your order.",
    				fr: "Lors de la finalisation de la commande, vous pouvez visualiser le montant total de votre commande."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*$lang*/ 1 && t8_value !== (t8_value = ({
    				en: "1) Payment in cash on delivery: ",
    				fr: "1) Paiement en espèces à la livraison:"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t8, t8_value);

    			if (dirty & /*$lang*/ 1 && t10_value !== (t10_value = ({
    				en: "A- Make sure to prepare the exact amount of the order. The delivery people do not always have cash on hand to give you change",
    				fr: "A- Assurez-vous de préparer le montant exact de la commande. Les livreurs ne disposent pas toujours d'espèces pour vous rendre la monnaie."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t10, t10_value);

    			if (dirty & /*$lang*/ 1 && t12_value !== (t12_value = ({
    				en: "B- We only accept payment in Tunisian Dinar.",
    				fr: "B- Nous acceptons uniquement le paiement en Dinar Tunisien."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t12, t12_value);

    			if (dirty & /*$lang*/ 1 && t14_value !== (t14_value = ({
    				en: "2) Secure payment by national and international credit cards (coming soon): ",
    				fr: "2) Paiement sécurisé par carte bancaire nationales et internationales (prochainement):"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t14, t14_value);

    			if (dirty & /*$lang*/ 1 && t16_value !== (t16_value = ({
    				en: "A- Once you have placed your order, simply select the online credit card payment option.",
    				fr: "A- Après avoir procédé à la passation de commande, sélectionnez simplement l'option de paiement par carte bancaire en ligne."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t16, t16_value);

    			if (dirty & /*$lang*/ 1 && t18_value !== (t18_value = ({
    				en: "B- Enter your card details such as:",
    				fr: "B- Entrez les détails de votre carte tels que:"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t18, t18_value);

    			if (dirty & /*$lang*/ 1 && t20_value !== (t20_value = ({
    				en: "- Card number",
    				fr: "- Numéro de carte"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t20, t20_value);

    			if (dirty & /*$lang*/ 1 && t22_value !== (t22_value = ({
    				en: "- Expiry date",
    				fr: "- Date d'expiration"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t22, t22_value);

    			if (dirty & /*$lang*/ 1 && t24_value !== (t24_value = ({
    				en: "- Security code",
    				fr: "- Code de sécurité"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t24, t24_value);

    			if (dirty & /*$lang*/ 1 && t26_value !== (t26_value = ({
    				en: "Then complete your order. To secure your payment, some banks will ask you for a security code, sent to your phone.",
    				fr: "Ensuite, complétez votre commande. Pour sécuriser votre paiement, certaines banques vous demanderont un code de sécurité, envoyé à votre téléphone."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t26, t26_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(0, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("PaymentMethods", slots, []);

    	onMount(() => {
    		window.scrollTo({ top: 0 });
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PaymentMethods> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ lang, onMount, $lang });
    	return [$lang];
    }

    class PaymentMethods extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PaymentMethods",
    			options,
    			id: create_fragment$W.name
    		});
    	}
    }

    /* src\routes\ShippingDelivery.svelte generated by Svelte v3.32.3 */
    const file$Q = "src\\routes\\ShippingDelivery.svelte";

    function create_fragment$X(ctx) {
    	let div7;
    	let h1;

    	let t0_value = ({
    		en: "Shipping & Delivery",
    		fr: "Expédition & Livraison"
    	})[/*$lang*/ ctx[0]] + "";

    	let t0;
    	let t1;
    	let div0;

    	let t2_value = ({
    		en: "Last Updated on February 14, 2021",
    		fr: "Dernière mise à jour le 14 février 2021"
    	})[/*$lang*/ ctx[0]] + "";

    	let t2;
    	let t3;
    	let div6;
    	let div1;

    	let t4_value = ({
    		en: "Shipping & Delivery",
    		fr: "Expédition & Livraison"
    	})[/*$lang*/ ctx[0]] + "";

    	let t4;
    	let t5;
    	let div2;

    	let t6_value = ({
    		en: "-Our delivery costs are indicated on the Unify website and concern the whole Tunisian territory.",
    		fr: "-Nos frais de livraisons sont indiqués sur le site sur le site internet Unify et concerne tout le territoire Tunisien."
    	})[/*$lang*/ ctx[0]] + "";

    	let t6;
    	let t7;
    	let br0;
    	let t8;
    	let div3;

    	let t9_value = ({
    		en: "-The costs and delivery times for items made available on unify.tn may vary. The delivery costs will be indicated on the summary of your order just before validating it.",
    		fr: "-Les frais et délais de livraison des articles mis à disposition sur unify.tn peuvent varier. Les frais de livraison seront indiqués sur le récapitulatif de votre commande juste avant de la valider."
    	})[/*$lang*/ ctx[0]] + "";

    	let t9;
    	let t10;
    	let br1;
    	let t11;
    	let div4;

    	let t12_value = ({
    		en: "-The delivery method and delivery time may vary according to the characteristics of the article (dimensions, weight, size...) and the quantity of the orders on our website.",
    		fr: "-Le mode et le délai de livraison peuvent varier en fonction des caractéristiques de l’article (Dimensions, poids, taille…) et la quantité des commandes."
    	})[/*$lang*/ ctx[0]] + "";

    	let t12;
    	let t13;
    	let br2;
    	let t14;
    	let div5;

    	let t15_value = ({
    		en: "-Standard delivery (5 to 8 working days).",
    		fr: "-Livraison standard (5 à 8 jours ouvrables)."
    	})[/*$lang*/ ctx[0]] + "";

    	let t15;

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			h1 = element("h1");
    			t0 = text(t0_value);
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div6 = element("div");
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div2 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			br0 = element("br");
    			t8 = space();
    			div3 = element("div");
    			t9 = text(t9_value);
    			t10 = space();
    			br1 = element("br");
    			t11 = space();
    			div4 = element("div");
    			t12 = text(t12_value);
    			t13 = space();
    			br2 = element("br");
    			t14 = space();
    			div5 = element("div");
    			t15 = text(t15_value);
    			attr_dev(h1, "class", "svelte-smxn3v");
    			add_location(h1, file$Q, 62, 4, 1176);
    			attr_dev(div0, "class", "lastUpdate svelte-smxn3v");
    			add_location(div0, file$Q, 63, 4, 1258);
    			attr_dev(div1, "class", "head svelte-smxn3v");
    			add_location(div1, file$Q, 67, 8, 1439);
    			attr_dev(div2, "class", "body svelte-smxn3v");
    			add_location(div2, file$Q, 68, 8, 1541);
    			add_location(br0, file$Q, 72, 14, 1858);
    			attr_dev(div3, "class", "body svelte-smxn3v");
    			add_location(div3, file$Q, 74, 8, 1874);
    			add_location(br1, file$Q, 78, 14, 2344);
    			attr_dev(div4, "class", "body svelte-smxn3v");
    			add_location(div4, file$Q, 79, 8, 2358);
    			add_location(br2, file$Q, 83, 14, 2786);
    			attr_dev(div5, "class", "body svelte-smxn3v");
    			add_location(div5, file$Q, 84, 8, 2800);
    			attr_dev(div6, "class", "u-container svelte-smxn3v");
    			add_location(div6, file$Q, 64, 4, 1392);
    			attr_dev(div7, "class", "u-view svelte-smxn3v");
    			add_location(div7, file$Q, 61, 0, 1150);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, h1);
    			append_dev(h1, t0);
    			append_dev(div7, t1);
    			append_dev(div7, div0);
    			append_dev(div0, t2);
    			append_dev(div7, t3);
    			append_dev(div7, div6);
    			append_dev(div6, div1);
    			append_dev(div1, t4);
    			append_dev(div6, t5);
    			append_dev(div6, div2);
    			append_dev(div2, t6);
    			append_dev(div2, t7);
    			append_dev(div6, br0);
    			append_dev(div6, t8);
    			append_dev(div6, div3);
    			append_dev(div3, t9);
    			append_dev(div3, t10);
    			append_dev(div6, br1);
    			append_dev(div6, t11);
    			append_dev(div6, div4);
    			append_dev(div4, t12);
    			append_dev(div4, t13);
    			append_dev(div6, br2);
    			append_dev(div6, t14);
    			append_dev(div6, div5);
    			append_dev(div5, t15);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$lang*/ 1 && t0_value !== (t0_value = ({
    				en: "Shipping & Delivery",
    				fr: "Expédition & Livraison"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*$lang*/ 1 && t2_value !== (t2_value = ({
    				en: "Last Updated on February 14, 2021",
    				fr: "Dernière mise à jour le 14 février 2021"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*$lang*/ 1 && t4_value !== (t4_value = ({
    				en: "Shipping & Delivery",
    				fr: "Expédition & Livraison"
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*$lang*/ 1 && t6_value !== (t6_value = ({
    				en: "-Our delivery costs are indicated on the Unify website and concern the whole Tunisian territory.",
    				fr: "-Nos frais de livraisons sont indiqués sur le site sur le site internet Unify et concerne tout le territoire Tunisien."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t6, t6_value);

    			if (dirty & /*$lang*/ 1 && t9_value !== (t9_value = ({
    				en: "-The costs and delivery times for items made available on unify.tn may vary. The delivery costs will be indicated on the summary of your order just before validating it.",
    				fr: "-Les frais et délais de livraison des articles mis à disposition sur unify.tn peuvent varier. Les frais de livraison seront indiqués sur le récapitulatif de votre commande juste avant de la valider."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t9, t9_value);

    			if (dirty & /*$lang*/ 1 && t12_value !== (t12_value = ({
    				en: "-The delivery method and delivery time may vary according to the characteristics of the article (dimensions, weight, size...) and the quantity of the orders on our website.",
    				fr: "-Le mode et le délai de livraison peuvent varier en fonction des caractéristiques de l’article (Dimensions, poids, taille…) et la quantité des commandes."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t12, t12_value);

    			if (dirty & /*$lang*/ 1 && t15_value !== (t15_value = ({
    				en: "-Standard delivery (5 to 8 working days).",
    				fr: "-Livraison standard (5 à 8 jours ouvrables)."
    			})[/*$lang*/ ctx[0]] + "")) set_data_dev(t15, t15_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $lang;
    	validate_store(lang, "lang");
    	component_subscribe($$self, lang, $$value => $$invalidate(0, $lang = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ShippingDelivery", slots, []);

    	onMount(() => {
    		window.scrollTo({ top: 0 });
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ShippingDelivery> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ lang, onMount, $lang });
    	return [$lang];
    }

    class ShippingDelivery extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ShippingDelivery",
    			options,
    			id: create_fragment$X.name
    		});
    	}
    }

    /* src\routes\Policy.svelte generated by Svelte v3.32.3 */
    const file$R = "src\\routes\\Policy.svelte";

    function create_fragment$Y(ctx) {
    	let div17;
    	let h1;
    	let t1;
    	let div0;
    	let t3;
    	let div16;
    	let div1;
    	let t5;
    	let div2;
    	let t7;
    	let div3;
    	let t9;
    	let div4;
    	let t11;
    	let div5;
    	let t13;
    	let div6;
    	let t15;
    	let div7;
    	let t17;
    	let div8;
    	let t19;
    	let div9;
    	let t21;
    	let div10;
    	let t23;
    	let div11;
    	let t25;
    	let div12;
    	let t27;
    	let div13;
    	let t29;
    	let div14;
    	let t31;
    	let div15;

    	const block = {
    		c: function create() {
    			div17 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Unify Privacy Policy";
    			t1 = space();
    			div0 = element("div");
    			div0.textContent = "Last Updated on February 14, 2021";
    			t3 = space();
    			div16 = element("div");
    			div1 = element("div");
    			div1.textContent = "Unify Privacy Policy";
    			t5 = space();
    			div2 = element("div");
    			div2.textContent = "This privacy policy ('Privacy Policy') governs how we, Unify and/or any other member of the Unify group (together, “Unify”, “we”, “our” or “us”) use, collect and store Personal Data we collect or receive from or about you (“User”, “you”) such as in the following use cases:";
    			t7 = space();
    			div3 = element("div");
    			div3.textContent = "1) When you browse or visit our website, https://unify.tn ('Website')";
    			t9 = space();
    			div4 = element("div");
    			div4.textContent = "2) When you make use of, or interact with, our Website";
    			t11 = space();
    			div5 = element("div");
    			div5.textContent = "1) When you create an account and/or log in clicking on “Connect with Facebook”";
    			t13 = space();
    			div6 = element("div");
    			div6.textContent = "2) When you create an account and/or log in clicking on “Connect with Google”";
    			t15 = space();
    			div7 = element("div");
    			div7.textContent = "3) When you contact us (e.g. customer support, when you submit a request, chat with us or leave us a message)";
    			t17 = space();
    			div8 = element("div");
    			div8.textContent = "3) When you make use of, or interact with our Dashboard";
    			t19 = space();
    			div9 = element("div");
    			div9.textContent = "4) When you exchange business cards with us";
    			t21 = space();
    			div10 = element("div");
    			div10.textContent = "5) When we use the Personal Data of our suppliers";
    			t23 = space();
    			div11 = element("div");
    			div11.textContent = "6) When we use the Personal Data of our customers";
    			t25 = space();
    			div12 = element("div");
    			div12.textContent = "7) When you interact with us on our social media profiles (e.g., Facebook, Instagram, Twitter, LinkedIn, etc) and we use the publicly available information.";
    			t27 = space();
    			div13 = element("div");
    			div13.textContent = "We greatly respect your privacy, which is why we make every effort to provide a platform that would live up to the highest of user privacy standards. “Personal Data” means any information that can be used, alone or together with other data, to uniquely identify any living human being. Please note that this is a master privacy policy and some of its provisions only apply to individuals in certain jurisdictions.";
    			t29 = space();
    			div14 = element("div");
    			div14.textContent = "This Privacy Policy may be updated from time to time and therefore we ask you to check back periodically for the latest version of the Privacy Policy, as indicated below. If there will be any significant changes made to the use of your Personal Data in a manner different from that stated at the time of collection, we will notify you by posting a notice on our Website or by other means";
    			t31 = space();
    			div15 = element("div");
    			div15.textContent = "If you have any questions, concerns or complaints regarding our compliance with this notice and the data protection laws, or if you wish to exercise your rights, we encourage you to first contact us at privacy@unify.tn.";
    			attr_dev(h1, "class", "svelte-1fhqjfm");
    			add_location(h1, file$R, 81, 4, 1579);
    			attr_dev(div0, "class", "lastUpdate svelte-1fhqjfm");
    			add_location(div0, file$R, 82, 4, 1614);
    			attr_dev(div1, "class", "head svelte-1fhqjfm");
    			add_location(div1, file$R, 86, 8, 1730);
    			attr_dev(div2, "class", "body svelte-1fhqjfm");
    			add_location(div2, file$R, 87, 8, 1785);
    			attr_dev(div3, "class", "h4 svelte-1fhqjfm");
    			add_location(div3, file$R, 90, 8, 2117);
    			attr_dev(div4, "class", "h4 svelte-1fhqjfm");
    			add_location(div4, file$R, 91, 8, 2218);
    			attr_dev(div5, "class", "h5 svelte-1fhqjfm");
    			add_location(div5, file$R, 92, 12, 2308);
    			attr_dev(div6, "class", "h5 svelte-1fhqjfm");
    			add_location(div6, file$R, 95, 12, 2456);
    			attr_dev(div7, "class", "h5 svelte-1fhqjfm");
    			add_location(div7, file$R, 98, 12, 2602);
    			attr_dev(div8, "class", "h4 svelte-1fhqjfm");
    			add_location(div8, file$R, 101, 8, 2775);
    			attr_dev(div9, "class", "h4 svelte-1fhqjfm");
    			add_location(div9, file$R, 102, 8, 2862);
    			attr_dev(div10, "class", "h4 svelte-1fhqjfm");
    			add_location(div10, file$R, 103, 8, 2937);
    			attr_dev(div11, "class", "h4 svelte-1fhqjfm");
    			add_location(div11, file$R, 104, 8, 3018);
    			attr_dev(div12, "class", "h4 svelte-1fhqjfm");
    			add_location(div12, file$R, 105, 8, 3099);
    			attr_dev(div13, "class", "body svelte-1fhqjfm");
    			add_location(div13, file$R, 107, 8, 3297);
    			attr_dev(div14, "class", "body svelte-1fhqjfm");
    			add_location(div14, file$R, 110, 8, 3770);
    			attr_dev(div15, "class", "body svelte-1fhqjfm");
    			add_location(div15, file$R, 113, 8, 4216);
    			attr_dev(div16, "class", "u-container svelte-1fhqjfm");
    			add_location(div16, file$R, 83, 4, 1683);
    			attr_dev(div17, "class", "u-view svelte-1fhqjfm");
    			add_location(div17, file$R, 80, 0, 1553);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div17, anchor);
    			append_dev(div17, h1);
    			append_dev(div17, t1);
    			append_dev(div17, div0);
    			append_dev(div17, t3);
    			append_dev(div17, div16);
    			append_dev(div16, div1);
    			append_dev(div16, t5);
    			append_dev(div16, div2);
    			append_dev(div16, t7);
    			append_dev(div16, div3);
    			append_dev(div16, t9);
    			append_dev(div16, div4);
    			append_dev(div16, t11);
    			append_dev(div16, div5);
    			append_dev(div16, t13);
    			append_dev(div16, div6);
    			append_dev(div16, t15);
    			append_dev(div16, div7);
    			append_dev(div16, t17);
    			append_dev(div16, div8);
    			append_dev(div16, t19);
    			append_dev(div16, div9);
    			append_dev(div16, t21);
    			append_dev(div16, div10);
    			append_dev(div16, t23);
    			append_dev(div16, div11);
    			append_dev(div16, t25);
    			append_dev(div16, div12);
    			append_dev(div16, t27);
    			append_dev(div16, div13);
    			append_dev(div16, t29);
    			append_dev(div16, div14);
    			append_dev(div16, t31);
    			append_dev(div16, div15);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div17);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Policy", slots, []);

    	onMount(() => {
    		window.scrollTo({ top: 0 });
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Policy> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ lang, onMount });
    	return [];
    }

    class Policy extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Policy",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.32.3 */

    // (39:4) <Route path="/">
    function create_default_slot_20(ctx) {
    	let navbarunify;
    	let t0;
    	let landingpage;
    	let t1;
    	let footer;
    	let current;
    	navbarunify = new NavbarUnify({ $$inline: true });
    	landingpage = new LandingPage({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarunify.$$.fragment);
    			t0 = space();
    			create_component(landingpage.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarunify, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(landingpage, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarunify.$$.fragment, local);
    			transition_in(landingpage.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarunify.$$.fragment, local);
    			transition_out(landingpage.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarunify, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(landingpage, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_20.name,
    		type: "slot",
    		source: "(39:4) <Route path=\\\"/\\\">",
    		ctx
    	});

    	return block;
    }

    // (44:4) <Route  path="/policy">
    function create_default_slot_19(ctx) {
    	let navbarunify;
    	let t0;
    	let policy;
    	let t1;
    	let footer;
    	let current;
    	navbarunify = new NavbarUnify({ $$inline: true });
    	policy = new Policy({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarunify.$$.fragment);
    			t0 = space();
    			create_component(policy.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarunify, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(policy, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarunify.$$.fragment, local);
    			transition_in(policy.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarunify.$$.fragment, local);
    			transition_out(policy.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarunify, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(policy, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_19.name,
    		type: "slot",
    		source: "(44:4) <Route  path=\\\"/policy\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:4) <Route  path="/shipping&delivery">
    function create_default_slot_18(ctx) {
    	let navbarunify;
    	let t0;
    	let shippingdelivery;
    	let t1;
    	let footer;
    	let current;
    	navbarunify = new NavbarUnify({ $$inline: true });
    	shippingdelivery = new ShippingDelivery({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarunify.$$.fragment);
    			t0 = space();
    			create_component(shippingdelivery.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarunify, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(shippingdelivery, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarunify.$$.fragment, local);
    			transition_in(shippingdelivery.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarunify.$$.fragment, local);
    			transition_out(shippingdelivery.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarunify, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(shippingdelivery, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_18.name,
    		type: "slot",
    		source: "(49:4) <Route  path=\\\"/shipping&delivery\\\">",
    		ctx
    	});

    	return block;
    }

    // (54:4) <Route  path="/payment">
    function create_default_slot_17(ctx) {
    	let navbarunify;
    	let t0;
    	let paymentmethods;
    	let t1;
    	let footer;
    	let current;
    	navbarunify = new NavbarUnify({ $$inline: true });
    	paymentmethods = new PaymentMethods({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarunify.$$.fragment);
    			t0 = space();
    			create_component(paymentmethods.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarunify, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(paymentmethods, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarunify.$$.fragment, local);
    			transition_in(paymentmethods.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarunify.$$.fragment, local);
    			transition_out(paymentmethods.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarunify, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(paymentmethods, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_17.name,
    		type: "slot",
    		source: "(54:4) <Route  path=\\\"/payment\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:4) <Route  path="/terms">
    function create_default_slot_16(ctx) {
    	let navbarunify;
    	let t0;
    	let terms;
    	let t1;
    	let footer;
    	let current;
    	navbarunify = new NavbarUnify({ $$inline: true });
    	terms = new Terms({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarunify.$$.fragment);
    			t0 = space();
    			create_component(terms.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarunify, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(terms, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarunify.$$.fragment, local);
    			transition_in(terms.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarunify.$$.fragment, local);
    			transition_out(terms.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarunify, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(terms, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_16.name,
    		type: "slot",
    		source: "(59:4) <Route  path=\\\"/terms\\\">",
    		ctx
    	});

    	return block;
    }

    // (64:4) <Route  path="/completed">
    function create_default_slot_15(ctx) {
    	let ordercompleted;
    	let current;
    	ordercompleted = new OrderCompleted({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(ordercompleted.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ordercompleted, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ordercompleted.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ordercompleted.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ordercompleted, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_15.name,
    		type: "slot",
    		source: "(64:4) <Route  path=\\\"/completed\\\">",
    		ctx
    	});

    	return block;
    }

    // (67:4) <Route  path="/inprogress">
    function create_default_slot_14(ctx) {
    	let inprogress;
    	let current;
    	inprogress = new InProgress({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(inprogress.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(inprogress, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(inprogress.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(inprogress.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(inprogress, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_14.name,
    		type: "slot",
    		source: "(67:4) <Route  path=\\\"/inprogress\\\">",
    		ctx
    	});

    	return block;
    }

    // (70:4) <Route  path="/contactus">
    function create_default_slot_13(ctx) {
    	let contactus;
    	let current;
    	contactus = new ContactUs({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(contactus.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(contactus, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(contactus.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(contactus.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(contactus, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_13.name,
    		type: "slot",
    		source: "(70:4) <Route  path=\\\"/contactus\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:4) <Route  path="/checkout">
    function create_default_slot_12(ctx) {
    	let navbarcheckout;
    	let t0;
    	let checkout;
    	let t1;
    	let footer;
    	let current;
    	navbarcheckout = new NavbarCheckout({ $$inline: true });
    	checkout = new CheckoutPage({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarcheckout.$$.fragment);
    			t0 = space();
    			create_component(checkout.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarcheckout, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(checkout, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarcheckout.$$.fragment, local);
    			transition_in(checkout.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarcheckout.$$.fragment, local);
    			transition_out(checkout.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarcheckout, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(checkout, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_12.name,
    		type: "slot",
    		source: "(73:4) <Route  path=\\\"/checkout\\\">",
    		ctx
    	});

    	return block;
    }

    // (78:4) <Route  path="/cart">
    function create_default_slot_11(ctx) {
    	let navbarunify;
    	let t0;
    	let cart;
    	let t1;
    	let footer;
    	let current;
    	navbarunify = new NavbarUnify({ $$inline: true });
    	cart = new CartPage({ $$inline: true });
    	footer = new Footer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(navbarunify.$$.fragment);
    			t0 = space();
    			create_component(cart.$$.fragment);
    			t1 = space();
    			create_component(footer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navbarunify, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(cart, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(footer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navbarunify.$$.fragment, local);
    			transition_in(cart.$$.fragment, local);
    			transition_in(footer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navbarunify.$$.fragment, local);
    			transition_out(cart.$$.fragment, local);
    			transition_out(footer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navbarunify, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(cart, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(footer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(78:4) <Route  path=\\\"/cart\\\">",
    		ctx
    	});

    	return block;
    }

    // (83:4) <Route  path="/signup">
    function create_default_slot_10(ctx) {
    	let signup;
    	let current;
    	signup = new Signup({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(signup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(signup, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(signup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(signup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(signup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(83:4) <Route  path=\\\"/signup\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:4) <Route  path="/signin">
    function create_default_slot_9(ctx) {
    	let signin;
    	let current;
    	signin = new Signin({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(signin.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(signin, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(signin.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(signin.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(signin, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(86:4) <Route  path=\\\"/signin\\\">",
    		ctx
    	});

    	return block;
    }

    // (90:4) <Route  let:params path="/myaccount/*">
    function create_default_slot_8(ctx) {
    	let userprofile;
    	let current;

    	userprofile = new UserProfile({
    			props: { params: /*params*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(userprofile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(userprofile, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const userprofile_changes = {};
    			if (dirty & /*params*/ 2) userprofile_changes.params = /*params*/ ctx[1];
    			userprofile.$set(userprofile_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(userprofile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(userprofile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(userprofile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(90:4) <Route  let:params path=\\\"/myaccount/*\\\">",
    		ctx
    	});

    	return block;
    }

    // (95:4) <Route  path="/phoneverification">
    function create_default_slot_7(ctx) {
    	let phoneverification;
    	let current;
    	phoneverification = new PhoneVerification({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(phoneverification.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(phoneverification, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(phoneverification.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(phoneverification.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(phoneverification, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(95:4) <Route  path=\\\"/phoneverification\\\">",
    		ctx
    	});

    	return block;
    }

    // (98:4) <Route  path="/emailverification">
    function create_default_slot_6(ctx) {
    	let emailverification;
    	let current;
    	emailverification = new EmailVerification({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(emailverification.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(emailverification, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(emailverification.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(emailverification.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(emailverification, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(98:4) <Route  path=\\\"/emailverification\\\">",
    		ctx
    	});

    	return block;
    }

    // (101:4) <Route  path="/forgotpassword">
    function create_default_slot_5(ctx) {
    	let forgotpassword;
    	let current;
    	forgotpassword = new ForgotPassword({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(forgotpassword.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(forgotpassword, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(forgotpassword.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(forgotpassword.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(forgotpassword, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(101:4) <Route  path=\\\"/forgotpassword\\\">",
    		ctx
    	});

    	return block;
    }

    // (125:4) <Route let:params path="/:userid/*">
    function create_default_slot_4$2(ctx) {
    	let routecreator;
    	let current;

    	routecreator = new EntryCreator({
    			props: { params: /*params*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(routecreator.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(routecreator, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const routecreator_changes = {};
    			if (dirty & /*params*/ 2) routecreator_changes.params = /*params*/ ctx[1];
    			routecreator.$set(routecreator_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(routecreator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(routecreator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(routecreator, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(125:4) <Route let:params path=\\\"/:userid/*\\\">",
    		ctx
    	});

    	return block;
    }

    // (133:4) <Route path="*">
    function create_default_slot_3$2(ctx) {
    	let notfound;
    	let current;
    	notfound = new NotFound({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(notfound.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notfound, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notfound.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notfound.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notfound, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(133:4) <Route path=\\\"*\\\">",
    		ctx
    	});

    	return block;
    }

    // (138:4) <Route path="*/*">
    function create_default_slot_2$2(ctx) {
    	let notfound;
    	let current;
    	notfound = new NotFound({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(notfound.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notfound, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notfound.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notfound.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notfound, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(138:4) <Route path=\\\"*/*\\\">",
    		ctx
    	});

    	return block;
    }

    // (143:4) <Route path="**">
    function create_default_slot_1$2(ctx) {
    	let notfound;
    	let current;
    	notfound = new NotFound({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(notfound.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notfound, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notfound.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notfound.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notfound, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(143:4) <Route path=\\\"**\\\">",
    		ctx
    	});

    	return block;
    }

    // (38:0) <Router url="{url}">
    function create_default_slot$3(ctx) {
    	let route0;
    	let t0;
    	let route1;
    	let t1;
    	let route2;
    	let t2;
    	let route3;
    	let t3;
    	let route4;
    	let t4;
    	let route5;
    	let t5;
    	let route6;
    	let t6;
    	let route7;
    	let t7;
    	let route8;
    	let t8;
    	let route9;
    	let t9;
    	let route10;
    	let t10;
    	let route11;
    	let t11;
    	let route12;
    	let t12;
    	let route13;
    	let t13;
    	let route14;
    	let t14;
    	let route15;
    	let t15;
    	let route16;
    	let t16;
    	let route17;
    	let t17;
    	let route18;
    	let t18;
    	let route19;
    	let current;

    	route0 = new Route({
    			props: {
    				path: "/",
    				$$slots: { default: [create_default_slot_20] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route1 = new Route({
    			props: {
    				path: "/policy",
    				$$slots: { default: [create_default_slot_19] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route2 = new Route({
    			props: {
    				path: "/shipping&delivery",
    				$$slots: { default: [create_default_slot_18] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route3 = new Route({
    			props: {
    				path: "/payment",
    				$$slots: { default: [create_default_slot_17] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route4 = new Route({
    			props: {
    				path: "/terms",
    				$$slots: { default: [create_default_slot_16] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route5 = new Route({
    			props: {
    				path: "/completed",
    				$$slots: { default: [create_default_slot_15] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route6 = new Route({
    			props: {
    				path: "/inprogress",
    				$$slots: { default: [create_default_slot_14] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route7 = new Route({
    			props: {
    				path: "/contactus",
    				$$slots: { default: [create_default_slot_13] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route8 = new Route({
    			props: {
    				path: "/checkout",
    				$$slots: { default: [create_default_slot_12] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route9 = new Route({
    			props: {
    				path: "/cart",
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route10 = new Route({
    			props: {
    				path: "/signup",
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route11 = new Route({
    			props: {
    				path: "/signin",
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route12 = new Route({
    			props: {
    				path: "/myaccount/*",
    				$$slots: {
    					default: [
    						create_default_slot_8,
    						({ params }) => ({ 1: params }),
    						({ params }) => params ? 2 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route13 = new Route({
    			props: {
    				path: "/phoneverification",
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route14 = new Route({
    			props: {
    				path: "/emailverification",
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route15 = new Route({
    			props: {
    				path: "/forgotpassword",
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route16 = new Route({
    			props: {
    				path: "/:userid/*",
    				$$slots: {
    					default: [
    						create_default_slot_4$2,
    						({ params }) => ({ 1: params }),
    						({ params }) => params ? 2 : 0
    					]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route17 = new Route({
    			props: {
    				path: "*",
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route18 = new Route({
    			props: {
    				path: "*/*",
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	route19 = new Route({
    			props: {
    				path: "**",
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(route0.$$.fragment);
    			t0 = space();
    			create_component(route1.$$.fragment);
    			t1 = space();
    			create_component(route2.$$.fragment);
    			t2 = space();
    			create_component(route3.$$.fragment);
    			t3 = space();
    			create_component(route4.$$.fragment);
    			t4 = space();
    			create_component(route5.$$.fragment);
    			t5 = space();
    			create_component(route6.$$.fragment);
    			t6 = space();
    			create_component(route7.$$.fragment);
    			t7 = space();
    			create_component(route8.$$.fragment);
    			t8 = space();
    			create_component(route9.$$.fragment);
    			t9 = space();
    			create_component(route10.$$.fragment);
    			t10 = space();
    			create_component(route11.$$.fragment);
    			t11 = space();
    			create_component(route12.$$.fragment);
    			t12 = space();
    			create_component(route13.$$.fragment);
    			t13 = space();
    			create_component(route14.$$.fragment);
    			t14 = space();
    			create_component(route15.$$.fragment);
    			t15 = space();
    			create_component(route16.$$.fragment);
    			t16 = space();
    			create_component(route17.$$.fragment);
    			t17 = space();
    			create_component(route18.$$.fragment);
    			t18 = space();
    			create_component(route19.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(route0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(route1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(route2, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(route3, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(route4, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(route5, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(route6, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(route7, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(route8, target, anchor);
    			insert_dev(target, t8, anchor);
    			mount_component(route9, target, anchor);
    			insert_dev(target, t9, anchor);
    			mount_component(route10, target, anchor);
    			insert_dev(target, t10, anchor);
    			mount_component(route11, target, anchor);
    			insert_dev(target, t11, anchor);
    			mount_component(route12, target, anchor);
    			insert_dev(target, t12, anchor);
    			mount_component(route13, target, anchor);
    			insert_dev(target, t13, anchor);
    			mount_component(route14, target, anchor);
    			insert_dev(target, t14, anchor);
    			mount_component(route15, target, anchor);
    			insert_dev(target, t15, anchor);
    			mount_component(route16, target, anchor);
    			insert_dev(target, t16, anchor);
    			mount_component(route17, target, anchor);
    			insert_dev(target, t17, anchor);
    			mount_component(route18, target, anchor);
    			insert_dev(target, t18, anchor);
    			mount_component(route19, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const route0_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route0_changes.$$scope = { dirty, ctx };
    			}

    			route0.$set(route0_changes);
    			const route1_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route1_changes.$$scope = { dirty, ctx };
    			}

    			route1.$set(route1_changes);
    			const route2_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route2_changes.$$scope = { dirty, ctx };
    			}

    			route2.$set(route2_changes);
    			const route3_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route3_changes.$$scope = { dirty, ctx };
    			}

    			route3.$set(route3_changes);
    			const route4_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route4_changes.$$scope = { dirty, ctx };
    			}

    			route4.$set(route4_changes);
    			const route5_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route5_changes.$$scope = { dirty, ctx };
    			}

    			route5.$set(route5_changes);
    			const route6_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route6_changes.$$scope = { dirty, ctx };
    			}

    			route6.$set(route6_changes);
    			const route7_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route7_changes.$$scope = { dirty, ctx };
    			}

    			route7.$set(route7_changes);
    			const route8_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route8_changes.$$scope = { dirty, ctx };
    			}

    			route8.$set(route8_changes);
    			const route9_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route9_changes.$$scope = { dirty, ctx };
    			}

    			route9.$set(route9_changes);
    			const route10_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route10_changes.$$scope = { dirty, ctx };
    			}

    			route10.$set(route10_changes);
    			const route11_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route11_changes.$$scope = { dirty, ctx };
    			}

    			route11.$set(route11_changes);
    			const route12_changes = {};

    			if (dirty & /*$$scope, params*/ 6) {
    				route12_changes.$$scope = { dirty, ctx };
    			}

    			route12.$set(route12_changes);
    			const route13_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route13_changes.$$scope = { dirty, ctx };
    			}

    			route13.$set(route13_changes);
    			const route14_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route14_changes.$$scope = { dirty, ctx };
    			}

    			route14.$set(route14_changes);
    			const route15_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route15_changes.$$scope = { dirty, ctx };
    			}

    			route15.$set(route15_changes);
    			const route16_changes = {};

    			if (dirty & /*$$scope, params*/ 6) {
    				route16_changes.$$scope = { dirty, ctx };
    			}

    			route16.$set(route16_changes);
    			const route17_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route17_changes.$$scope = { dirty, ctx };
    			}

    			route17.$set(route17_changes);
    			const route18_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route18_changes.$$scope = { dirty, ctx };
    			}

    			route18.$set(route18_changes);
    			const route19_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				route19_changes.$$scope = { dirty, ctx };
    			}

    			route19.$set(route19_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(route0.$$.fragment, local);
    			transition_in(route1.$$.fragment, local);
    			transition_in(route2.$$.fragment, local);
    			transition_in(route3.$$.fragment, local);
    			transition_in(route4.$$.fragment, local);
    			transition_in(route5.$$.fragment, local);
    			transition_in(route6.$$.fragment, local);
    			transition_in(route7.$$.fragment, local);
    			transition_in(route8.$$.fragment, local);
    			transition_in(route9.$$.fragment, local);
    			transition_in(route10.$$.fragment, local);
    			transition_in(route11.$$.fragment, local);
    			transition_in(route12.$$.fragment, local);
    			transition_in(route13.$$.fragment, local);
    			transition_in(route14.$$.fragment, local);
    			transition_in(route15.$$.fragment, local);
    			transition_in(route16.$$.fragment, local);
    			transition_in(route17.$$.fragment, local);
    			transition_in(route18.$$.fragment, local);
    			transition_in(route19.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(route0.$$.fragment, local);
    			transition_out(route1.$$.fragment, local);
    			transition_out(route2.$$.fragment, local);
    			transition_out(route3.$$.fragment, local);
    			transition_out(route4.$$.fragment, local);
    			transition_out(route5.$$.fragment, local);
    			transition_out(route6.$$.fragment, local);
    			transition_out(route7.$$.fragment, local);
    			transition_out(route8.$$.fragment, local);
    			transition_out(route9.$$.fragment, local);
    			transition_out(route10.$$.fragment, local);
    			transition_out(route11.$$.fragment, local);
    			transition_out(route12.$$.fragment, local);
    			transition_out(route13.$$.fragment, local);
    			transition_out(route14.$$.fragment, local);
    			transition_out(route15.$$.fragment, local);
    			transition_out(route16.$$.fragment, local);
    			transition_out(route17.$$.fragment, local);
    			transition_out(route18.$$.fragment, local);
    			transition_out(route19.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(route0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(route1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(route2, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(route3, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(route4, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(route5, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(route6, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(route7, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(route8, detaching);
    			if (detaching) detach_dev(t8);
    			destroy_component(route9, detaching);
    			if (detaching) detach_dev(t9);
    			destroy_component(route10, detaching);
    			if (detaching) detach_dev(t10);
    			destroy_component(route11, detaching);
    			if (detaching) detach_dev(t11);
    			destroy_component(route12, detaching);
    			if (detaching) detach_dev(t12);
    			destroy_component(route13, detaching);
    			if (detaching) detach_dev(t13);
    			destroy_component(route14, detaching);
    			if (detaching) detach_dev(t14);
    			destroy_component(route15, detaching);
    			if (detaching) detach_dev(t15);
    			destroy_component(route16, detaching);
    			if (detaching) detach_dev(t16);
    			destroy_component(route17, detaching);
    			if (detaching) detach_dev(t17);
    			destroy_component(route18, detaching);
    			if (detaching) detach_dev(t18);
    			destroy_component(route19, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(38:0) <Router url=\\\"{url}\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let notifications;
    	let t;
    	let router;
    	let current;
    	notifications = new Notifications({ $$inline: true });

    	router = new Router({
    			props: {
    				url: /*url*/ ctx[0],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(notifications.$$.fragment);
    			t = space();
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(notifications, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const router_changes = {};
    			if (dirty & /*url*/ 1) router_changes.url = /*url*/ ctx[0];

    			if (dirty & /*$$scope*/ 4) {
    				router_changes.$$scope = { dirty, ctx };
    			}

    			router.$set(router_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notifications.$$.fragment, local);
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notifications.$$.fragment, local);
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notifications, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	let { url = "" } = $$props;
    	const writable_props = ["url"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    	};

    	$$self.$capture_state = () => ({
    		Router,
    		Link,
    		Route,
    		NotFound,
    		LandingPage,
    		ProfilePage,
    		MerchPage,
    		SingleProductPage,
    		RouteCreator: EntryCreator,
    		NavbarUnify,
    		NavbarCheckout,
    		Cart: CartPage,
    		Checkout: CheckoutPage,
    		Signup,
    		Signin,
    		PhoneVerification,
    		UserProfile,
    		ForgotPassword,
    		EmailVerification,
    		Footer,
    		InProgress,
    		ContactUs,
    		Notifications,
    		FooterCC,
    		OrderCompleted,
    		Terms,
    		PaymentMethods,
    		ShippingDelivery,
    		Policy,
    		url
    	});

    	$$self.$inject_state = $$props => {
    		if ("url" in $$props) $$invalidate(0, url = $$props.url);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [url];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { url: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$Z.name
    		});
    	}

    	get url() {
    		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set url(value) {
    		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const app = new App({
        target: document.body,
    });

    return app;

}(AOS));
//# sourceMappingURL=bundle.js.map
